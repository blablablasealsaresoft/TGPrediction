diff --git a/ENV_CONFIGURATION.txt b/ENV_CONFIGURATION.txt
index 891a10df09971ed504bb3f146c5e3b4cc4f0083c..0a6d2525dcfe93739be662cc9898f9605edf51dd 100644
--- a/ENV_CONFIGURATION.txt
+++ b/ENV_CONFIGURATION.txt
@@ -1,274 +1,168 @@
 # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
 # ğŸš€ ELITE SOLANA TRADING BOT - CONFIGURATION TEMPLATE
 # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
 # Copy this file to .env and fill in your values
 # Never commit .env to git!
 # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
 
 # ============================================================================
 # ğŸ” CORE CREDENTIALS (REQUIRED)
 # ============================================================================
 
 # Telegram Bot Token (get from @BotFather)
 TELEGRAM_BOT_TOKEN=8455438652:AAFvrxM6GFZ91BwoohvMCezhsj7N16YFju0
 
 # Admin Telegram User ID (get from @userinfobot)
-ADMIN_CHAT_ID=6594416344
+ADMIN_CHAT_ID=8059844643
 
 # Solana RPC URLs (use paid RPC for better performance)
-SOLANA_RPC_URL=https://api.mainnet-beta.solana.com
+SOLANA_RPC_URL=https://mainnet.helius-rpc.com/?api-key=4177e73c-0edb-4e4a-9d22-4c99b9a3f8c1
 SOLANA_WS_URL=wss://api.mainnet-beta.solana.com
+FALLBACK_RPC_URL=https://api.mainnet-beta.solana.com
+FALLBACK_RPC_1=https://api.mainnet-beta.solana.com
+FALLBACK_RPC_2=https://solana-api.projectserum.com
+FALLBACK_RPC_3=https://rpc.ankr.com/solana
+SIMULATE_RPC=https://mainnet.helius-rpc.com/?api-key=4177e73c-0edb-4e4a-9d22-4c99b9a3f8c1
 
 # Optional: Your wallet private key in base58 format (for platform fees)
 WALLET_PRIVATE_KEY=2KBD49gknMGpsVSJWuUFbTPLsVLd4kMEN8n8cBERvJFML8sBzavGqpHH14mYUwDWYHZ6EdTx1DzHxto6PUsUVpke
 
+# Required master encryption key for user wallets
+WALLET_ENCRYPTION_KEY=6SZqLo3c77pzvLVyRLuYafhNuxa-qANLx8WWaplEZPw=
+
+# Helius RPC project identifiers (optional, for analytics dashboards)
+HELIUS_API_KEY=4177e73c-0edb-4e4a-9d22-4c99b9a3f8c1
+HELIUS_PROJECT_ID=6a9a1a3c-79f8-4265-a86f-199bc33ffa56
 
 # ============================================================================
 # ğŸ§  ELITE WALLET INTELLIGENCE
 # ============================================================================
-
-# Auto-track wallets that trade successfully
 TRACK_WALLETS_AUTO=true
-
-# Minimum score to consider a wallet "good" (0-100)
-MIN_WALLET_SCORE=70.0
-
-# Max wallets to track simultaneously
+MIN_WALLET_SCORE=65.0
 MAX_TRACKED_WALLETS=100
 
-
 # ============================================================================
 # ğŸ¤– AUTOMATED TRADING
 # ============================================================================
-
-# Enable/disable automated trading (users can still toggle individually)
 AUTO_TRADE_ENABLED=true
-
-# Minimum AI confidence required to execute (0.0-1.0)
-AUTO_TRADE_MIN_CONFIDENCE=0.75
-
-# Max trades per day per user
-AUTO_TRADE_MAX_DAILY_TRADES=50
-
-# Max SOL to spend on auto-trading per day per user
-AUTO_TRADE_DAILY_LIMIT_SOL=100.0
-
-# Default buy amount per trade (SOL)
-DEFAULT_BUY_AMOUNT=0.1
-
-# Max position size (SOL)
-MAX_POSITION_SIZE_SOL=10.0
-
+AUTO_TRADE_MIN_CONFIDENCE=0.6
+AUTO_TRADE_MAX_DAILY_TRADES=10
+AUTO_TRADE_DAILY_LIMIT_SOL=1.0
+DEFAULT_BUY_AMOUNT=0.05
+MAX_POSITION_SIZE_SOL=0.5
 
 # ============================================================================
 # ğŸ›¡ï¸ ELITE PROTECTION SYSTEM
 # ============================================================================
-
-# Enable comprehensive honeypot detection (6 methods)
 HONEYPOT_DETECTION_METHODS=6
 HONEYPOT_CHECK_ENABLED=true
-
-# Minimum liquidity required (USD)
-MIN_LIQUIDITY_USD=5000.0
-
-# Authority checks
+MIN_LIQUIDITY_USD=2000.0
 CHECK_MINT_AUTHORITY=true
 CHECK_FREEZE_AUTHORITY=true
-
-# Holder distribution checks
 CHECK_TOP_HOLDERS=true
 MAX_TOP_HOLDER_PERCENTAGE=0.20
-
-# Twitter handle reuse detection
 TWITTER_HANDLE_CHECK=true
-
-# Contract analysis depth (LOW, MEDIUM, HIGH)
 CONTRACT_ANALYSIS_DEPTH=HIGH
 
-
 # ============================================================================
 # âš¡ ELITE SNIPING ENGINE
 # ============================================================================
-
-# Enable auto-sniper
 SNIPE_ENABLED=true
-
-# Use Jito bundles for snipes (MEV protection)
 SNIPE_USE_JITO=true
-
-# Jito tip amount (lamports)
 SNIPE_TIP_LAMPORTS=100000
-
-# Priority fee for snipes (microlamports)
 SNIPE_PRIORITY_FEE=2000000
-
-# Default snipe amount (SOL)
-SNIPE_AMOUNT_SOL=0.5
-
-# Minimum liquidity for snipes (SOL)
-SNIPE_MIN_LIQUIDITY_SOL=10
-
-# Max snipes per day per user
-SNIPE_MAX_DAILY=10
-
+SNIPE_AMOUNT_SOL=0.05
+SNIPE_MIN_LIQUIDITY_SOL=2
+SNIPE_MAX_DAILY=3
 
 # ============================================================================
 # ğŸ“Š RISK MANAGEMENT
 # ============================================================================
-
-# Stop loss percentage (0.15 = 15%)
 STOP_LOSS_PERCENTAGE=0.15
-
-# Take profit percentage (0.50 = 50%)
 TAKE_PROFIT_PERCENTAGE=0.50
-
-# Trailing stop percentage (0.10 = 10%)
 TRAILING_STOP_PERCENTAGE=0.10
-
-# Max daily loss per user (SOL)
-MAX_DAILY_LOSS_SOL=50.0
-
-# Max slippage (0.05 = 5%)
+MAX_DAILY_LOSS_SOL=0.15
 MAX_SLIPPAGE=0.05
 
-
 # ============================================================================
 # ğŸ¯ JITO CONFIGURATION (MEV PROTECTION)
 # ============================================================================
-
-# Jito Block Engine URL
 JITO_BLOCK_ENGINE_URL=https://mainnet.block-engine.jito.wtf/api/v1
-
-# Jito Tip Account (main one)
 JITO_TIP_ACCOUNT=96gYZGLnJYVFmbjzopPSU6QiEV5fGqZNyN9nmNhvrZU5
-
-# Default Jito tip (lamports)
 JITO_TIP_LAMPORTS=100000
-
+PRIORITY_FEE_MICROLAMPORTS=2000000
+COMPUTE_UNIT_LIMIT=200000
+ENABLE_PARALLEL_SUBMISSION=true
+ENABLE_FAST_SIMULATION=true
+PARALLEL_RPC_COUNT=3
 
 # ============================================================================
 # ğŸ¦ SOCIAL MEDIA APIs (Optional - for sentiment analysis)
 # ============================================================================
-
-# Twitter/X API v2
-TWITTER_API_KEY=
-TWITTER_API_SECRET=
-TWITTER_BEARER_TOKEN=
-
-# Reddit API
-REDDIT_CLIENT_ID=
-REDDIT_CLIENT_SECRET=
+TWITTER_API_KEY=SrEqKHwaXpj3R28d7RcnZjJIE
+TWITTER_API_SECRET=Lli2wtX1ifkDXwsB9v23DtJaKvFEk2rhqReItSzfoMuB8U7Dse
+TWITTER_BEARER_TOKEN=AAAAAAAAAAAAAAAAAAAAAHY%2F1wEAAAAAnj8bmnYBp5pvGrUamSySm4Uzfdw%3DUopwOJrEuPFtvj6GRzjTj2dEAX0dtYbLTNsE5qaYMBesseEP7B
+TWITTER_CLIENT_ID=Z3NITmlwMkZxQ3hpdFVlQ3Q3NS06MTpjaQ
+TWITTER_CLIENT_SECRET=BrT7t3BgwOqEfAVoBonDdydonE1JfSWKzt3qleYFIVkyL-VZHd
+REDDIT_CLIENT_ID=U-h5zvhaIifMRiZ3hKGyfw
+REDDIT_CLIENT_SECRET=_dlqVgssQQwhGCFw4XYadfI64odO4g
 REDDIT_USER_AGENT=EliteTradingBot/1.0
-
-# Discord Bot (for monitoring channels)
-DISCORD_TOKEN=
-
+DISCORD_TOKEN=
 
 # ============================================================================
 # ğŸ’¾ DATABASE
 # ============================================================================
-
-# Database URL (SQLite by default, can use PostgreSQL for production)
-DATABASE_URL=sqlite:///trading_bot.db
-
-# Enable database backups
+DATABASE_URL=sqlite+aiosqlite:///trading_bot.db
 DATABASE_BACKUP_ENABLED=true
 DATABASE_BACKUP_INTERVAL_HOURS=6
 
-
 # ============================================================================
 # ğŸ“ˆ PERFORMANCE & MONITORING
 # ============================================================================
-
-# Enable performance monitoring
 MONITORING_ENABLED=true
-
-# Log level (DEBUG, INFO, WARNING, ERROR)
 LOG_LEVEL=INFO
-
-# Enable Prometheus metrics
 PROMETHEUS_ENABLED=false
 PROMETHEUS_PORT=9090
 
-
 # ============================================================================
 # ğŸ® GAMIFICATION & REWARDS
 # ============================================================================
-
-# Enable reward system
 REWARDS_ENABLED=true
-
-# Points per successful trade
 POINTS_PER_TRADE=10
-
-# Points per wallet tracked
 POINTS_PER_WALLET_TRACK=5
-
-# Points per token rating
 POINTS_PER_RATING=5
 
-
 # ============================================================================
 # ğŸ’° PLATFORM FEES (Optional - for monetization)
 # ============================================================================
-
-# Platform fee percentage (0.005 = 0.5%)
 PLATFORM_FEE_PERCENTAGE=0.005
-
-# Fee collection wallet
 FEE_COLLECTION_WALLET=4164wKUM9HJyqXc9yrj24LKvy8BwxjzDazg4FSMycfR5
 
-
 # ============================================================================
 # ğŸš€ ADVANCED SETTINGS (Don't change unless you know what you're doing)
 # ============================================================================
-
-# Transaction confirmation timeout (seconds)
 TX_CONFIRMATION_TIMEOUT=60
-
-# Max retry attempts for transactions
 TX_MAX_RETRIES=3
-
-# RPC request timeout (seconds)
 RPC_TIMEOUT=30
-
-# WebSocket ping interval (seconds)
 WS_PING_INTERVAL=30
-
-# Cache duration (seconds)
 CACHE_DURATION=300
-
-# Rate limit: requests per minute
 RATE_LIMIT_PER_MINUTE=60
 
-
 # ============================================================================
 # ğŸ§ª TESTING & DEVELOPMENT
 # ============================================================================
-
-# Enable test mode (uses devnet)
 TEST_MODE=false
-
-# Devnet RPC (if test mode enabled)
 DEVNET_RPC_URL=https://api.devnet.solana.com
-
-# Enable debug logging
 DEBUG_MODE=false
-
-# Dry run mode (simulate trades without executing)
 DRY_RUN=false
 
-
 # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
 # ğŸ“ NOTES
 # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
-#
 # 1. For production, use a paid RPC service (Helius, QuickNode, Alchemy)
 # 2. Start with small amounts when testing (0.01-0.1 SOL)
 # 3. Monitor your bot regularly, especially during high volatility
 # 4. Enable all protection features for maximum safety
 # 5. Use Jito bundles for better execution and MEV protection
 # 6. Keep your .env file secure - never share it or commit to git
-#
 # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
-
diff --git a/README.md b/README.md
index 813c8209853bfe131f996a05156a3324898234af..935cf793c3133da40de182f0dc2003d37cee0896 100644
--- a/README.md
+++ b/README.md
@@ -61,268 +61,300 @@
 | 1ï¸âƒ£ | **AI Predictions** | ML models predict token performance | `/ai <token>` |
 | 2ï¸âƒ£ | **Copy Trading** | Auto-copy successful traders | `/copy <trader_id>` |
 | 3ï¸âƒ£ | **Sentiment Analysis** | Real-time social media monitoring | `/trending` |
 | 4ï¸âƒ£ | **Community Intel** | Crowdsourced token ratings | `/community <token>` |
 | 5ï¸âƒ£ | **Pattern Recognition** | Auto-detect profitable setups | Auto |
 | 6ï¸âƒ£ | **Adaptive Strategies** | Market-based strategy selection | Auto |
 | 7ï¸âƒ£ | **Strategy Marketplace** | Buy/sell proven strategies | `/strategies` |
 | 8ï¸âƒ£ | **Gamification** | Points, tiers, and rewards | `/rewards` |
 | 9ï¸âƒ£ | **Anti-MEV** | Jito bundle protection | Auto |
 | ğŸ”Ÿ | **Risk Management** | Kelly Criterion position sizing | Auto |
 
 ### ğŸš€ NEW: Elite Features
 | # | Feature | Description | Command |
 |---|---------|-------------|---------|
 | 1ï¸âƒ£1ï¸âƒ£ | **ğŸ§  Wallet Intelligence** | Track & rank profitable wallets (0-100) | `/track <wallet>` |
 | 1ï¸âƒ£2ï¸âƒ£ | **ğŸ† Wallet Rankings** | See top performing wallets | `/rankings` |
 | 1ï¸âƒ£3ï¸âƒ£ | **ğŸ¤– Auto Trading** | 24/7 autonomous trading | `/autostart` |
 | 1ï¸âƒ£4ï¸âƒ£ | **ğŸ›¡ï¸ 6-Layer Protection** | Advanced scam detection | Auto |
 | 1ï¸âƒ£5ï¸âƒ£ | **âš¡ Elite Sniping** | Sub-100ms detection + Jito | `/snipe_enable` |
 
 ---
 
 ## ğŸš€ Quick Start
 
 ### Prerequisites
-- Python 3.9 or higher
-- Telegram account
-- Solana wallet with SOL
-- **NEW:** Helius FREE account (optional but recommended) - 100K requests/day
+- Python 3.9 or higher (virtual environments recommended)
+- Telegram bot token from [@BotFather](https://t.me/BotFather)
+- Solana RPC endpoint (Helius, Triton, or self-hosted)
+- Base64-encoded `WALLET_ENCRYPTION_KEY` generated with `scripts/rotate_wallet_key.py`
 
-### Installation
+### Setup
 
 ```bash
-# 1. Clone repository
-git clone https://github.com/YOUR-USERNAME/solana-trading-bot.git
-cd solana-trading-bot
+# 1. Clone the repository
+git clone https://github.com/YOUR-USERNAME/revolutionary-solana-trading-bot.git
+cd revolutionary-solana-trading-bot
 
-# 2. Install dependencies
-pip install -r requirements.txt
+# 2. (Recommended) Create a virtual environment
+python3 -m venv .venv
+source .venv/bin/activate  # Windows: .venv\Scripts\activate
 
-# 3. Setup project
-python scripts/setup_project.py
+# 3. Install dependencies from the locked set
+pip install --upgrade pip
+./scripts/install_requirements.sh
 
-# 4. Configure (copy template and edit)
+# (Optional) Pre-fetch wheels for offline/CI usage
+python scripts/fetch_wheels.py
+
+# 4. Configure environment
 cp ENV_CONFIGURATION.txt .env
-# Edit .env with your credentials
+# Edit .env and populate TELEGRAM_BOT_TOKEN, SOLANA_RPC_URL, WALLET_ENCRYPTION_KEY, etc.
+
+# 5. Apply database migrations (creates SQLite db by default)
+python scripts/migrate_database.py
 
-# 5. (RECOMMENDED) Setup Helius RPC for Better Performance
-# Go to https://helius.dev and create FREE account
-# Get your API key and add to .env:
-# HELIUS_API_KEY=your_api_key
-# SOLANA_RPC_URL=https://mainnet.helius-rpc.com/?api-key=your_api_key
+# 6. Verify encryption key / generate a new one if needed
+python scripts/rotate_wallet_key.py --generate-new-key
 
-# 6. Run bot
+# 7. Launch the bot
 python scripts/run_bot.py
 ```
 
-### Quick Status Check
+### Operational checks
 
 ```bash
-# Check bot status anytime
+# Inspect current health/metrics via the new admin command
+/metrics (from Telegram, admin only)
+
+# Or query from the CLI helper
 python scripts/bot_status.py
 ```
 
 ### Docker (Alternative)
 
 ```bash
 # 1. Configure
 cp MINIMAL_ENV.txt .env
 # Edit .env
 
 # 2. Run
 docker-compose up -d
 
 # 3. View logs
 docker-compose logs -f trading-bot
 ```
 
 ---
 
 ## ğŸ“± Professional Telegram UI
 
 Modern button-based interface:
 
 ```
 [User] added Revolutionary Trading Bot to this group!
 
 Click Get Started to fund your trading wallet then:
 
 1. Analyze any token with /analyze or /ai
 2. Get Notified of trending tokens  
 3. Buy and Sell directly in chat
 4. Get Alerts when opportunities detected
 5. Follow and Copy Top Traders
 
 [ğŸš€ Get Started]  [âŒ Close]
 [ğŸ“Š My Stats]     [ğŸ† Leaderboard]
 [âš™ï¸ Settings]     [â“ Help]
 ```
 
 ---
 
 ## ğŸ“Š Commands Reference
 
 ### ğŸ’° Wallet Management
 - `/wallet` - Your wallet info
 - `/balance` - Check balance
 - `/deposit` - Deposit instructions
 - `/export_wallet` - Export private keys (secure)
 
 ### ğŸ“ˆ Trading
-- `/buy <token> <amount>` - Buy tokens
-- `/sell <token> <amount>` - Sell tokens
+- `/buy <token_mint> <amount_sol>` - Swap SOL from your bot wallet into a token
+- `/sell <token_mint> [amount_tokens|all]` - Exit an open position (use `all` to close entirely)
 - `/snipe <token>` - Snipe new launch
 - `/positions` - View open positions
 
 ### ğŸ“Š Analysis
 - `/ai <token>` or `/analyze <token>` - AI-powered analysis
 - `/trending` - Tokens going viral NOW
 - `/community <token>` - Community ratings
 
 ### ğŸ§  Elite Wallet Intelligence (NEW)
 - `/track <wallet>` - Track & analyze wallet performance
 - `/rankings` - Top 10 performing wallets
 - Follow the smart money automatically!
 
 ### ğŸ¤– Automated Trading (NEW)
 - `/autostart` - Start 24/7 automated trading
 - `/autostop` - Stop automated trading
 - `/autostatus` - Check status & stats
 - Set it and forget it!
 
 ### ğŸ‘¥ Social Trading
 - `/leaderboard` - Top traders
 - `/copy <trader_id>` - Auto-copy trader
 - `/stop_copy` - Stop copying
 
 ### ğŸ¯ Auto-Sniper
 - `/snipe` - View sniper settings
 - `/snipe_enable` - Enable auto-sniper
 - `/snipe_disable` - Disable auto-sniper
 
 ### ğŸ® Stats & Rewards
 - `/stats` or `/my_stats` - Your performance
 - `/rewards` - Points & tier status
 
+### ğŸ› ï¸ Operations (Admin)
+- `/metrics` - Live health and execution metrics (admin only)
+
 ### â“ Help
 - `/help` - All commands
 - `/settings` - Configure bot
 - `/features` - See all features
 
 ---
 
 ## ğŸ—ï¸ Project Structure
 
 ```
-sol/
-â”œâ”€â”€ src/                    # Source code
-â”‚   â”œâ”€â”€ bot/               # Bot implementations
-â”‚   â”‚   â”œâ”€â”€ main.py       # Revolutionary bot (primary)
-â”‚   â”‚   â””â”€â”€ basic_bot.py  # Basic version
-â”‚   â”œâ”€â”€ modules/           # Core modules
-â”‚   â”‚   â”œâ”€â”€ ai_strategy_engine.py
-â”‚   â”‚   â”œâ”€â”€ social_trading.py
-â”‚   â”‚   â”œâ”€â”€ sentiment_analysis.py
-â”‚   â”‚   â”œâ”€â”€ database.py
-â”‚   â”‚   â”œâ”€â”€ wallet_manager.py
-â”‚   â”‚   â”œâ”€â”€ jupiter_client.py     # âš¡ Enhanced with Jito
-â”‚   â”‚   â”œâ”€â”€ token_sniper.py       # ğŸ¯ Elite sniping
-â”‚   â”‚   â”œâ”€â”€ wallet_intelligence.py  # ğŸ§  NEW
-â”‚   â”‚   â”œâ”€â”€ elite_protection.py     # ğŸ›¡ï¸ NEW
-â”‚   â”‚   â”œâ”€â”€ automated_trading.py    # ğŸ¤– NEW
-â”‚   â”‚   â””â”€â”€ monitoring.py
-â”‚   â””â”€â”€ config.py         # Configuration management
-â”œâ”€â”€ tests/                 # Test suite
-â”œâ”€â”€ scripts/               # Utility scripts
-â”œâ”€â”€ docs/                  # Documentation
-â”œâ”€â”€ enhancements/          # Elite features documentation
-â”œâ”€â”€ config/                # Config templates
-â””â”€â”€ Docker files          # Containerization
+.
+â”œâ”€â”€ src/
+â”‚   â”œâ”€â”€ bot/
+â”‚   â”‚   â””â”€â”€ main.py                # Telegram bot entrypoint & lifecycle coordination
+â”‚   â””â”€â”€ modules/
+â”‚       â”œâ”€â”€ ai_strategy_engine.py  # AI-driven scoring with social sentiment context
+â”‚       â”œâ”€â”€ automated_trading.py   # Background wallet scanner & executor
+â”‚       â”œâ”€â”€ database.py            # SQLAlchemy models & async session helpers
+â”‚       â”œâ”€â”€ monitoring.py          # BotMonitor metrics aggregation
+â”‚       â”œâ”€â”€ sentiment_analysis.py  # Social/community data ingestion
+â”‚       â”œâ”€â”€ social_trading.py      # Trader marketplace & copy relationships
+â”‚       â”œâ”€â”€ token_sniper.py        # Auto-sniper orchestration & persistence
+â”‚       â”œâ”€â”€ trade_execution.py     # Centralized execution, risk checks, copy fanout
+â”‚       â””â”€â”€ wallet_manager.py      # Key management, encryption, user wallet utilities
+â”œâ”€â”€ scripts/
+â”‚   â”œâ”€â”€ run_bot.py                 # CLI launcher used in production
+â”‚   â”œâ”€â”€ migrate_database.py        # Applies schema migrations / bootstraps DB
+â”‚   â”œâ”€â”€ rotate_wallet_key.py       # Generate & rotate Fernet encryption keys
+â”‚   â””â”€â”€ bot_status.py              # Operational status snapshot
+â”œâ”€â”€ tests/
+â”‚   â”œâ”€â”€ unit/
+â”‚   â”‚   â””â”€â”€ test_trade_execution.py
+â”‚   â””â”€â”€ test_copy_trading.py
+â”œâ”€â”€ docs/                          # Supplementary guides & deployment notes
+â”œâ”€â”€ enhancements/                  # Elite feature overviews and executive summaries
+â”œâ”€â”€ ENV_CONFIGURATION.txt          # Annotated environment template
+â”œâ”€â”€ requirements.txt
+â””â”€â”€ README.md
 ```
 
+## ğŸ§  Architecture Overview
+
+- **Database-backed state.** Trades, open positions, tracked traders, follower relationships, sniper snapshots, and per-user risk settings are all persisted through SQLAlchemy models so restarts never lose context (`Trade`, `Position`, `TrackedWallet`, `UserSettings`, `SnipeRun`).
+- **Centralized execution core.** Every buy/sell goes through `TradeExecutionService`, which enforces balance checks, user risk limits, elite protection, Jito routing, persistence, and follow-on copy trades for subscribers.
+- **Social marketplace & copy trading.** `SocialTradingMarketplace` hydrates trader profiles and active copy settings from the database, tracks performance, and fans out follower trades through the shared executor.
+- **Auto-sniper with resume support.** `AutoSniper` records AI decisions and outcomes, reloads user sniper preferences from `UserSettings`, and restores pending snipes from `SnipeRun` so maintenance windows do not drop signals.
+- **Automated trading telemetry.** Batched wallet scans reuse cached transaction data, honor user risk controls, and publish metrics through `BotMonitor` for operational visibility.
+- **Sentiment-driven intelligence.** The AI strategy engine fuses quantitative signals with live social/community sentiment to justify recommendations surfaced in Telegram responses and sniper scoring.
+- **Graceful lifecycle management.** `RevolutionaryTradingBot.start()` runs inside an async application that waits on a shutdown event, while `BotRunner` wires OS signal handlers so polling and background tasks stop cleanly.
+- **Hardened key management.** Wallet encryption requires a supplied Fernet key, and `scripts/rotate_wallet_key.py` provides generate/dry-run/rotate flows for professional deployments.
+
 ---
 
 ## âš™ï¸ Configuration
 
 See `ENV_CONFIGURATION.txt` for complete elite configuration with all new features.
 
 **Minimal required variables:**
 ```env
 TELEGRAM_BOT_TOKEN=your_bot_token
 SOLANA_RPC_URL=https://api.mainnet-beta.solana.com
-WALLET_ENCRYPTION_KEY=your_encryption_key  # Generated on first run
+WALLET_ENCRYPTION_KEY=base64_fernet_key  # Generate with scripts/rotate_wallet_key.py --generate-new-key
 ```
 
 **Recommended - Helius RPC (FREE 100K requests/day):**
 ```env
 HELIUS_API_KEY=your_helius_api_key
 SOLANA_RPC_URL=https://mainnet.helius-rpc.com/?api-key=your_helius_api_key
 ```
 
 **Optional - Twitter Sentiment Analysis:**
 ```env
 TWITTER_API_KEY=your_api_key
 TWITTER_API_SECRET=your_api_secret
 TWITTER_BEARER_TOKEN=your_bearer_token
 TWITTER_CLIENT_ID=your_client_id
 TWITTER_CLIENT_SECRET=your_client_secret
 ```
 
 **Elite features configuration:**
 ```env
 # Wallet Intelligence
 TRACK_WALLETS_AUTO=true
 MIN_WALLET_SCORE=70.0
 
 # Automated Trading
 AUTO_TRADE_ENABLED=true
 AUTO_TRADE_MIN_CONFIDENCE=0.75
 
 # Elite Protection (6-layer)
 HONEYPOT_CHECK_ENABLED=true
 MIN_LIQUIDITY_USD=2000.0  # Optimized for more opportunities
 CHECK_MINT_AUTHORITY=true
 CHECK_FREEZE_AUTHORITY=true
 CHECK_TOP_HOLDERS=true
 TWITTER_HANDLE_CHECK=true
 
 # Elite Sniping with Jito
 SNIPE_ENABLED=true
 SNIPE_USE_JITO=true
 SNIPE_TIP_LAMPORTS=100000
 SNIPE_MIN_LIQUIDITY_SOL=2  # Lowered from 10 for more opportunities
 
 # Auto-Sell / Risk Management
 STOP_LOSS_PERCENTAGE=0.15
 TAKE_PROFIT_PERCENTAGE=0.50
 TRAILING_STOP_PERCENTAGE=0.10
 MAX_DAILY_LOSS_SOL=50.0
 ```
 
 See `ENV_CONFIGURATION.txt` for all 60+ configuration options!
 
+### ğŸ” Wallet encryption & rotation
+
+* **Always supply `WALLET_ENCRYPTION_KEY`.** The bot will now refuse to start without a valid Fernet key so that user wallets are never encrypted with a throw-away secret.
+* **Generate and rotate keys with tooling.** Run `python scripts/rotate_wallet_key.py --generate-new-key` to create a compliant key or `python scripts/rotate_wallet_key.py --new-key <key>` to re-encrypt existing wallets. Use `--dry-run` first in production to validate the current key before writing changes.
+* **Store secrets in hardened systems.** For professional deployments, keep the key in your cloud secret manager or hardware-backed KMS (AWS KMS, GCP Cloud KMS, Azure Key Vault with HSM, etc.) and inject it at runtime rather than storing it in plain `.env` files.
+
 ---
 
 ## ğŸ’° Platform Fees
 
 - **Fee rate:** 0.5% per trade (configurable)
 - **Collection:** Automatic on every trade
 - **Sent to:** Your configured team wallet
 - **Revenue model:** Per-trade or subscription
 
 ---
 
 ## ğŸ§ª Testing
 
 ```bash
 # Run all tests
 pytest
 
 # Run with coverage
 pytest --cov=src --cov-report=html
 
 # Run specific tests
 pytest tests/unit/test_database.py
 ```
 
 ---
diff --git a/docs/INDIVIDUAL_WALLETS_GUIDE.md b/docs/INDIVIDUAL_WALLETS_GUIDE.md
index f0623d685882d896b4cb4a52b1e83fe1f8aae978..34a13a8112b29bfc50394608159b52fe1a6fb000 100644
--- a/docs/INDIVIDUAL_WALLETS_GUIDE.md
+++ b/docs/INDIVIDUAL_WALLETS_GUIDE.md
@@ -25,53 +25,53 @@ When a user runs `/start`:
 ```
 User1 â†’ Creates Wallet1 (unique keypair)
 User2 â†’ Creates Wallet2 (unique keypair)
 User3 â†’ Creates Wallet3 (unique keypair)
 ```
 
 Each wallet is:
 - âœ… Generated from secure randomness
 - âœ… Encrypted with master key
 - âœ… Stored in database
 - âœ… Cached in memory for performance
 
 ### 2. Encryption System
 ```python
 User Private Key (64 bytes)
     â†“
 Encrypt with Fernet (AES-128-CBC)
     â†“
 Store in database (encrypted string)
     â†“
 Decrypt only when needed for signing
 ```
 
 **Master Encryption Key:**
 - Stored in environment variable: `WALLET_ENCRYPTION_KEY`
-- Generated automatically on first run
-- Must be kept secret
-- Backs up all user wallets
+- Must be provisioned before the bot starts (Fernet 32-byte key)
+- Generate with `python scripts/rotate_wallet_key.py --generate-new-key` or your KMS
+- Must be kept secret and backed up securely
 
 ### 3. Trading Flow
 ```
 1. User runs /ai_analyze <token>
 2. Bot recommends buying 0.1 SOL
 3. User clicks "Buy" button
 4. Bot:
    a) Gets USER'S keypair (decrypts from DB)
    b) Checks USER'S balance
    c) Signs transaction with USER'S wallet
    d) Executes trade
 5. Tokens go to USER'S wallet
 6. Only USER can access their funds
 ```
 
 ## Database Schema
 
 ### New Table: `user_wallets`
 ```sql
 CREATE TABLE user_wallets (
     id INTEGER PRIMARY KEY,
     user_id INTEGER UNIQUE,              -- Telegram user ID
     telegram_username TEXT,
     public_key TEXT UNIQUE,              -- Solana wallet address
     encrypted_private_key TEXT,          -- Encrypted keypair
@@ -147,57 +147,59 @@ Quick balance check:
 - Individual balance tracking
 
 ### 4. Audit Trail
 - All transactions logged with user_id
 - Can track who traded what
 - Full accountability
 
 ## Setup Instructions
 
 ### 1. Install Dependencies
 ```bash
 pip install cryptography>=41.0.0
 ```
 
 ### 2. Update Database
 The database will auto-create the new `user_wallets` table on first run.
 
 To manually migrate:
 ```python
 from src.modules.database import Base, DatabaseManager
 
 db = DatabaseManager()
 Base.metadata.create_all(db.engine)
 ```
 
-### 3. Set Encryption Key (Optional)
+### 3. Set Encryption Key (Required)
 Add to your `.env` file:
 ```bash
-WALLET_ENCRYPTION_KEY=<generate_one_or_let_bot_generate>
+WALLET_ENCRYPTION_KEY=<fernet_key_from_rotate_wallet_key_or_kms>
 ```
 
-If not set, bot generates one automatically (check logs for the key to save).
+Use `python scripts/rotate_wallet_key.py --generate-new-key` to print a compliant
+key or pull the value from your hardware-backed KMS/secret manager. The bot will
+exit during startup if the key is missing or invalid.
 
 ### 4. Start Bot
 ```bash
 python scripts/run_bot.py
 ```
 
 Each user who runs `/start` gets their own wallet automatically.
 
 ## User Experience
 
 ### First Time User
 ```
 User: /start
 
 Bot: Welcome! ğŸ‰
 
 âœ¨ New wallet created!
 
 ğŸ” Your Personal Trading Wallet:
 `7xJ4...pQm8`
 
 Use /wallet to manage your wallet
 
 Quick Start:
 1. Fund your wallet with /deposit
diff --git a/docs/SNIPER_IMPLEMENTED.md b/docs/SNIPER_IMPLEMENTED.md
index f40b72ec24b0788dd668736189622a173f5343b9..9382bf5e040a7a21ae4a4db1498f3f2c14f79261 100644
--- a/docs/SNIPER_IMPLEMENTED.md
+++ b/docs/SNIPER_IMPLEMENTED.md
@@ -125,69 +125,53 @@ For each user with snipe enabled:
    ğŸ¯ Auto-sniper monitoring started
    ğŸ¯ Auto-snipe enabled for user XXXXX
    
    Every 30 seconds:
    ğŸ¯ Checking for new tokens...
    ```
 
 5. **When new token launches:**
    ```
    ğŸ¯ NEW TOKEN DETECTED: SYMBOL (address...)
    ğŸ¯ Running AI analysis for user X
    ğŸ¯ AI says: strong_buy with 72% confidence
    ğŸ¯ WOULD BUY: 0.1 SOL of SYMBOL
    ```
 
 ## Current Implementation Status
 
 âœ… **Working:**
 - Monitoring system (polls every 30s)
 - Token detection
 - AI analysis integration
 - Safety checks
 - User settings
 - Enable/disable commands
 - Database storage
-
-â³ **Next Step Needed:**
-- Actual Jupiter swap execution
-- User notifications via Telegram
-- Trade recording in database
-
-Currently it **LOGS what it would buy** but doesn't execute yet. This is SAFE for testing!
-
-## To Make It Execute Real Trades
-
-In `src/modules/token_sniper.py`, line ~280, there's a TODO:
-
-```python
-# TODO: Implement actual Jupiter swap here
-# For now, log what we would do
-logger.info(f"ğŸ¯ WOULD BUY: {settings.max_buy_amount:.4f} SOL")
-```
-
-Replace with actual swap execution once you're ready to test with real money.
+- Jupiter swap execution with Jito bundles
+- Trade persistence + sniper history recovery
+- User notifications via Telegram (auto updates + failure alerts)
 
 ## Monitoring in Real-Time
 
 Watch your bot logs for:
 ```
 ğŸ¯ Auto-sniper monitoring started
 ğŸ¯ Checking for new tokens...
 ğŸ¯ NEW TOKEN DETECTED: [when found]
 ğŸ¯ Running AI analysis...
 ğŸ¯ AI says: [recommendation]
 ğŸ¯ WOULD BUY: [when criteria met]
 ```
 
 ## User Experience
 
 ### Before:
 ```
 /snipe
 â†’ Just showed placeholder text
 â†’ Didn't do anything
 â†’ "Coming soon"
 ```
 
 ### After:
 ```
diff --git a/docs/WALLET_EXPORT_FEATURE.md b/docs/WALLET_EXPORT_FEATURE.md
index b0c09345de5eb896ce5a564e2d209cea593bd282..a47aadbc2e0ea7e834ca4f9e9114a5f01bf1d288 100644
--- a/docs/WALLET_EXPORT_FEATURE.md
+++ b/docs/WALLET_EXPORT_FEATURE.md
@@ -160,44 +160,44 @@ Users can now:
 3. âœ… Trade with AI
 4. âœ… Export keys anytime
 5. âœ… Import to Phantom
 6. âœ… Full control!
 
 ---
 
 ## ğŸ“ Commands Summary
 
 | Command | Description | Where |
 |---------|-------------|-------|
 | `/wallet` | Show wallet info + export button | Private/Group |
 | `/export_wallet` | Export private key | Private Only |
 | `/export_keys` | Same as above (alias) | Private Only |
 | `/balance` | Quick balance check | Private/Group |
 | `/deposit` | Deposit instructions | Private/Group |
 
 ---
 
 ## âš ï¸ Important Notes
 
 1. **Users must save their keys** - Bot doesn't store recovery phrases
 2. **Keys work in all Solana wallets** - Standard format
 3. **Same wallet everywhere** - Bot & Phantom share same funds
 4. **Encrypted in DB** - Even if DB is compromised, keys are encrypted
-5. **Master encryption key** - Stored in `.env` (WALLET_ENCRYPTION_KEY)
+5. **Master encryption key** - Stored in `.env` (WALLET_ENCRYPTION_KEY) â€” generate/rotate with `scripts/rotate_wallet_key.py` and keep it in your secret manager or KMS
 
 ---
 
 ## ğŸŠ Status: LIVE & WORKING!
 
 âœ… Feature implemented  
 âœ… Commands registered  
 âœ… Security measures in place  
 âœ… UI updated  
 âœ… Help documentation updated  
 âœ… Bot restarted with changes  
 
 **Users can now export their private keys safely!** ğŸ”
 
 ---
 
 *This is a critical trust-building feature that gives users true ownership of their funds.*
 
diff --git a/docs/WALLET_FIX_SUMMARY.md b/docs/WALLET_FIX_SUMMARY.md
index fe8eabcd4d1c392b1bad3acb1926fc1e6de960fb..6db499db464df554ec6bfa1b6ca9f9fb31d5b34b 100644
--- a/docs/WALLET_FIX_SUMMARY.md
+++ b/docs/WALLET_FIX_SUMMARY.md
@@ -119,54 +119,54 @@ That's it! Bot will:
 
 ### Before âŒ:
 ```python
 # Single shared wallet for everyone
 self.keypair = load_shared_wallet()
 
 def execute_trade(user_id, amount):
     # Uses same wallet for all users!
     sign_transaction(self.keypair, amount)
 ```
 
 ### After âœ…:
 ```python
 # Individual wallet per user
 self.wallet_manager = UserWalletManager()
 
 def execute_trade(user_id, amount):
     # Gets THIS user's wallet
     user_keypair = await wallet_manager.get_user_keypair(user_id)
     sign_transaction(user_keypair, amount)
 ```
 
 ## Important Notes
 
 âš ï¸ **Master Encryption Key**
-- Generated on first run
-- Shown in logs
-- **SAVE IT to `.env`**
-- Without it, all wallets are lost!
+- Provision `WALLET_ENCRYPTION_KEY` before starting the bot
+- Generate with `python scripts/rotate_wallet_key.py --generate-new-key` or issue from your KMS
+- **Store it in a secure secret manager** and load via environment variables
+- Without it, encrypted wallets cannot be decrypted!
 
 ğŸ“‹ **Database Migration**
 - New users: Automatic
 - Existing users: Delete old DB and start fresh (recommended)
 
 ğŸ”’ **Security**
 - Never share database file
 - Never commit encryption key to Git
 - Back up encryption key securely
 - Test with small amounts first
 
 ## Ready to Launch! ğŸš€
 
 Your bot now has:
 - âœ… Individual user wallets (secure!)
 - âœ… Trained AI model (smart!)
 - âœ… Fixed AI analysis (no more errors!)
 - âœ… Production-ready architecture
 
 **You're ready to launch with real users and real money!**
 
 For detailed documentation, see:
 - `INDIVIDUAL_WALLETS_GUIDE.md` - Complete guide
 - `AI_TRAINING_GUIDE.md` - Model training
 - `FIXED_AI_ANALYSIS.md` - AI fix details
diff --git a/requirements.txt b/requirements.txt
index 62f0edde93373dece571b56b19a331323a116d4b..42c954d1662582235c69790c26dde514cfb9d92c 100644
--- a/requirements.txt
+++ b/requirements.txt
@@ -1,54 +1,2 @@
-# ğŸš€ ELITE SOLANA TRADING BOT - REQUIREMENTS
-# Python 3.9+ required
-
-# Telegram Bot
-python-telegram-bot>=22.5
-
-# Solana - using newer versions for compatibility
-solana>=0.36.9
-solders>=0.21.0
-# Note: SPL token support is included in the solana package
-
-# Web Requests & Async
-aiohttp==3.9.1
-requests==2.31.0
-websockets==12.0
-
-# Database
-sqlalchemy==2.0.23
-aiosqlite==0.19.0
-
-# Environment & Config
-python-dotenv==1.0.0
-
-# Data Processing
-pandas==2.1.4
-numpy==1.26.2
-
-# Machine Learning (for AI features)
-scikit-learn==1.3.2
-joblib==1.3.2
-
-# Utilities
-python-dateutil==2.8.2
-pytz==2023.3
-
-# Social Media APIs (optional)
-tweepy==4.14.0  # Twitter
-praw==7.7.1  # Reddit
-
-# Monitoring & Logging
-prometheus-client==0.19.0
-
-# Testing
-pytest==7.4.3
-pytest-asyncio==0.21.1
-
-# Code Quality
-black==23.12.1
-flake8==6.1.0
-
-# Encryption & Security
-cryptography==41.0.7
-base58==2.1.1
-
+# See requirements/README.md for details on updating the lockfile.
+-r requirements/dev.lock
diff --git a/requirements/README.md b/requirements/README.md
new file mode 100644
index 0000000000000000000000000000000000000000..810fb3124a95f122d3bc9bf3688af018c1336dbd
--- /dev/null
+++ b/requirements/README.md
@@ -0,0 +1,27 @@
+# Dependency management
+
+This project now ships a locked dependency set so CI and production hosts install the exact same wheels every time.
+
+## Files
+
+- `base.in` â€“ runtime dependencies used by the bot.
+- `dev.in` â€“ developer tooling layered on top of `base.in`.
+- `dev.lock` â€“ the fully pinned set that CI installs. The first line points pip at the checked-in `vendor/` wheelhouse so builds remain reproducible even without internet access.
+
+## Installing locally
+
+```bash
+./scripts/install_requirements.sh
+```
+
+The helper script automatically prefers the vendored wheels under `vendor/` and falls back to PyPI if the directory is empty.
+
+## Updating the lockfile
+
+```bash
+pip install pip-tools
+pip-compile requirements/dev.in --output-file requirements/dev.lock
+python scripts/fetch_wheels.py
+```
+
+After compiling, re-run the fetch script so the wheelhouse matches the new pins before committing.
diff --git a/requirements/base.in b/requirements/base.in
new file mode 100644
index 0000000000000000000000000000000000000000..43bbc686369976a2be004fb9876199b1d81e591d
--- /dev/null
+++ b/requirements/base.in
@@ -0,0 +1,20 @@
+# Core runtime dependencies for the Elite Solana Trading Bot.
+aiohttp==3.9.1
+aiosqlite==0.19.0
+base58==2.1.1
+cryptography==41.0.7
+discord.py==2.3.2
+numpy==1.26.2
+pandas==2.1.4
+praw==7.7.1
+prometheus-client==0.19.0
+python-dateutil==2.8.2
+python-dotenv==1.0.0
+python-telegram-bot==20.8
+requests==2.31.0
+scikit-learn==1.3.2
+solders==0.21.0
+solana==0.36.9
+sqlalchemy==2.0.23
+tweepy==4.14.0
+websockets==12.0
diff --git a/requirements/dev.in b/requirements/dev.in
new file mode 100644
index 0000000000000000000000000000000000000000..46c27aac07f02ef0e11cb8e4b40d515b53f36794
--- /dev/null
+++ b/requirements/dev.in
@@ -0,0 +1,8 @@
+# Developer tooling extends the base runtime requirements.
+-r base.in
+black==23.12.1
+flake8==6.1.0
+joblib==1.3.2
+pytest==7.4.3
+pytest-asyncio==0.21.1
+pytest-xprocess==0.23.1
diff --git a/requirements/dev.lock b/requirements/dev.lock
new file mode 100644
index 0000000000000000000000000000000000000000..566a2c50d5cb927cc2c7705996dba229947cab27
--- /dev/null
+++ b/requirements/dev.lock
@@ -0,0 +1,27 @@
+--find-links ../vendor
+# Locked dependency set for CI and production builds.
+aiohttp==3.9.1
+aiosqlite==0.19.0
+base58==2.1.1
+black==23.12.1
+cryptography==41.0.7
+discord.py==2.3.2
+flake8==6.1.0
+joblib==1.3.2
+numpy==1.26.2
+pandas==2.1.4
+praw==7.7.1
+prometheus-client==0.19.0
+pytest==7.4.3
+pytest-asyncio==0.21.1
+pytest-xprocess==0.23.1
+python-dateutil==2.8.2
+python-dotenv==1.0.0
+python-telegram-bot==20.8
+requests==2.31.0
+scikit-learn==1.3.2
+solders==0.21.0
+solana==0.36.9
+sqlalchemy==2.0.23
+tweepy==4.14.0
+websockets==12.0
diff --git a/scripts/fetch_wheels.py b/scripts/fetch_wheels.py
new file mode 100644
index 0000000000000000000000000000000000000000..2837eb3aea6df8db24156c132392988d21213dc1
--- /dev/null
+++ b/scripts/fetch_wheels.py
@@ -0,0 +1,45 @@
+"""Download locked dependencies into the vendored wheelhouse."""
+
+from __future__ import annotations
+
+import argparse
+import subprocess
+import sys
+from pathlib import Path
+
+ROOT_DIR = Path(__file__).resolve().parents[1]
+DEFAULT_REQUIREMENTS = ROOT_DIR / "requirements" / "dev.lock"
+DEFAULT_DEST = ROOT_DIR / "vendor"
+
+
+def fetch(requirements: Path, destination: Path) -> None:
+    destination.mkdir(parents=True, exist_ok=True)
+    cmd = [
+        sys.executable,
+        "-m",
+        "pip",
+        "download",
+        "--dest",
+        str(destination),
+        "-r",
+        str(requirements),
+    ]
+    subprocess.check_call(cmd)
+
+
+if __name__ == "__main__":
+    parser = argparse.ArgumentParser(description=__doc__)
+    parser.add_argument(
+        "requirements",
+        nargs="?",
+        default=str(DEFAULT_REQUIREMENTS),
+        help="Path to the locked requirements file (default: requirements/dev.lock)",
+    )
+    parser.add_argument(
+        "--dest",
+        default=str(DEFAULT_DEST),
+        help="Directory to store downloaded wheels (default: vendor/)",
+    )
+    args = parser.parse_args()
+
+    fetch(Path(args.requirements), Path(args.dest))
diff --git a/scripts/install_requirements.sh b/scripts/install_requirements.sh
new file mode 100755
index 0000000000000000000000000000000000000000..f997ddccf72ee6a2f321401da74647e5e0a116af
--- /dev/null
+++ b/scripts/install_requirements.sh
@@ -0,0 +1,22 @@
+#!/usr/bin/env bash
+set -euo pipefail
+
+ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")"/.. && pwd)"
+REQ_FILE="${1:-requirements/dev.lock}"
+REQ_PATH="${ROOT_DIR}/${REQ_FILE}"
+WHEEL_DIR="${ROOT_DIR}/vendor"
+
+if [[ ! -f "${REQ_PATH}" ]]; then
+  echo "Requested requirements file '${REQ_PATH}' does not exist" >&2
+  exit 1
+fi
+
+PIP_ARGS=("-r" "${REQ_PATH}")
+
+if [[ -d "${WHEEL_DIR}" ]] && [[ $(ls -A "${WHEEL_DIR}" 2>/dev/null) ]]; then
+  echo "Installing dependencies from vendored wheelhouse at ${WHEEL_DIR}" >&2
+  python -m pip install --no-index --find-links "${WHEEL_DIR}" "${PIP_ARGS[@]}"
+else
+  echo "Vendored wheelhouse empty; falling back to PyPI" >&2
+  python -m pip install "${PIP_ARGS[@]}"
+fi
diff --git a/scripts/rotate_wallet_key.py b/scripts/rotate_wallet_key.py
new file mode 100644
index 0000000000000000000000000000000000000000..340a02ba93ed6802247755454314537341a38d7c
--- /dev/null
+++ b/scripts/rotate_wallet_key.py
@@ -0,0 +1,164 @@
+#!/usr/bin/env python3
+
+"""Rotate the WALLET_ENCRYPTION_KEY used to protect user wallets.
+
+This utility re-encrypts every stored wallet with a new Fernet key. It can
+also generate a fresh key when one is not provided. Always run a database
+backup before rotating keys in production.
+"""
+
+from __future__ import annotations
+
+import argparse
+import asyncio
+import logging
+import os
+import sys
+from typing import Optional
+
+from dotenv import load_dotenv
+from cryptography.fernet import Fernet, InvalidToken
+from sqlalchemy import select
+
+load_dotenv()
+
+# Ensure project modules are importable when executed directly
+sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))
+
+from src.modules.database import DatabaseManager, UserWallet  # noqa: E402
+from src.modules.wallet_manager import WalletEncryption  # noqa: E402
+
+logger = logging.getLogger("wallet_key_rotation")
+
+
+def _build_parser() -> argparse.ArgumentParser:
+    parser = argparse.ArgumentParser(
+        description="Rotate the WALLET_ENCRYPTION_KEY protecting stored wallets."
+    )
+    parser.add_argument(
+        "--database-url",
+        default=os.getenv("DATABASE_URL", "sqlite+aiosqlite:///trading_bot.db"),
+        help="Database connection string (defaults to DATABASE_URL env or local SQLite).",
+    )
+    parser.add_argument(
+        "--current-key",
+        help=(
+            "Existing WALLET_ENCRYPTION_KEY. Defaults to the environment value if set."
+        ),
+    )
+    parser.add_argument(
+        "--new-key",
+        help="New WALLET_ENCRYPTION_KEY to apply. Must be a urlsafe base64-encoded 32-byte key.",
+    )
+    parser.add_argument(
+        "--generate-new-key",
+        action="store_true",
+        help="Generate a compliant key automatically. The value will be printed to stdout.",
+    )
+    parser.add_argument(
+        "--dry-run",
+        action="store_true",
+        help="Validate keys and decrypt all wallets without writing changes.",
+    )
+    return parser
+
+
+async def _rotate_keys(
+    *,
+    database_url: str,
+    current_key: str,
+    new_key: str,
+    dry_run: bool,
+) -> None:
+    current_bytes = WalletEncryption.validate_key(current_key)
+    new_bytes = WalletEncryption.validate_key(new_key)
+
+    current_cipher = Fernet(current_bytes)
+    new_cipher = Fernet(new_bytes)
+
+    db = DatabaseManager(database_url)
+
+    async with db.async_session() as session:
+        result = await session.execute(select(UserWallet))
+        wallets = result.scalars().all()
+
+        if not wallets:
+            logger.info("No wallets found in the database. Nothing to rotate.")
+            return
+
+        logger.info("Rotating encryption for %s wallet(s)", len(wallets))
+
+        validated = 0
+        updated = 0
+        for wallet in wallets:
+            try:
+                decrypted = current_cipher.decrypt(wallet.encrypted_private_key.encode())
+            except InvalidToken as exc:
+                raise RuntimeError(
+                    "Failed to decrypt wallet %s with the current key. Aborting rotation."
+                    % wallet.public_key
+                ) from exc
+
+            validated += 1
+
+            if dry_run:
+                continue
+
+            wallet.encrypted_private_key = new_cipher.encrypt(decrypted).decode()
+            updated += 1
+
+        if dry_run:
+            logger.info(
+                "Dry run completed successfully for %s wallet(s). All entries are decryptable with the current key.",
+                validated,
+            )
+            return
+
+        await session.commit()
+        logger.info("Successfully rotated %s wallet(s).", updated)
+
+
+async def _main_async(args: argparse.Namespace) -> None:
+    logging.basicConfig(level=logging.INFO, format="%(levelname)s %(message)s")
+
+    current_key = args.current_key or os.getenv("WALLET_ENCRYPTION_KEY")
+    if not current_key:
+        raise RuntimeError(
+            "Current WALLET_ENCRYPTION_KEY must be supplied via --current-key or the environment."
+        )
+
+    if args.generate_new_key and args.new_key:
+        raise ValueError("Provide either --new-key or --generate-new-key, not both.")
+
+    if args.generate_new_key:
+        new_key = WalletEncryption.generate_key()
+        print("Generated new wallet encryption key:\nWALLET_ENCRYPTION_KEY=%s" % new_key)
+    elif args.new_key:
+        new_key = args.new_key
+    else:
+        raise RuntimeError("A new key is required. Use --new-key or --generate-new-key.")
+
+    await _rotate_keys(
+        database_url=args.database_url,
+        current_key=current_key,
+        new_key=new_key,
+        dry_run=args.dry_run,
+    )
+
+    if args.dry_run:
+        logger.info("Dry run only. Database was not modified.")
+    else:
+        logger.info(
+            "Rotation complete. Update WALLET_ENCRYPTION_KEY in your secret manager before restarting services."
+        )
+
+
+def main(argv: Optional[list[str]] = None) -> None:
+    parser = _build_parser()
+    args = parser.parse_args(argv)
+    asyncio.run(_main_async(args))
+
+
+if __name__ == "__main__":  # pragma: no cover - manual script entrypoint
+    main()
+
diff --git a/scripts/run_bot.py b/scripts/run_bot.py
index b4d2d26bdaf6636726b5ea29f9d65e2f7ca72cdd..2a935f578ad72ae2855a3083f5abf427ea3de6f1 100644
--- a/scripts/run_bot.py
+++ b/scripts/run_bot.py
@@ -1,102 +1,126 @@
 #!/usr/bin/env python3
 """
 Main entry point for running the trading bot
 Handles initialization, error handling, and graceful shutdown
 """
 
 import asyncio
 import logging
 import signal
 import sys
 from pathlib import Path
+from typing import Optional
 
 # Add project root to path
 project_root = Path(__file__).parent.parent
 sys.path.insert(0, str(project_root))
 
 from src.config import get_config
 from src.modules.database import DatabaseManager
 from src.bot.main import RevolutionaryTradingBot
+from solana.rpc.async_api import AsyncClient
 
 # Setup logging
 logging.basicConfig(
     format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
     level=logging.INFO,
     handlers=[
         logging.FileHandler('logs/trading_bot.log'),
         logging.StreamHandler()
     ]
 )
 logger = logging.getLogger(__name__)
 
 
 class BotRunner:
     """Manages bot lifecycle"""
     
     def __init__(self):
         self.bot = None
+        self.config = None
+        self.db_manager: Optional[DatabaseManager] = None
+        self.solana_client: Optional[AsyncClient] = None
         self.shutdown_event = asyncio.Event()
     
+
     async def start(self):
         """Start the bot"""
         try:
-            # Load config
             logger.info("Loading configuration...")
-            config = get_config()
-            
-            # Initialize database
+            self.config = get_config()
+
             logger.info("Initializing database...")
-            db_manager = DatabaseManager(config.database_url)
-            await db_manager.init_db()
-            
-            # Create and start bot
+            self.db_manager = DatabaseManager(self.config.database_url)
+            await self.db_manager.init_db()
+
+            logger.info("Preparing Solana client...")
+            self.solana_client = AsyncClient(self.config.solana_rpc_url)
+
             logger.info("Starting Revolutionary Trading Bot...")
-            self.bot = RevolutionaryTradingBot()
-            
-            # Start bot (this should be implemented in main.py)
-            await self.bot.start()
-            
-            # Wait for shutdown signal
-            await self.shutdown_event.wait()
-            
+            self.bot = RevolutionaryTradingBot(
+                self.config,
+                self.db_manager,
+                solana_client=self.solana_client,
+            )
+
+            await self.bot.start(self.shutdown_event)
+
         except KeyboardInterrupt:
             logger.info("Keyboard interrupt received")
         except Exception as e:
             logger.error(f"Fatal error: {e}", exc_info=True)
             raise
         finally:
             await self.cleanup()
-    
+
     async def cleanup(self):
         """Cleanup resources"""
         logger.info("Shutting down...")
         if self.bot:
             try:
                 await self.bot.stop()
             except Exception as e:
                 logger.error(f"Error during shutdown: {e}")
+
+        if self.solana_client:
+            try:
+                await self.solana_client.close()
+            except Exception as e:
+                logger.error(f"Error closing Solana client: {e}")
+            finally:
+                self.solana_client = None
+
+        if self.db_manager:
+            try:
+                await self.db_manager.dispose()
+            except Exception as e:
+                logger.error(f"Error disposing database manager: {e}")
+            finally:
+                self.db_manager = None
+
+        self.bot = None
     
     def signal_handler(self, signum, frame):
         """Handle shutdown signals"""
         logger.info(f"Received signal {signum}")
         self.shutdown_event.set()
 
 
 async def main():
     """Main entry point"""
     # Create logs directory
     Path("logs").mkdir(exist_ok=True)
     
     runner = BotRunner()
     
     # Setup signal handlers
     signal.signal(signal.SIGINT, runner.signal_handler)
     signal.signal(signal.SIGTERM, runner.signal_handler)
     
     try:
         await runner.start()
     except Exception as e:
         logger.error(f"Bot crashed: {e}", exc_info=True)
         sys.exit(1)
 
 
diff --git a/scripts/use_platform_wallet_simple.py b/scripts/use_platform_wallet_simple.py
index ca345740ad99ce02d6a3266621b8b9de12ecfa57..267ca15d4a0a9c9f0a3c13e4bbd5f4f8b5d94298 100644
--- a/scripts/use_platform_wallet_simple.py
+++ b/scripts/use_platform_wallet_simple.py
@@ -1,65 +1,65 @@
 """
 Simple script to import platform wallet for admin user
 """
 
 import asyncio
 import os
 import sys
 from dotenv import load_dotenv
 
 load_dotenv()
 sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
 
 from solana.rpc.async_api import AsyncClient
 from solders.keypair import Keypair
 from sqlalchemy import select, delete
 from src.modules.database import DatabaseManager, UserWallet
 from src.modules.wallet_manager import WalletEncryption
 
 async def main():
     admin_id = int(os.getenv('ADMIN_CHAT_ID'))
     wallet_key = os.getenv('WALLET_PRIVATE_KEY')
     rpc_url = os.getenv('SOLANA_RPC_URL')
-    
+
     keypair = Keypair.from_base58_string(wallet_key)
     public_key = str(keypair.pubkey())
-    
+
     client = AsyncClient(rpc_url)
     db = DatabaseManager()
     encryption = WalletEncryption()
     
     # Get balance
     response = await client.get_balance(keypair.pubkey())
     balance_sol = response.value / 1e9
     
     print(f"\nâœ… Platform Wallet: {public_key}")
     print(f"âœ… Balance: {balance_sol:.6f} SOL")
     print(f"âœ… Importing for admin user: {admin_id}\n")
     
     # Delete existing wallet
     async with db.async_session() as session:
         await session.execute(delete(UserWallet).where(UserWallet.user_id == admin_id))
         await session.commit()
     
     # Add platform wallet
-    encrypted = encryption.encrypt(wallet_key.encode())
+    encrypted = encryption.encrypt_private_key(bytes(keypair))
     
     async with db.async_session() as session:
         wallet = UserWallet(
             user_id=admin_id,
             public_key=public_key,
             encrypted_private_key=encrypted
         )
         session.add(wallet)
         await session.commit()
     
     print(f"âœ… DONE! Your bot now uses your funded wallet!")
     print(f"\nVerify in Telegram:")
     print(f"  /wallet - Should show {public_key}")
     print(f"  /balance - Should show {balance_sol:.6f} SOL")
     
     await client.close()
 
 if __name__ == "__main__":
     asyncio.run(main())
 
diff --git a/src/bot/main.py b/src/bot/main.py
index dd8476bf56c39de59bd42c0c91cd5fa76483c252..f54bb6c47a69a842c3dc6723ffc910bdc93c27fb 100644
--- a/src/bot/main.py
+++ b/src/bot/main.py
@@ -1,170 +1,240 @@
 """
 REVOLUTIONARY SOLANA TRADING BOT - PRODUCTION VERSION
 The most advanced Solana trading bot in the market
 
 UNIQUE DIFFERENTIATORS THAT DOMINATE THE MARKET:
 1. AI-Powered Predictions - ML models that learn and improve
 2. Social Trading Marketplace - Copy successful traders automatically
 3. Real-Time Sentiment Analysis - Twitter/Reddit/Discord monitoring
 4. Community Intelligence - Crowdsourced token ratings
 5. Adaptive Strategies - Automatically adjusts to market conditions
 6. Pattern Recognition - Identifies profitable setups
 7. Gamification & Rewards - Points for contributing
 8. Strategy Marketplace - Buy/sell proven strategies
 9. Anti-MEV Protection - Advanced Jito integration
 10. Professional Risk Management - Kelly Criterion position sizing
 
 THIS IS NOT JUST A BOT - IT'S A COMPLETE TRADING ECOSYSTEM
 """
 
-import os
 import asyncio
 import logging
+import os
+import sys
 from datetime import datetime, timedelta
-from typing import Dict, List, Optional
+from typing import Any, Dict, Optional
 
-from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
+from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
+from telegram.error import TelegramError
 from telegram.ext import (
     Application,
-    CommandHandler,
     CallbackQueryHandler,
+    CommandHandler,
     ContextTypes,
 )
 
 from solana.rpc.async_api import AsyncClient
 from solders.keypair import Keypair
 
-# Import our revolutionary modules
-import sys
-import os
-# Add parent directory to path for imports
+# Add parent directory to path for imports before local modules
 sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../..')))
 
 from src.modules.ai_strategy_engine import AIStrategyManager
 from src.modules.social_trading import (
     SocialTradingMarketplace,
     StrategyMarketplace,
     CommunityIntelligence,
     RewardSystem,
     REWARD_POINTS
 )
 from src.modules.sentiment_analysis import SocialMediaAggregator, TrendDetector
 from src.modules.database import DatabaseManager
 from src.modules.wallet_manager import UserWalletManager
 from src.modules.token_sniper import AutoSniper, SnipeSettings
 from src.modules.jupiter_client import JupiterClient, AntiMEVProtection
 from src.modules.monitoring import BotMonitor, PerformanceTracker
-from src.config import get_config
+from src.modules.trade_execution import TradeExecutionService
+from src.config import Config, get_config
 
 # ğŸš€ ELITE ENHANCEMENTS
 from src.modules.wallet_intelligence import WalletIntelligenceEngine, WalletMetrics
 from src.modules.elite_protection import EliteProtectionSystem, ProtectionConfig
 from src.modules.automated_trading import AutomatedTradingEngine, TradingConfig as AutoTradingConfig
 
 logging.basicConfig(
     format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
     level=logging.INFO
 )
 logger = logging.getLogger(__name__)
 
 
 class RevolutionaryTradingBot:
     """
     THE ULTIMATE SOLANA TRADING BOT
     
     Features that NO other bot has:
     - AI that learns from every trade
     - Copy successful traders automatically
     - Real-time social media sentiment
     - Community-driven intelligence
     - Adaptive strategy optimization
     - Professional risk management
     """
     
-    def __init__(self):
-        # Core components
-        self.client = AsyncClient(os.getenv('SOLANA_RPC_URL'))
-        self.db = DatabaseManager()
-        
+
+    def __init__(
+        self,
+        config: Config,
+        db_manager: DatabaseManager,
+        solana_client: Optional[AsyncClient] = None,
+        monitor: Optional[BotMonitor] = None,
+    ):
+        self.config = config
+        self.db = db_manager
+        self.client = solana_client or AsyncClient(config.solana_rpc_url)
+
+        # Default risk settings for new users
+        self.default_user_settings = self._build_default_user_settings()
+
         # ğŸ” USER WALLET MANAGEMENT - Each user gets their own wallet
-        self.wallet_manager = UserWalletManager(self.db, self.client)
-        
+        self.wallet_manager = UserWalletManager(
+            self.db,
+            self.client,
+            default_user_settings=self.default_user_settings,
+        )
+
         # Revolutionary AI system
         self.ai_manager = AIStrategyManager()
-        
+
         # Social trading platform
         self.social_marketplace = SocialTradingMarketplace(self.db)
         self.strategy_marketplace = StrategyMarketplace(self.db)
         self.community_intel = CommunityIntelligence()
         self.rewards = RewardSystem()
-        
+
         # Sentiment analysis with full Twitter OAuth 2.0 credentials
         self.sentiment_analyzer = SocialMediaAggregator(
-            twitter_api_key=os.getenv('TWITTER_API_KEY'),
-            twitter_bearer_token=os.getenv('TWITTER_BEARER_TOKEN'),
-            twitter_client_id=os.getenv('TWITTER_CLIENT_ID'),
-            twitter_client_secret=os.getenv('TWITTER_CLIENT_SECRET'),
+            twitter_api_key=self.config.twitter_api_key,
+            twitter_bearer_token=self.config.twitter_bearer_token,
+            twitter_client_id=self.config.twitter_client_id,
+            twitter_client_secret=self.config.twitter_client_secret,
             reddit_credentials={
-                'client_id': os.getenv('REDDIT_CLIENT_ID'),
-                'client_secret': os.getenv('REDDIT_CLIENT_SECRET')
+                'client_id': self.config.reddit_client_id,
+                'client_secret': self.config.reddit_client_secret,
+                'user_agent': self.config.reddit_user_agent,
             },
-            discord_token=os.getenv('DISCORD_TOKEN')
+            discord_token=self.config.discord_token,
         )
         self.trend_detector = TrendDetector()
-        
+
         # Trading execution
         self.jupiter = JupiterClient(self.client)
         self.anti_mev = AntiMEVProtection(self.client)
-        
+
         # ğŸš€ ELITE SYSTEMS
         self.wallet_intelligence = WalletIntelligenceEngine(self.client)
         self.elite_protection = EliteProtectionSystem(self.client, ProtectionConfig())
-        self.auto_trader = None  # Initialized when user starts auto-trading
-        
-        # ğŸ¯ Auto-Sniper with Elite Protection
+
+        # Monitoring & performance tracking
+        self.monitor = monitor or BotMonitor(None, admin_chat_id=self.config.admin_chat_id)
+        self.performance = PerformanceTracker()
+
+        # Centralized trade execution
+        self.trade_executor = TradeExecutionService(
+            self.db,
+            self.wallet_manager,
+            self.jupiter,
+            protection=self.elite_protection,
+            monitor=self.monitor,
+            social_marketplace=self.social_marketplace,
+            rewards=self.rewards,
+            default_user_settings=self.default_user_settings,
+        )
+
+        # Share executor with marketplace for copy trades
+        self.social_marketplace.attach_trade_executor(self.trade_executor)
+
+        # Automated trading engine is created on demand
+        self.auto_trader = None
+
+        # ğŸ¯ Auto-Sniper with Elite Protection and centralized execution
         self.sniper = AutoSniper(
             self.ai_manager,
-            self.wallet_manager, 
+            self.wallet_manager,
             self.jupiter,
-            protection_system=self.elite_protection
+            database_manager=self.db,
+            protection_system=self.elite_protection,
+            trade_executor=self.trade_executor,
+            sentiment_aggregator=self.sentiment_analyzer,
+            community_intel=self.community_intel,
         )
-        
-        # Monitoring
-        self.monitor = BotMonitor(None, admin_chat_id=int(os.getenv('ADMIN_CHAT_ID', 0)))
-        self.performance = PerformanceTracker()
-        
+        self.sniper.register_notification_handler(self._handle_sniper_notification)
+
+        # Shutdown coordination
+        self._stop_event: Optional[asyncio.Event] = None
+        self.app: Optional[Application] = None
+
         logger.info("ğŸš€ Revolutionary Trading Bot initialized!")
         logger.info("ğŸ” Individual user wallets enabled")
         logger.info("ğŸ¯ Elite Auto-sniper ready")
         logger.info("ğŸ§  Wallet Intelligence System ready")
         logger.info("ğŸ›¡ï¸ Elite Protection System (6-layer) ready")
         logger.info("ğŸ¤– Automated Trading Engine ready")
-    
+
+    def _build_default_user_settings(self) -> Dict[str, Any]:
+        trading = self.config.trading
+        return {
+            'max_trade_size_sol': trading.max_trade_size_sol,
+            'daily_loss_limit_sol': trading.daily_loss_limit_sol,
+            'slippage_percentage': trading.max_slippage,
+            'require_confirmation': trading.require_confirmation,
+            'use_stop_loss': trading.stop_loss_percentage > 0,
+            'default_stop_loss_percentage': trading.stop_loss_percentage,
+            'use_take_profit': trading.take_profit_percentage > 0,
+            'default_take_profit_percentage': trading.take_profit_percentage,
+            'check_honeypots': trading.honeypot_check_enabled,
+            'min_liquidity_usd': trading.min_liquidity_usd,
+        }
+
+    def _is_admin(self, update: Update) -> bool:
+        """Return True when the incoming update belongs to the admin chat."""
+
+        if not self.config.admin_chat_id:
+            return False
+
+        user = update.effective_user if update else None
+        chat = update.effective_chat if update else None
+        candidates = (
+            getattr(user, "id", None),
+            getattr(chat, "id", None),
+        )
+        return any(identifier == self.config.admin_chat_id for identifier in candidates)
+
     def _load_wallet(self) -> Optional[Keypair]:
         """Load wallet from environment"""
-        private_key = os.getenv('WALLET_PRIVATE_KEY')
+        private_key = self.config.wallet_private_key
         if private_key:
             import base58
             return Keypair.from_bytes(base58.b58decode(private_key))
         return None
     
     # ==================== TELEGRAM COMMANDS ====================
     
     async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
         """Welcome message with professional UI and buttons"""
         user_id = update.effective_user.id
         username = update.effective_user.username or f"user_{user_id}"
         first_name = update.effective_user.first_name or username
         
         # ğŸ” Create individual wallet for user
         wallet_info = await self.wallet_manager.get_or_create_user_wallet(user_id, username)
         
         # Register trader
         await self.social_marketplace.register_trader(user_id, username)
         
         # Award login points
         await self.rewards.award_points(user_id, REWARD_POINTS['daily_login'], 'Daily login')
         
         wallet_status = "âœ¨ *New wallet created!*" if wallet_info['is_new'] else f"Balance: {wallet_info['sol_balance']:.4f} SOL"
         
         welcome_message = f"""*Welcome {first_name}!* ğŸ‰
@@ -307,64 +377,159 @@ Send SOL to your personal trading wallet:
 3. Send SOL to this address
 4. Funds arrive instantly!
 
 âš ï¸ *Important:*
 â€¢ Only send SOL to this address
 â€¢ Minimum deposit: 0.01 SOL
 â€¢ Network: Solana Mainnet
 
 After depositing, use /balance to check your new balance
 """
         
         keyboard = [
             [InlineKeyboardButton("ğŸ”„ Check Balance", callback_data="refresh_wallet")],
             [InlineKeyboardButton("â—€ï¸ Back", callback_data="show_wallet")]
         ]
         
         await update.message.reply_text(
             message,
             parse_mode='Markdown',
             reply_markup=InlineKeyboardMarkup(keyboard)
         )
     
     async def balance_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
         """Quick balance check"""
         user_id = update.effective_user.id
-        
+
         balance = await self.wallet_manager.get_user_balance(user_id)
         wallet_address = await self.wallet_manager.get_user_wallet_address(user_id)
-        
+
         if not wallet_address:
             await update.message.reply_text("âŒ No wallet found. Use /start")
             return
-        
+
         await update.message.reply_text(
             f"ğŸ’° *Your Balance:* {balance:.6f} SOL\n\n"
             f"Wallet: `{wallet_address[:8]}...{wallet_address[-8:]}`",
             parse_mode='Markdown'
         )
-    
+
+    async def buy_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
+        """Execute a manual buy using the user's wallet"""
+        user_id = update.effective_user.id
+
+        if not context.args or len(context.args) < 2:
+            await update.message.reply_text(
+                "Usage: /buy <token_mint> <amount_sol>"
+            )
+            return
+
+        token_mint = context.args[0]
+
+        try:
+            amount_sol = float(context.args[1])
+        except ValueError:
+            await update.message.reply_text("Amount must be a number (SOL)")
+            return
+
+        token_symbol = context.args[2] if len(context.args) >= 3 else None
+
+        progress_message = await update.message.reply_text("â³ Executing buy order...")
+
+        result = await self.trade_executor.execute_buy(
+            user_id,
+            token_mint,
+            amount_sol,
+            token_symbol=token_symbol,
+            reason='manual_command',
+            context='manual_command'
+        )
+
+        if result.get('success'):
+            message = (
+                "âœ… *BUY EXECUTED*\n\n"
+                f"Token: `{token_mint[:8]}...`\n"
+                f"Amount: {amount_sol:.4f} SOL\n"
+                f"Received: {result.get('amount_tokens', 0):.4f} tokens\n"
+                f"Price: {result.get('price', 0) or 0:.6f} SOL/token\n"
+                f"Signature: `{(result.get('signature') or '')[:16]}...`"
+            )
+        else:
+            message = f"âŒ Buy failed: {result.get('error', 'Unknown error')}"
+
+        await progress_message.edit_text(message, parse_mode='Markdown')
+
+    async def sell_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
+        """Execute a manual sell for an open position"""
+        user_id = update.effective_user.id
+
+        if not context.args:
+            await update.message.reply_text(
+                "Usage: /sell <token_mint> [amount_tokens|all]"
+            )
+            return
+
+        token_mint = context.args[0]
+        amount_tokens = None
+
+        if len(context.args) >= 2:
+            amount_arg = context.args[1].lower()
+            if amount_arg == 'all':
+                amount_tokens = None
+            else:
+                try:
+                    amount_tokens = float(context.args[1])
+                except ValueError:
+                    await update.message.reply_text(
+                        "Amount must be numeric or 'all'"
+                    )
+                    return
+
+        progress_message = await update.message.reply_text("â³ Executing sell order...")
+
+        result = await self.trade_executor.execute_sell(
+            user_id,
+            token_mint,
+            amount_tokens=amount_tokens,
+            reason='manual_command',
+            context='manual_command'
+        )
+
+        if result.get('success'):
+            message = (
+                "âœ… *SELL EXECUTED*\n\n"
+                f"Token: `{token_mint[:8]}...`\n"
+                f"Tokens sold: {result.get('amount_tokens', 0):.4f}\n"
+                f"Received: {result.get('amount_sol', 0):.4f} SOL\n"
+                f"PnL: {result.get('pnl', 0):+.4f} SOL\n"
+                f"Signature: `{(result.get('signature') or '')[:16]}...`"
+            )
+        else:
+            message = f"âŒ Sell failed: {result.get('error', 'Unknown error')}"
+
+        await progress_message.edit_text(message, parse_mode='Markdown')
+
     async def export_wallet_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
         """
         ğŸ” EXPORT PRIVATE KEY
         Allows users to export their private key to import into Phantom, Solflare, etc.
         """
         user_id = update.effective_user.id
         chat_type = update.message.chat.type
         
         # Security: Only allow in private chats
         if chat_type != 'private':
             await update.message.reply_text(
                 "âš ï¸ *SECURITY WARNING*\n\n"
                 "For your security, private keys can only be exported in private messages.\n\n"
                 "Please send `/export_wallet` to me in a private message.",
                 parse_mode='Markdown'
             )
             return
         
         # Get user's wallet
         wallet_address = await self.wallet_manager.get_user_wallet_address(user_id)
         
         if not wallet_address:
             await update.message.reply_text(
                 "âŒ No wallet found. Use /start to create one first!"
             )
@@ -406,114 +571,152 @@ After depositing, use /balance to check your new balance
 *After importing, you have FULL control of your funds in both places.*
 
 ğŸ—‘ï¸ Please delete this message after saving your key safely!"""
         
         await update.message.reply_text(message, parse_mode='Markdown')
         
         logger.info(f"User {user_id} exported their private key")
     
     async def ai_analyze_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
         """
         ğŸ”¥ KILLER FEATURE #1: AI-Powered Token Analysis
         No other bot has this level of intelligence
         """
         if len(context.args) < 1:
             await update.message.reply_text("Usage: /ai_analyze <token_address>")
             return
         
         token_mint = context.args[0]
         user_id = update.effective_user.id
         
         await update.message.reply_text("ğŸ¤– *AI ANALYSIS IN PROGRESS...*\n\nThe AI is analyzing:\nâ€¢ ML predictions\nâ€¢ Social sentiment\nâ€¢ Community signals\nâ€¢ Market patterns\nâ€¢ Risk factors", parse_mode='Markdown')
         
         try:
             # Get token data (implement actual data fetching)
             token_data = await self._fetch_token_data(token_mint)
-            
-            # Get portfolio value
-            portfolio_value = await self._get_portfolio_value(user_id)
-            
-            # ğŸ”¥ AI ANALYSIS
-            ai_analysis = await self.ai_manager.analyze_opportunity(
-                token_data,
-                portfolio_value
-            )
-            
+
             # ğŸ”¥ SENTIMENT ANALYSIS
             sentiment = await self.sentiment_analyzer.analyze_token_sentiment(
                 token_mint,
                 token_data.get('symbol', 'UNKNOWN')
             )
-            
+
             # ğŸ”¥ COMMUNITY INTELLIGENCE
             community_signal = await self.community_intel.get_community_signal(token_mint)
+
+            enriched_token_data = dict(token_data)
+            if sentiment:
+                enriched_token_data['sentiment_score'] = sentiment.get(
+                    'sentiment_score',
+                    enriched_token_data.get('sentiment_score', 50)
+                )
+                enriched_token_data['social_mentions'] = sentiment.get(
+                    'total_mentions',
+                    enriched_token_data.get('social_mentions', 0)
+                )
+                enriched_token_data['social_score'] = sentiment.get(
+                    'social_score',
+                    enriched_token_data.get('social_score', 0)
+                )
+
+            if community_signal:
+                enriched_token_data['community_score'] = community_signal.get(
+                    'community_score',
+                    enriched_token_data.get('community_score', 0)
+                )
+
+            enriched_token_data.setdefault('social_score', enriched_token_data.get('sentiment_score', 0))
+            enriched_token_data.setdefault('community_score', 0.0)
+
+            # Get portfolio value
+            portfolio_value = await self._get_portfolio_value(user_id)
+
+            # ğŸ”¥ AI ANALYSIS
+            ai_analysis = await self.ai_manager.analyze_opportunity(
+                enriched_token_data,
+                portfolio_value,
+                sentiment_snapshot=sentiment,
+                community_signal=community_signal
+            )
             
             # Build comprehensive analysis
             ml_pred = ai_analysis.get('ml_prediction', {})
             key_factors = ml_pred.get('key_factors', [])
             key_factors_text = ', '.join(key_factors[:3]) if key_factors else 'N/A'
             
             message = f"""
 ğŸ¤– *AI ANALYSIS COMPLETE*
 
 *Token:* `{token_mint[:8]}...`
 
 *ğŸ¯ AI RECOMMENDATION:* *{ai_analysis['action'].upper()}*
 *Confidence:* {ai_analysis['confidence']:.1%}
 *Risk Level:* {ai_analysis['risk_level'].upper()}
 
 *ğŸ“Š ML MODEL PREDICTION:*
 Success Probability: {ml_pred.get('probability', 0):.1%}
 Recommendation: {ml_pred.get('recommendation', 'N/A')}
 Key Factors: {key_factors_text}
 
 *ğŸ“± SOCIAL SENTIMENT:*
 """
             
             # Check if sentiment data is available
-            twitter_mentions = sentiment.get('twitter', {}).get('mentions', 0)
-            if twitter_mentions > 0:
+            twitter_mentions = sentiment.get('twitter', {}).get('mentions', 0) if sentiment else 0
+            total_mentions = sentiment.get('total_mentions', 0) if sentiment else 0
+            if sentiment and (twitter_mentions > 0 or total_mentions > 0):
                 message += f"""Score: {sentiment['sentiment_score']:.1f}/100
+Social Mentions: {total_mentions}
 Twitter Mentions: {twitter_mentions}
-Viral Potential: {sentiment['viral_potential']:.1%}
+Viral Potential: {sentiment.get('viral_potential', 0):.1%}
 Going Viral: {"ğŸ”¥ YES" if sentiment.get('twitter', {}).get('trending', False) else "No"}
 """
             else:
-                message += """âš ï¸ Not Available (API keys required)
-Configure TWITTER_API_KEY in .env for real-time sentiment
+                message += """No recent social chatter detected
+Connect Twitter/Reddit/Discord APIs for live data
 
 """
             
             message += "\n*ğŸ‘¥ COMMUNITY INTELLIGENCE:*\n"
             
             if community_signal:
                 message += f"""Community Score: {community_signal['community_score']:.1f}/100
 Ratings: {community_signal['total_ratings']}
 Flags: {community_signal['flag_count']}
 Sentiment: {community_signal['sentiment'].upper()}
 
 """
+
+            social_context = ai_analysis.get('social_context')
+            if social_context:
+                message += "\n*ğŸ“¡ SOCIAL & COMMUNITY IMPACT:*\n"
+                message += (
+                    f"Composite Bias: {social_context['label'].replace('_', ' ').title()} "
+                    f"({social_context['score'] * 100:.0f}/100)\n"
+                )
+                for insight in social_context.get('insights', [])[:3]:
+                    message += f"â€¢ {insight}\n"
             
             # Escape special characters in reasoning
             reasoning_text = str(ai_analysis['reasoning']).replace('|', '\\|').replace('_', '\\_')
             
             message += f"""*ğŸ’° SUGGESTED POSITION:*
 Size: {ai_analysis['position_size']:.4f} SOL
 Strategy: {ai_analysis['strategy'].upper()}
 Market Regime: {ai_analysis['market_regime'].upper()}
 
 *ğŸ§  AI REASONING:*
 {reasoning_text}
 
 """
             
             # Add action buttons
             if ai_analysis['action'] in ['buy', 'strong_buy']:
                 keyboard = [
                     [
                         InlineKeyboardButton(
                             f"ğŸš€ Buy {ai_analysis['position_size']:.4f} SOL",
                             callback_data=f"ai_buy_{token_mint}_{ai_analysis['position_size']}"
                         )
                     ],
                     [
                         InlineKeyboardButton("ğŸ“Š More Details", callback_data=f"details_{token_mint}"),
@@ -664,76 +867,87 @@ Use /leaderboard to see when traders appear!"""
 You're about to copy: *{trader.username}*
 
 *Trader Stats:*
 â€¢ Tier: {trader.tier.value.upper()}
 â€¢ Score: {trader.reputation_score:.1f}/100
 â€¢ Win Rate: {trader.win_rate:.1f}%
 â€¢ Total PnL: {trader.total_pnl:+.4f} SOL
 â€¢ Followers: {trader.followers}
 
 *How it works:*
 When they buy, you buy automatically
 When they sell, you sell automatically
 
 Select amount per trade:
 """
             await update.message.reply_text(message, parse_mode='Markdown', reply_markup=reply_markup)
             
         except ValueError:
             await update.message.reply_text("âŒ Invalid trader ID")
     
     async def stop_copy_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
         """Stop copying a trader"""
         if len(context.args) < 1:
             # Show who user is copying
             follower_id = update.effective_user.id
-            
+
             # Check active copies
-            if follower_id not in self.social_marketplace.active_copies:
+            user_copies = self.social_marketplace.active_copies.get(follower_id, {})
+            active_traders = [
+                trader_id
+                for trader_id, copy_settings in user_copies.items()
+                if copy_settings.get('enabled')
+            ]
+
+            if not active_traders:
                 await update.message.reply_text(
                     "You're not copying anyone.\n\n"
                     "Use /leaderboard to find traders to copy!"
                 )
                 return
-            
-            copy_settings = self.social_marketplace.active_copies[follower_id]
-            trader_id = copy_settings['trader_id']
-            trader = await self.social_marketplace.get_trader_profile(trader_id)
-            
-            if trader:
-                message = f"""ğŸ‘¥ *STOP COPY TRADING*
 
-You're currently copying: *{trader.username}*
+            lines = []
+            for trader_id in active_traders:
+                trader = await self.social_marketplace.get_trader_profile(trader_id)
+                copy_settings = user_copies.get(trader_id, {})
+                trader_name = trader.username if trader else f"Trader {trader_id}"
+                max_amount = copy_settings.get('max_copy_amount', 0) or 0
+                lines.append(
+                    f"*{trader_name}* (ID: {trader_id})\n"
+                    f"Total copied: {copy_settings.get('total_copied', 0)} trades\n"
+                    f"Max per trade: {max_amount:.4f} SOL\n"
+                )
+
+            message = """ğŸ‘¥ *ACTIVE COPY TRADES*
 
-Total copied: {copy_settings['total_copied']} trades
-Total profit: {copy_settings.get('total_profit', 0):+.4f} SOL
+{details}
+Use `/stop_copy <trader_id>` to stop copying a trader.
+""".format(details="\n".join(lines))
 
-Use: `/stop_copy {trader_id}` to stop
-"""
-                await update.message.reply_text(message, parse_mode='Markdown')
+            await update.message.reply_text(message, parse_mode='Markdown')
             return
-        
+
         try:
             trader_id = int(context.args[0])
             follower_id = update.effective_user.id
             
             # Stop copying
             success = await self.social_marketplace.stop_copying_trader(follower_id, trader_id)
             
             if success:
                 message = f"""âœ… *COPY TRADING STOPPED*
 
 You stopped copying trader {trader_id}
 
 You can start copying again anytime with:
 /copy_trader {trader_id}
 
 Or find new traders:
 /leaderboard
 """
                 keyboard = [
                     [InlineKeyboardButton("ğŸ† View Leaderboard", callback_data="leaderboard")],
                     [InlineKeyboardButton("ğŸ“Š My Stats", callback_data="my_stats")]
                 ]
                 await update.message.reply_text(
                     message,
                     parse_mode='Markdown',
@@ -823,91 +1037,91 @@ Manual snipe:
         
         # Don't use Markdown to avoid parsing errors with $ and other special chars
         await update.message.reply_text(
             message,
             parse_mode=None,
             reply_markup=InlineKeyboardMarkup(keyboard)
         )
     
     async def snipe_enable_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
         """Enable auto-snipe for user"""
         user_id = update.effective_user.id
         
         # Check balance
         balance = await self.wallet_manager.get_user_balance(user_id)
         if balance < 0.01:
             await update.message.reply_text(
                 "âŒ *Insufficient Balance*\n\n"
                 "You need at least 0.01 SOL to enable auto-snipe.\n\n"
                 "Use /deposit to fund your wallet.",
                 parse_mode='Markdown'
             )
             return
         
         # Enable snipe
         await self.db.update_user_settings(user_id, {'snipe_enabled': True})
-        
+
         # Enable in sniper
-        self.sniper.enable_snipe(user_id)
+        await self.sniper.enable_snipe(user_id)
         
         message = """âœ… AUTO-SNIPE ENABLED!
 
 Your bot is now monitoring pump.fun for new launches!
 
 What happens next:
 â€¢ Bot checks every 30 seconds for new tokens
 â€¢ When found, AI analyzes automatically
 â€¢ If AI recommends strong buy, executes trade
 â€¢ You get instant notification
 
 Your Settings:
 â€¢ Max per snipe: 0.1 SOL
 â€¢ Min liquidity: $10,000
 â€¢ Min AI confidence: 65%
 â€¢ Daily limit: 10 snipes
 
 To configure:
 /snipe - View settings
 /snipe_disable - Turn off
 
 Important:
 Keep sufficient SOL balance for snipes!
 
 ğŸ¯ Sniper is ACTIVE and hunting!
 """
         
         await update.message.reply_text(message, parse_mode=None)
     
     async def snipe_disable_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
         """Disable auto-snipe for user"""
         user_id = update.effective_user.id
         
         # Disable snipe
         await self.db.update_user_settings(user_id, {'snipe_enabled': False})
-        
+
         # Disable in sniper
-        self.sniper.disable_snipe(user_id)
+        await self.sniper.disable_snipe(user_id)
         
         await update.message.reply_text(
             "âŒ AUTO-SNIPE DISABLED\n\n"
             "You will no longer auto-buy new tokens.\n\n"
             "To enable again: /snipe_enable",
             parse_mode=None
         )
     
     async def trending_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
         """
         ğŸ”¥ KILLER FEATURE #4: Viral Token Detection
         Real-time detection of tokens going viral
         """
         await update.message.reply_text("ğŸ”¥ *DETECTING VIRAL TOKENS...*", parse_mode='Markdown')
         
         try:
             # Get viral tokens
             viral_tokens = await self.sentiment_analyzer.detect_viral_tokens(min_score=70)
             
             # Get emerging trends
             trends = await self.trend_detector.detect_emerging_trends()
         except Exception as e:
             logger.error(f"Trending detection error: {e}")
             viral_tokens = []
             trends = []
@@ -1685,51 +1899,53 @@ Use /rankings to see top wallets!
         
         # Check balance
         balance = await self.wallet_manager.get_user_balance(user_id)
         if balance < 0.1:
             await update.message.reply_text(
                 "âŒ Insufficient Balance\n\n"
                 "You need at least 0.1 SOL to enable auto-trading.\n\n"
                 "Use /deposit to fund your wallet.",
                 parse_mode=None
             )
             return
         
         # Get user keypair
         user_keypair = await self.wallet_manager.get_user_keypair(user_id)
         if not user_keypair:
             await update.message.reply_text("âŒ Could not access your wallet")
             return
         
         # Initialize auto trader if not exists
         if not self.auto_trader:
             config = AutoTradingConfig()
             self.auto_trader = AutomatedTradingEngine(
                 config,
                 self.wallet_intelligence,
                 self.jupiter,
-                self.elite_protection
+                self.elite_protection,
+                trade_executor=self.trade_executor,
+                monitor=self.monitor,
             )
         
         # Start automated trading (with database for loading tracked wallets)
         try:
             logger.info(f"ğŸ¯ Starting automated trading for user {user_id}...")
             await self.auto_trader.start_automated_trading(
                 user_id,
                 user_keypair,
                 self.wallet_manager,
                 self.db  # Pass database manager to load tracked wallets
             )
             logger.info(f"âœ… Automated trading successfully started for user {user_id}")
             
             # ğŸ¯ Register auto-trader with sniper for position tracking
             self.sniper.register_auto_trader(self.auto_trader)
             
         except Exception as e:
             logger.error(f"âŒ ERROR starting automated trading: {e}", exc_info=True)
             await update.message.reply_text(
                 f"âŒ Error starting automated trading:\n{str(e)}\n\n"
                 "Please contact support if this persists."
             )
             return
         
         message = """ğŸ¤– AUTOMATED TRADING STARTED!
@@ -1763,80 +1979,102 @@ COMMANDS:
 """
         
         await update.message.reply_text(message, parse_mode=None)
     
     async def autostop_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
         """Stop automated trading"""
         if self.auto_trader and self.auto_trader.is_running:
             await self.auto_trader.stop_automated_trading()
             await update.message.reply_text(
                 "ğŸ›‘ AUTOMATED TRADING STOPPED\n\n"
                 "All open positions remain active.\n"
                 "Use /positions to manage them.\n\n"
                 "To restart: /autostart"
             )
         else:
             await update.message.reply_text(
                 "Automated trading is not running.\n\n"
                 "Use /autostart to enable it."
             )
     
     async def autostatus_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
         """Show automated trading status"""
         if not self.auto_trader:
             await update.message.reply_text("Automated trading not initialized. Use /autostart")
             return
-        
+
         status = self.auto_trader.get_status()
         
         status_emoji = "âœ… RUNNING" if status['is_running'] else "âŒ STOPPED"
         
         message = f"""ğŸ¤– AUTOMATED TRADING STATUS
 
 Status: {status_emoji}
 
 TODAY'S STATS:
 â€¢ Trades Executed: {status['daily_trades']}
 â€¢ Total P&L: {status['daily_pnl']:+.4f} SOL
 â€¢ Active Positions: {status['active_positions']}
 
 OPEN POSITIONS:
 """
         
         if status['positions']:
             for token in status['positions']:
                 message += f"â€¢ {token[:8]}...\n"
         else:
             message += "â€¢ None\n"
         
         message += "\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
         message += "Commands:\n"
         message += "/autostop - Stop trading\n"
         message += "/positions - Manage positions"
-        
+
         await update.message.reply_text(message, parse_mode=None)
-    
+
+    async def metrics_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
+        """Return live operational telemetry for the administrator."""
+
+        message = update.effective_message
+        if not message:
+            return
+
+        if not self._is_admin(update):
+            await message.reply_text("âŒ Metrics are available to the admin only.")
+            return
+
+        if not self.monitor:
+            await message.reply_text("Monitoring is currently disabled.")
+            return
+
+        report = self.monitor.render_markdown_summary()
+        await message.reply_text(
+            report,
+            parse_mode="Markdown",
+            disable_web_page_preview=True,
+        )
+
     async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
         """Show help menu with all commands"""
         message = """â“ HELP & COMMANDS
 
 ğŸ’° WALLET:
 /wallet - Your wallet info
 /balance - Check balance
 /deposit - Deposit instructions
 /export_wallet - Export private keys
 
 ğŸ“Š ANALYSIS:
 /analyze <token> - AI analysis
 /ai <token> - Quick analysis
 /trending - Viral tokens
 /community <token> - Ratings
 
 ğŸ’° TRADING:
 /buy <token> <amount>
 /sell <token> <amount>
 /snipe <token>
 /positions - Open trades
 
 ğŸ§  ELITE FEATURES:
 /track <wallet> - Track wallet performance
 /rankings - Top performing wallets
@@ -2122,56 +2360,56 @@ Click *Get Started* to fund your trading wallet then:
                 )
                 
                 # Award points
                 await self.rewards.award_points(
                     query.from_user.id,
                     REWARD_POINTS['help_user'],
                     'Started copy trading'
                 )
         
         elif data.startswith("snipe_toggle_"):
             # Toggle snipe on/off
             parts = data.split("_")
             user_id = int(parts[2])
             
             if query.from_user.id != user_id:
                 await query.answer("This is not your sniper settings!", show_alert=True)
                 return
             
             # Get current status
             settings = await self.db.get_user_settings(user_id)
             current_status = settings.snipe_enabled if settings else False
             
             # Toggle
             new_status = not current_status
             await self.db.update_user_settings(user_id, {'snipe_enabled': new_status})
-            
+
             if new_status:
-                self.sniper.enable_snipe(user_id)
+                await self.sniper.enable_snipe(user_id)
                 status_msg = "âœ… AUTO-SNIPE ENABLED!\n\nMonitoring new launches..."
             else:
-                self.sniper.disable_snipe(user_id)
+                await self.sniper.disable_snipe(user_id)
                 status_msg = "âŒ AUTO-SNIPE DISABLED\n\nNo longer monitoring."
             
             await query.edit_message_text(status_msg, parse_mode=None)
         
         elif data.startswith("snipe_config_"):
             # Show configuration options
             user_id = int(data.split("_")[2])
             
             message = """âš™ï¸ SNIPER CONFIGURATION
 
 Adjust your sniper settings:
 
 Use these commands:
 /snipe - View current settings
 /snipe_enable - Enable sniper
 /snipe_disable - Disable sniper
 
 Advanced settings coming soon:
 â€¢ Custom buy amounts
 â€¢ Liquidity filters
 â€¢ AI confidence threshold
 â€¢ Daily limits
 """
             
             keyboard = [[InlineKeyboardButton("â—€ï¸ Back", callback_data="back_to_start")]]
@@ -2274,52 +2512,52 @@ Configure your trading preferences:
 *Features:*
 â€¢ AI Analysis: âœ… Enabled
 â€¢ Copy Trading: âœ… Enabled
 â€¢ Auto-Alerts: âœ… Enabled
 
 Use /settings command to modify these settings
 """
         keyboard = [[InlineKeyboardButton("â—€ï¸ Back", callback_data="back_to_start")]]
         await query.edit_message_text(
             message,
             parse_mode='Markdown',
             reply_markup=InlineKeyboardMarkup(keyboard)
         )
     
     async def _show_help_menu(self, query):
         """Show help menu with all commands"""
         message = """â“ *HELP & COMMANDS*
 
 *ğŸ“Š Analysis Commands:*
 /analyze <token> - AI-powered analysis
 /ai <token> - Quick AI analysis
 /trending - Trending tokens right now
 /community <token> - Community ratings
 
 *ğŸ’° Trading Commands:*
-/buy <token> <amount> - Buy tokens
-/sell <token> <amount> - Sell tokens
+/buy <token_mint> <amount_sol> - Swap SOL into a token
+/sell <token_mint> [amount_tokens|all] - Exit an open position
 /snipe <token> - Snipe new launch
 /positions - View open positions
 
 *ğŸ‘¥ Social Trading:*
 /leaderboard - Top traders
 /copy <trader_id> - Copy a trader
 /stop_copy <trader_id> - Stop copying
 /my_followers - Who's copying you
 
 *ğŸ® Rewards & Stats:*
 /my_stats - Your performance
 /rewards - Points & tier status
 /achievements - Your achievements
 
 *ğŸ›¡ï¸ Safety:*
 /settings - Configure bot
 /limits - View safety limits
 
 *Need more help?* Visit our documentation
 """
         keyboard = [[InlineKeyboardButton("â—€ï¸ Back", callback_data="back_to_start")]]
         await query.edit_message_text(
             message,
             parse_mode='Markdown',
             reply_markup=InlineKeyboardMarkup(keyboard)
@@ -2340,257 +2578,373 @@ Use /settings command to modify these settings
             'volume_24h': 100000,
             'price_change_1h': 5.0,
             'price_change_24h': 10.0,
             'holder_count': 500,
             'top_10_holder_percentage': 30,
             'transaction_count_1h': 100,
             'buy_sell_ratio': 1.5,
             'market_cap': 1000000,
             'age_hours': 48,
             'social_mentions': 50,
             'sentiment_score': 65
         }
     
     async def _get_portfolio_value(self, user_id: int) -> float:
         """Get user's total portfolio value (SOL balance)"""
         return await self.wallet_manager.get_user_balance(user_id)
     
     async def _execute_ai_trade(
         self,
         user_id: int,
         token_mint: str,
         amount: float,
         action: str
     ) -> Dict:
         """Execute AI-recommended trade using user's personal wallet"""
-        
+
+        if action != 'buy':
+            return {'success': False, 'error': 'Sell not implemented for AI trades yet'}
+
         try:
-            # ğŸ” Get user's personal keypair
-            user_keypair = await self.wallet_manager.get_user_keypair(user_id)
-            
-            if not user_keypair:
-                return {'success': False, 'error': 'User wallet not found'}
-            
-            # Check user has sufficient balance
-            balance = await self.wallet_manager.get_user_balance(user_id)
-            if balance < amount:
-                return {
-                    'success': False,
-                    'error': f'Insufficient balance. You have {balance:.4f} SOL, need {amount:.4f} SOL'
-                }
-            
-            if action == 'buy':
-                async with self.jupiter:
-                    result = await self.jupiter.execute_swap(
-                        'So11111111111111111111111111111111111111112',  # SOL
-                        token_mint,
-                        int(amount * 1e9),  # Convert to lamports
-                        user_keypair  # ğŸ” Use user's own wallet!
-                    )
-            else:
-                # Sell logic
-                result = {'success': False, 'error': 'Sell not implemented'}
-            
-            # Record trade
-            if result['success']:
-                await self.db.add_trade({
-                    'user_id': user_id,
-                    'signature': result['signature'],
-                    'trade_type': action,
-                    'token_mint': token_mint,
-                    'amount_sol': amount,
-                    'success': True
-                })
-                
-                # Award points
-                await self.rewards.award_points(
-                    user_id,
-                    REWARD_POINTS['successful_trade'],
-                    'Successful trade'
-                )
-            
-            return result
-            
+            return await self.trade_executor.execute_buy(
+                user_id,
+                token_mint,
+                amount,
+                reason='ai_signal',
+                context='ai_signal'
+            )
         except Exception as e:
             logger.error(f"Trade execution error: {e}")
             return {'success': False, 'error': str(e)}
     
     async def _get_user_points(self, user_id: int) -> int:
         """Get user's reward points"""
         rewards = await self.rewards.get_user_rewards(user_id)
         return rewards['points']
     
     async def _get_user_tier(self, user_id: int) -> str:
         """Get user's tier"""
         rewards = await self.rewards.get_user_rewards(user_id)
         return rewards['tier']
     
     def _get_tier_emoji(self, tier) -> str:
         """Get emoji for tier"""
         emojis = {
             'bronze': 'ğŸ¥‰',
             'silver': 'ğŸ¥ˆ',
             'gold': 'ğŸ¥‡',
             'platinum': 'ğŸ’',
             'diamond': 'ğŸ‘‘'
         }
         return emojis.get(tier.value, 'â­')
     
     async def _load_sniper_settings(self):
         """Load enabled sniper settings from database"""
         try:
-            # Get all user settings from database
-            # For now, we'll enable snipers as users activate them
-            logger.info("ğŸ¯ Sniper settings loaded from database")
+            loaded = await self.sniper.load_persistent_settings()
+            logger.info(
+                "ğŸ¯ Sniper settings loaded from database (%d profiles)",
+                len(loaded)
+            )
         except Exception as e:
             logger.error(f"Error loading sniper settings: {e}")
-    
-    async def start(self):
+
+    async def _notify_user(self, chat_id: int, message: str) -> None:
+        """Send a Telegram message if the bot instance is available."""
+
+        bot = None
+        if self.app:
+            bot = getattr(self.app, "bot", None)
+
+        if not bot and self.monitor:
+            bot = getattr(self.monitor, "bot", None)
+
+        if not bot:
+            logger.debug("No Telegram bot available to notify chat %s", chat_id)
+            return
+
+        try:
+            await bot.send_message(chat_id=chat_id, text=message)
+        except TelegramError as exc:  # pragma: no cover - network dependent
+            logger.error("Failed to deliver sniper notification to %s: %s", chat_id, exc)
+
+    async def _handle_sniper_notification(self, event_type: str, payload: Dict[str, Any]) -> None:
+        """Format and forward sniper events to the relevant recipients."""
+
+        user_id = payload.get('user_id')
+        if not user_id:
+            return
+
+        token_symbol = payload.get('token_symbol') or payload.get('token_mint', 'Unknown')
+        amount_sol = payload.get('amount_sol')
+        confidence = payload.get('confidence')
+
+        if confidence is not None and confidence <= 1:
+            confidence_pct = confidence * 100
+        elif confidence is not None:
+            confidence_pct = confidence
+        else:
+            confidence_pct = None
+
+        if event_type == 'snipe_executed':
+            tokens = payload.get('amount_tokens')
+            price = payload.get('price')
+            signature = payload.get('signature')
+            bundle = payload.get('bundle_id')
+
+            lines = [
+                "ğŸ¯ AUTO-SNIPE EXECUTED",
+                "",
+                f"Token: {token_symbol}",
+            ]
+
+            if amount_sol is not None:
+                lines.append(f"Spent: {amount_sol:.4f} SOL")
+            if tokens is not None:
+                lines.append(f"Received: {tokens:.4f} tokens")
+            if price:
+                lines.append(f"Price: {price:.6f} SOL/token")
+            if confidence_pct is not None:
+                lines.append(f"AI confidence: {confidence_pct:.1f}%")
+            if signature:
+                lines.append(f"Signature: {signature}")
+            if bundle:
+                lines.append(f"Bundle: {bundle}")
+
+            lines.extend(["", "View with /positions"])
+            message = "\n".join(lines)
+
+            await self._notify_user(user_id, message)
+
+        elif event_type == 'snipe_failed':
+            error = payload.get('error', 'Unknown error')
+            lines = [
+                "âš ï¸ AUTO-SNIPE FAILED",
+                "",
+                f"Token: {token_symbol}",
+                f"Reason: {error}",
+            ]
+
+            if confidence_pct is not None:
+                lines.append(f"AI confidence: {confidence_pct:.1f}%")
+
+            lines.append("Use /snipe to review your settings.")
+            message = "\n".join(lines)
+
+            await self._notify_user(user_id, message)
+
+            if self.monitor:
+                await self.monitor.send_alert(
+                    "auto_sniper_failure",
+                    f"User {user_id} snipe failed for {token_symbol}: {error}",
+                )
+
+    async def start(self, shutdown_event: Optional[asyncio.Event] = None):
         """Start the bot (async version for runner script)"""
-        # Initialize database tables
-        await self.db.init_db()
-        
+        # Load persisted social trading state
+        await self.social_marketplace.initialize()
+
         # ğŸ¯ Start auto-sniper monitoring
         await self.sniper.start()
         logger.info("ğŸ¯ Auto-sniper monitoring started")
-        
+
         # Load enabled snipers from database
         await self._load_sniper_settings()
-        
-        app = Application.builder().token(os.getenv('TELEGRAM_BOT_TOKEN')).build()
-        
+
+        if shutdown_event is not None:
+            if shutdown_event.is_set():
+                shutdown_event.clear()
+            self._stop_event = shutdown_event
+        else:
+            self._stop_event = asyncio.Event()
+
+        self.app = Application.builder().token(self.config.telegram_bot_token).build()
+        app = self.app
+
         # Register all commands with aliases
         app.add_handler(CommandHandler("start", self.start_command))
         
         # ğŸ” Wallet commands (NEW!)
         app.add_handler(CommandHandler("wallet", self.wallet_command))
         app.add_handler(CommandHandler("deposit", self.deposit_command))
         app.add_handler(CommandHandler("balance", self.balance_command))
         app.add_handler(CommandHandler("export_wallet", self.export_wallet_command))
         app.add_handler(CommandHandler("export_keys", self.export_wallet_command))  # Alias
+
+        # Trading commands
+        app.add_handler(CommandHandler("buy", self.buy_command))
+        app.add_handler(CommandHandler("sell", self.sell_command))
         
         # Analysis commands (with short aliases)
         app.add_handler(CommandHandler("ai_analyze", self.ai_analyze_command))
         app.add_handler(CommandHandler("analyze", self.ai_analyze_command))
         app.add_handler(CommandHandler("ai", self.ai_analyze_command))
         
         # Social & trending
         app.add_handler(CommandHandler("leaderboard", self.leaderboard_command))
         app.add_handler(CommandHandler("trending", self.trending_command))
         
         # ğŸ¯ Sniper commands
         app.add_handler(CommandHandler("snipe", self.snipe_command))
         app.add_handler(CommandHandler("snipe_enable", self.snipe_enable_command))
         app.add_handler(CommandHandler("snipe_disable", self.snipe_disable_command))
         
         # ğŸ§  ELITE COMMANDS
         app.add_handler(CommandHandler("track", self.track_wallet_command))
         app.add_handler(CommandHandler("rankings", self.rankings_command))
         app.add_handler(CommandHandler("autostart", self.autostart_command))
         app.add_handler(CommandHandler("autostop", self.autostop_command))
         app.add_handler(CommandHandler("autostatus", self.autostatus_command))
         
         app.add_handler(CommandHandler("community", self.community_command))
         app.add_handler(CommandHandler("rate_token", self.rate_token_command))
         
         # Copy trading (with aliases)
         app.add_handler(CommandHandler("copy_trader", self.copy_trader_command))
         app.add_handler(CommandHandler("copy", self.copy_trader_command))
         app.add_handler(CommandHandler("stop_copy", self.stop_copy_command))
         
         # Stats & rewards
         app.add_handler(CommandHandler("my_stats", self.my_stats_command))
         app.add_handler(CommandHandler("stats", self.my_stats_command))
         app.add_handler(CommandHandler("rewards", self.rewards_command))
         
         # Strategy marketplace
         app.add_handler(CommandHandler("strategies", self.strategies_command))
         app.add_handler(CommandHandler("publish_strategy", self.publish_strategy_command))
         app.add_handler(CommandHandler("buy_strategy", self.buy_strategy_command))
         app.add_handler(CommandHandler("my_strategies", self.my_strategies_command))
-        
+
+        # Operations / admin tools
+        app.add_handler(CommandHandler("metrics", self.metrics_command))
+
         # Help
         app.add_handler(CommandHandler("help", self.help_command))
         app.add_handler(CommandHandler("features", self.features_command))
-        
+
         # Callback handler for all buttons
         app.add_handler(CallbackQueryHandler(self.button_callback))
         
         # Store app for cleanup
         self.app = app
         
         logger.info("ğŸš€ REVOLUTIONARY TRADING BOT STARTED!")
         logger.info("=" * 50)
         logger.info("FEATURES ACTIVE:")
         logger.info("âœ… AI-Powered Predictions")
         logger.info("âœ… Social Trading Marketplace")
         logger.info("âœ… Real-Time Sentiment Analysis")
         logger.info("âœ… Community Intelligence")
         logger.info("âœ… Adaptive Strategies")
         logger.info("âœ… Pattern Recognition")
         logger.info("âœ… Gamification & Rewards")
         logger.info("âœ… Strategy Marketplace")
         logger.info("âœ… Anti-MEV Protection")
         logger.info("âœ… Professional Risk Management")
         logger.info("=" * 50)
         
         # Initialize and start polling
         await app.initialize()
+        if self.monitor and not getattr(self.monitor, 'bot', None):
+            self.monitor.bot = app.bot
+
         await app.start()
         await app.updater.start_polling(allowed_updates=Update.ALL_TYPES)
-        
+
         logger.info("Bot is now listening for commands...")
-        
-        # Keep running until stopped
-        while True:
-            await asyncio.sleep(1)
-    
+
+        if self._stop_event is not None:
+            await self._stop_event.wait()
+            logger.info("Shutdown signal received; stopping bot loop")
+
+
     async def stop(self):
         """Stop the bot gracefully"""
-        if hasattr(self, 'app') and self.app:
-            logger.info("Stopping bot...")
+        if self._stop_event and not self._stop_event.is_set():
+            self._stop_event.set()
+
+        logger.info("Stopping bot...")
+
+        try:
+            await self.sniper.stop()
+        except Exception as exc:
+            logger.error(f"Error stopping sniper: {exc}")
+
+        if self.app:
             try:
-                # Stop sniper first
-                await self.sniper.stop()
-                
-                await self.app.updater.stop()
+                if getattr(self.app, "updater", None):
+                    await self.app.updater.stop()
                 await self.app.stop()
                 await self.app.shutdown()
                 logger.info("Bot stopped successfully")
-            except Exception as e:
-                logger.error(f"Error during shutdown: {e}")
-    
+            except Exception as exc:
+                logger.error(f"Error during Telegram shutdown: {exc}")
+
+        if self.monitor:
+            try:
+                await self.monitor.publish_summary("ğŸ›‘ Shutdown summary")
+            except Exception as exc:
+                logger.error("Failed to publish shutdown metrics: %s", exc)
+            self.monitor.bot = None
+
+        if self.client:
+            try:
+                await self.client.close()
+            except Exception as exc:
+                logger.error(f"Failed to close Solana client: {exc}")
+            finally:
+                self.client = None
+
+        if hasattr(self, 'db') and hasattr(self.db, 'dispose'):
+            try:
+                await self.db.dispose()
+            except Exception as exc:
+                logger.error(f"Failed to dispose database engine: {exc}")
+            finally:
+                self.db = None
+
     def run(self):
         """Start the revolutionary bot (sync version for direct use)"""
-        app = Application.builder().token(os.getenv('TELEGRAM_BOT_TOKEN')).build()
+        self.app = Application.builder().token(self.config.telegram_bot_token).build()
+        app = self.app
         
         # Register all commands
         app.add_handler(CommandHandler("start", self.start_command))
         app.add_handler(CommandHandler("ai_analyze", self.ai_analyze_command))
         app.add_handler(CommandHandler("leaderboard", self.leaderboard_command))
         app.add_handler(CommandHandler("copy_trader", self.copy_trader_command))
         app.add_handler(CommandHandler("trending", self.trending_command))
         app.add_handler(CommandHandler("my_stats", self.my_stats_command))
         app.add_handler(CommandHandler("strategies", self.strategies_command))
+        app.add_handler(CommandHandler("metrics", self.metrics_command))
         app.add_handler(CallbackQueryHandler(self.button_callback))
         
         logger.info("ğŸš€ REVOLUTIONARY TRADING BOT STARTED!")
         logger.info("=" * 50)
         logger.info("FEATURES ACTIVE:")
         logger.info("âœ… AI-Powered Predictions")
         logger.info("âœ… Social Trading Marketplace")
         logger.info("âœ… Real-Time Sentiment Analysis")
         logger.info("âœ… Community Intelligence")
         logger.info("âœ… Adaptive Strategies")
         logger.info("âœ… Pattern Recognition")
         logger.info("âœ… Gamification & Rewards")
         logger.info("âœ… Strategy Marketplace")
         logger.info("âœ… Anti-MEV Protection")
         logger.info("âœ… Professional Risk Management")
         logger.info("=" * 50)
         
         app.run_polling(allowed_updates=Update.ALL_TYPES)
 
 
+
 if __name__ == "__main__":
-    bot = RevolutionaryTradingBot()
-    bot.run()
+    config = get_config()
+    db_manager = DatabaseManager(config.database_url)
+    asyncio.run(db_manager.init_db())
+    client = AsyncClient(config.solana_rpc_url)
+
+    bot = RevolutionaryTradingBot(config, db_manager, solana_client=client)
+    try:
+        bot.run()
+    finally:
+        asyncio.run(bot.stop())
diff --git a/src/config.py b/src/config.py
index 84339128797eabd28c4613cbc7c01bac6815e7f6..8f2d8f2532ba23192768525bc711b314cdabbc37 100644
--- a/src/config.py
+++ b/src/config.py
@@ -1,168 +1,217 @@
-"""
-Configuration management for trading bot
-Loads settings from environment variables with validation
-"""
+
+"""Configuration management for trading bot
+Loads settings from environment variables with validation"""
 
 import os
 from typing import Optional
 from dataclasses import dataclass
 from dotenv import load_dotenv
 
 # Load environment variables from .env file
 load_dotenv()
 
 
+def _normalize_percentage(value: float) -> float:
+    """Convert fractional percentages (0-1) to 0-100 scale."""
+    if value <= 1:
+        return value * 100
+    return value
+
+
+def _get_float(name: str, default: str) -> float:
+    """Safely parse a float environment variable."""
+    raw = os.getenv(name, default)
+    try:
+        return float(raw)
+    except (TypeError, ValueError) as exc:  # pragma: no cover - defensive guard
+        raise ValueError(f"Invalid numeric value for {name}: {raw}") from exc
+
+
+def _get_bool(name: str, default: str = 'false') -> bool:
+    """Parse a boolean flag from environment variables."""
+    value = os.getenv(name, default)
+    if value is None:
+        return False
+    return value.strip().lower() in {"1", "true", "yes", "on"}
+
+
 @dataclass
 class TradingConfig:
     """Trading parameters"""
+
     max_slippage: float
     default_buy_amount_sol: float
-    min_profit_percentage: float
     max_trade_size_sol: float
     daily_loss_limit_sol: float
     require_confirmation: bool
     min_liquidity_usd: float
     check_mint_authority: bool
     check_freeze_authority: bool
+    honeypot_check_enabled: bool
+    stop_loss_percentage: float
+    take_profit_percentage: float
+    trailing_stop_percentage: float
 
 
 @dataclass
 class Config:
     """Main configuration class"""
-    
+
     # Telegram
     telegram_bot_token: str
     admin_chat_id: Optional[int]
-    
+
     # Solana
     solana_rpc_url: str
     wallet_private_key: str
     solana_network: str
-    
+
     # Trading
     trading: TradingConfig
-    
+
     # Social Media APIs
     twitter_api_key: Optional[str]
     twitter_api_secret: Optional[str]
+    twitter_bearer_token: Optional[str]
+    twitter_client_id: Optional[str]
+    twitter_client_secret: Optional[str]
     reddit_client_id: Optional[str]
     reddit_client_secret: Optional[str]
+    reddit_user_agent: Optional[str]
     discord_token: Optional[str]
-    
+
     # Database
     database_url: str
-    
+
     # Monitoring
     enable_health_check_server: bool
     health_check_port: int
-    
+
     # Logging
     log_level: str
     log_file: str
-    
+
     @classmethod
     def from_env(cls) -> 'Config':
         """Load configuration from environment variables"""
-        
+
         # Telegram
         telegram_bot_token = os.getenv('TELEGRAM_BOT_TOKEN', '')
         if not telegram_bot_token:
             raise ValueError("TELEGRAM_BOT_TOKEN is required")
-        
+
         admin_chat_id_str = os.getenv('ADMIN_CHAT_ID')
         admin_chat_id = int(admin_chat_id_str) if admin_chat_id_str else None
-        
+
         # Solana
         solana_rpc_url = os.getenv('SOLANA_RPC_URL', 'https://api.mainnet-beta.solana.com')
         wallet_private_key = os.getenv('WALLET_PRIVATE_KEY', '')
         solana_network = os.getenv('SOLANA_NETWORK', 'mainnet-beta')
-        
+
         # Trading
         trading = TradingConfig(
-            max_slippage=float(os.getenv('MAX_SLIPPAGE', '5.0')),
-            default_buy_amount_sol=float(os.getenv('DEFAULT_BUY_AMOUNT_SOL', '0.1')),
-            min_profit_percentage=float(os.getenv('MIN_PROFIT_PERCENTAGE', '2.0')),
-            max_trade_size_sol=float(os.getenv('MAX_TRADE_SIZE_SOL', '1.0')),
-            daily_loss_limit_sol=float(os.getenv('DAILY_LOSS_LIMIT_SOL', '5.0')),
-            require_confirmation=os.getenv('REQUIRE_CONFIRMATION', 'true').lower() == 'true',
-            min_liquidity_usd=float(os.getenv('MIN_LIQUIDITY_USD', '10000')),
-            check_mint_authority=os.getenv('CHECK_MINT_AUTHORITY', 'true').lower() == 'true',
-            check_freeze_authority=os.getenv('CHECK_FREEZE_AUTHORITY', 'true').lower() == 'true',
+            max_slippage=_normalize_percentage(_get_float('MAX_SLIPPAGE', '5.0')),
+            default_buy_amount_sol=_get_float('DEFAULT_BUY_AMOUNT', os.getenv('DEFAULT_BUY_AMOUNT_SOL', '0.1') or '0.1'),
+            max_trade_size_sol=_get_float('MAX_POSITION_SIZE_SOL', os.getenv('MAX_TRADE_SIZE_SOL', '1.0') or '1.0'),
+            daily_loss_limit_sol=_get_float('MAX_DAILY_LOSS_SOL', os.getenv('DAILY_LOSS_LIMIT_SOL', '5.0') or '5.0'),
+            require_confirmation=_get_bool('REQUIRE_CONFIRMATION', 'true'),
+            min_liquidity_usd=_get_float('MIN_LIQUIDITY_USD', '10000'),
+            check_mint_authority=_get_bool('CHECK_MINT_AUTHORITY', 'true'),
+            check_freeze_authority=_get_bool('CHECK_FREEZE_AUTHORITY', 'true'),
+            honeypot_check_enabled=_get_bool(
+                'HONEYPOT_CHECK_ENABLED',
+                os.getenv('HONEYPOT_DETECTION_ENABLED', 'true') or 'true'
+            ),
+            stop_loss_percentage=_normalize_percentage(_get_float('STOP_LOSS_PERCENTAGE', '10.0')),
+            take_profit_percentage=_normalize_percentage(_get_float('TAKE_PROFIT_PERCENTAGE', '20.0')),
+            trailing_stop_percentage=_normalize_percentage(_get_float('TRAILING_STOP_PERCENTAGE', '0.0')),
         )
-        
+
         # Social Media (optional)
         twitter_api_key = os.getenv('TWITTER_API_KEY')
         twitter_api_secret = os.getenv('TWITTER_API_SECRET')
+        twitter_bearer_token = os.getenv('TWITTER_BEARER_TOKEN')
+        twitter_client_id = os.getenv('TWITTER_CLIENT_ID')
+        twitter_client_secret = os.getenv('TWITTER_CLIENT_SECRET')
         reddit_client_id = os.getenv('REDDIT_CLIENT_ID')
         reddit_client_secret = os.getenv('REDDIT_CLIENT_SECRET')
+        reddit_user_agent = os.getenv('REDDIT_USER_AGENT')
         discord_token = os.getenv('DISCORD_TOKEN')
-        
+
         # Database
         database_url = os.getenv('DATABASE_URL', 'sqlite+aiosqlite:///trading_bot.db')
-        
+
         # Monitoring
-        enable_health_check_server = os.getenv('ENABLE_HEALTH_CHECK_SERVER', 'true').lower() == 'true'
+        enable_health_check_server = _get_bool('ENABLE_HEALTH_CHECK_SERVER', 'true')
         health_check_port = int(os.getenv('HEALTH_CHECK_PORT', '8080'))
-        
+
         # Logging
         log_level = os.getenv('LOG_LEVEL', 'INFO')
         log_file = os.getenv('LOG_FILE', 'logs/trading_bot.log')
-        
+
         return cls(
             telegram_bot_token=telegram_bot_token,
             admin_chat_id=admin_chat_id,
             solana_rpc_url=solana_rpc_url,
             wallet_private_key=wallet_private_key,
             solana_network=solana_network,
             trading=trading,
             twitter_api_key=twitter_api_key,
             twitter_api_secret=twitter_api_secret,
+            twitter_bearer_token=twitter_bearer_token,
+            twitter_client_id=twitter_client_id,
+            twitter_client_secret=twitter_client_secret,
             reddit_client_id=reddit_client_id,
             reddit_client_secret=reddit_client_secret,
+            reddit_user_agent=reddit_user_agent,
             discord_token=discord_token,
             database_url=database_url,
             enable_health_check_server=enable_health_check_server,
             health_check_port=health_check_port,
             log_level=log_level,
             log_file=log_file
         )
-    
+
     def validate(self):
         """Validate configuration"""
         errors = []
-        
+
         if not self.telegram_bot_token:
             errors.append("TELEGRAM_BOT_TOKEN is required")
-        
+
         if self.solana_network not in ['devnet', 'testnet', 'mainnet-beta']:
             errors.append(f"Invalid SOLANA_NETWORK: {self.solana_network}")
-        
+
         if self.trading.max_slippage < 0 or self.trading.max_slippage > 50:
-            errors.append("MAX_SLIPPAGE must be between 0 and 50")
-        
+            errors.append("MAX_SLIPPAGE must be between 0 and 50 percent")
+
         if self.trading.max_trade_size_sol <= 0:
-            errors.append("MAX_TRADE_SIZE_SOL must be positive")
-        
+            errors.append("MAX_POSITION_SIZE_SOL must be positive")
+
+        if self.trading.daily_loss_limit_sol <= 0:
+            errors.append("MAX_DAILY_LOSS_SOL must be positive")
+
         if errors:
-            raise ValueError(f"Configuration errors:\n" + "\n".join(f"- {e}" for e in errors))
+            raise ValueError(
+                "Configuration errors:\n" + "\n".join(f"- {e}" for e in errors)
+            )
 
 
 # Global config instance
 _config: Optional[Config] = None
 
 
 def get_config() -> Config:
     """Get global configuration instance"""
     global _config
     if _config is None:
         _config = Config.from_env()
         _config.validate()
     return _config
 
 
 def reload_config():
     """Reload configuration from environment"""
     global _config
     _config = None
     return get_config()
-
diff --git a/src/modules/ai_strategy_engine.py b/src/modules/ai_strategy_engine.py
index 27901d21b5603bb487da607f16a3a8c15ded06a5..7fd4761be5464829e8678f8cbda16b79d6f9a4db 100644
--- a/src/modules/ai_strategy_engine.py
+++ b/src/modules/ai_strategy_engine.py
@@ -21,51 +21,53 @@ import logging
 
 logger = logging.getLogger(__name__)
 
 
 class MLPredictionEngine:
     """
     Machine Learning prediction engine for token performance
     Learns from historical data to predict winners
     """
     
     def __init__(self):
         self.model = None
         self.scaler = StandardScaler()
         self.feature_columns = [
             'liquidity_usd',
             'volume_24h',
             'price_change_1h',
             'price_change_24h',
             'holder_count',
             'top_10_holder_percentage',
             'transaction_count_1h',
             'buy_sell_ratio',
             'market_cap',
             'age_hours',
             'social_mentions',
-            'sentiment_score'
+            'sentiment_score',
+            'social_score',
+            'community_score'
         ]
         self.trained = False
         self.accuracy = 0.0
         
         # Try to load pre-trained model
         self._load_pretrained_model()
     
     def _load_pretrained_model(self):
         """Load pre-trained model if available"""
         try:
             import os
             model_path = "data/models/ml_prediction_model.pkl"
             scaler_path = "data/models/feature_scaler.pkl"
             
             if os.path.exists(model_path) and os.path.exists(scaler_path):
                 self.model = joblib.load(model_path)
                 self.scaler = joblib.load(scaler_path)
                 self.trained = True
                 
                 # Try to load accuracy from metadata
                 metadata_path = "data/models/model_metadata.json"
                 if os.path.exists(metadata_path):
                     import json
                     with open(metadata_path, 'r') as f:
                         metadata = json.load(f)
@@ -117,51 +119,53 @@ class MLPredictionEngine:
         
         self.model.fit(X_scaled, y)
         
         # Calculate accuracy
         self.accuracy = self.model.score(X_scaled, y)
         self.trained = True
         
         logger.info(f"ML model trained! Accuracy: {self.accuracy:.2%}")
         return True
     
     def _extract_features(self, token_data: Dict) -> Optional[List[float]]:
         """Extract features from token data"""
         try:
             return [
                 float(token_data.get('liquidity_usd', 0)),
                 float(token_data.get('volume_24h', 0)),
                 float(token_data.get('price_change_1h', 0)),
                 float(token_data.get('price_change_24h', 0)),
                 float(token_data.get('holder_count', 0)),
                 float(token_data.get('top_10_holder_percentage', 0)),
                 float(token_data.get('transaction_count_1h', 0)),
                 float(token_data.get('buy_sell_ratio', 1.0)),
                 float(token_data.get('market_cap', 0)),
                 float(token_data.get('age_hours', 0)),
                 float(token_data.get('social_mentions', 0)),
-                float(token_data.get('sentiment_score', 0))
+                float(token_data.get('sentiment_score', 0)),
+                float(token_data.get('social_score', 0)),
+                float(token_data.get('community_score', 0))
             ]
         except Exception as e:
             logger.error(f"Feature extraction error: {e}")
             return None
     
     async def predict_token_success(
         self,
         token_data: Dict
     ) -> Dict[str, float]:
         """
         Predict if a token will be profitable
         
         Returns:
             Dict with probability and confidence
         """
         if not self.trained:
             return {
                 'probability': 0.5,
                 'confidence': 0.0,
                 'recommendation': 'neutral',
                 'reason': 'Model not trained yet',
                 'key_factors': []
             }
         
         features = self._extract_features(token_data)
@@ -557,137 +561,277 @@ class SmartPositionSizer:
         
         logger.info(
             f"Kelly fraction: {kelly_fraction:.1%}, "
             f"Confidence: {confidence:.1%}, "
             f"Position size: {position_size:.4f} SOL"
         )
         
         return position_size
 
 
 # Main AI Strategy Manager
 class AIStrategyManager:
     """
     Orchestrates all AI components for intelligent trading
     """
     
     def __init__(self):
         self.ml_engine = MLPredictionEngine()
         self.strategy_optimizer = AdaptiveStrategyOptimizer()
         self.pattern_engine = PatternRecognitionEngine()
         self.position_sizer = SmartPositionSizer()
     
     async def analyze_opportunity(
         self,
         token_data: Dict,
-        portfolio_value: float
+        portfolio_value: float,
+        sentiment_snapshot: Optional[Dict] = None,
+        community_signal: Optional[Dict] = None
     ) -> Dict:
         """
         Comprehensive AI analysis of trading opportunity
-        
+
         Returns complete recommendation with reasoning
         """
+        enriched_token_data = dict(token_data)
+
+        if sentiment_snapshot:
+            enriched_token_data['sentiment_score'] = sentiment_snapshot.get(
+                'sentiment_score',
+                enriched_token_data.get('sentiment_score', 50)
+            )
+            enriched_token_data['social_mentions'] = sentiment_snapshot.get(
+                'total_mentions',
+                enriched_token_data.get('social_mentions', 0)
+            )
+            enriched_token_data['social_score'] = sentiment_snapshot.get(
+                'social_score',
+                enriched_token_data.get('social_score', 0)
+            )
+
+        if community_signal:
+            enriched_token_data['community_score'] = community_signal.get(
+                'community_score',
+                enriched_token_data.get('community_score', 0)
+            )
+
+        enriched_token_data.setdefault('social_score', enriched_token_data.get('sentiment_score', 0))
+        enriched_token_data.setdefault('community_score', 0.0)
+
         # ML prediction
-        ml_prediction = await self.ml_engine.predict_token_success(token_data)
-        
+        ml_prediction = await self.ml_engine.predict_token_success(enriched_token_data)
+
         # Pattern recognition
-        pattern = await self.pattern_engine.identify_pattern(token_data)
+        pattern = await self.pattern_engine.identify_pattern(enriched_token_data)
         pattern_rec = await self.pattern_engine.get_pattern_recommendation(
             pattern
         ) if pattern else {}
-        
+
         # Market regime
         market_regime = await self.strategy_optimizer.detect_market_regime(
-            token_data.get('market_data', {})
+            enriched_token_data.get('market_data', {})
         )
-        
+
         # Recommended strategy
         strategy = await self.strategy_optimizer.get_recommended_strategy()
-        
+
+        social_context = self._score_social_sentiment(
+            sentiment_snapshot,
+            community_signal
+        )
+
         # Position sizing
         position_size = self.position_sizer.calculate_position_size(
             portfolio_value,
             ml_prediction['confidence']
         )
-        
+
         # Combine all signals
         final_recommendation = self._combine_signals(
             ml_prediction,
             pattern_rec,
             market_regime,
-            strategy
+            strategy,
+            social_context
         )
-        
+
         return {
             'action': final_recommendation['action'],
             'confidence': final_recommendation['confidence'],
             'position_size': position_size,
             'reasoning': final_recommendation['reasoning'],
             'ml_prediction': ml_prediction,
             'pattern': pattern,
             'market_regime': market_regime,
             'strategy': strategy,
-            'risk_level': final_recommendation['risk_level']
+            'risk_level': final_recommendation['risk_level'],
+            'social_context': social_context,
+            'enriched_token_data': enriched_token_data
         }
-    
+
+    def _score_social_sentiment(
+        self,
+        sentiment_snapshot: Optional[Dict],
+        community_signal: Optional[Dict]
+    ) -> Optional[Dict]:
+        """Derive a normalized social/community score and qualitative insights."""
+
+        if not sentiment_snapshot and not community_signal:
+            return None
+
+        scores = []
+        insights: List[str] = []
+        breakdown: Dict[str, float] = {}
+
+        if sentiment_snapshot:
+            social_score = float(sentiment_snapshot.get('social_score', 0))
+            sentiment_score = float(sentiment_snapshot.get('sentiment_score', 0))
+            total_mentions = sentiment_snapshot.get('total_mentions')
+
+            if social_score:
+                scores.append(social_score / 100)
+                breakdown['social_score'] = social_score
+            if sentiment_score:
+                breakdown['sentiment_score'] = sentiment_score
+
+            if total_mentions is None:
+                total_mentions = 0
+                twitter_mentions = sentiment_snapshot.get('twitter', {}).get('mentions')
+                reddit_posts = sentiment_snapshot.get('reddit', {}).get('posts')
+                reddit_comments = sentiment_snapshot.get('reddit', {}).get('comments')
+                discord_mentions = sentiment_snapshot.get('discord', {}).get('mentions')
+                for value in (twitter_mentions, reddit_posts, reddit_comments, discord_mentions):
+                    if value:
+                        total_mentions += value
+
+            if total_mentions:
+                insights.append(
+                    f"{int(total_mentions)} recent social mentions across monitored feeds"
+                )
+
+            if sentiment_snapshot.get('overall_recommendation'):
+                insights.append(
+                    f"Aggregator bias: {sentiment_snapshot['overall_recommendation'].replace('_', ' ')}"
+                )
+
+            viral_potential = sentiment_snapshot.get('viral_potential')
+            if viral_potential:
+                insights.append(
+                    f"Viral potential {viral_potential * 100:.0f}%"
+                )
+
+            if sentiment_snapshot.get('twitter', {}).get('trending'):
+                insights.append("Token is trending on Twitter")
+
+        if community_signal:
+            community_score = float(community_signal.get('community_score', 0))
+            if community_score:
+                scores.append(community_score / 100)
+                breakdown['community_score'] = community_score
+
+            avg_rating = community_signal.get('avg_rating')
+            total_ratings = community_signal.get('total_ratings')
+            if avg_rating is not None and total_ratings is not None:
+                insights.append(
+                    f"Community rating {avg_rating:.1f}/5 from {total_ratings} ratings"
+                )
+
+            flag_count = community_signal.get('flag_count')
+            if flag_count:
+                insights.append(f"{flag_count} community risk flag(s) raised")
+
+            sentiment_label = community_signal.get('sentiment')
+            if sentiment_label:
+                breakdown['community_sentiment'] = sentiment_label
+
+        if not scores:
+            return None
+
+        normalized = sum(scores) / len(scores)
+        normalized = max(0.0, min(normalized, 1.0))
+
+        if normalized >= 0.75:
+            label = 'strongly_bullish'
+        elif normalized >= 0.6:
+            label = 'bullish'
+        elif normalized >= 0.45:
+            label = 'neutral'
+        elif normalized >= 0.3:
+            label = 'cautious'
+        else:
+            label = 'bearish'
+
+        return {
+            'score': normalized,
+            'label': label,
+            'insights': insights,
+            'breakdown': breakdown
+        }
+
     def _combine_signals(
         self,
         ml_pred: Dict,
         pattern_rec: Dict,
         market_regime: str,
-        strategy: str
+        strategy: str,
+        social_context: Optional[Dict] = None
     ) -> Dict:
         """Combine all signals into final recommendation"""
-        
+
         # Score calculation
         ml_score = ml_pred['probability']
         pattern_score = pattern_rec.get('confidence', 0.5)
-        
+        social_score = social_context['score'] if social_context else 0.5
+
         # Weight the scores
-        combined_score = (ml_score * 0.6) + (pattern_score * 0.4)
-        
+        combined_score = (ml_score * 0.5) + (pattern_score * 0.2) + (social_score * 0.3)
+
         # Determine action
         if combined_score > 0.7:
             action = 'strong_buy'
             risk = 'medium'
         elif combined_score > 0.6:
             action = 'buy'
             risk = 'medium'
         elif combined_score > 0.4:
             action = 'hold'
             risk = 'low'
         else:
             action = 'avoid'
             risk = 'high'
         
         # Build reasoning
         reasoning = []
         reasoning.append(f"ML Model: {ml_pred['recommendation']} ({ml_pred['probability']:.1%} probability)")
         if pattern_rec:
             reasoning.append(f"Pattern: {pattern_rec.get('action', 'unknown')}")
         reasoning.append(f"Market: {market_regime} regime")
         reasoning.append(f"Strategy: {strategy}")
-        
+        if social_context:
+            reasoning.append(
+                f"Social/Community: {social_context['label']} ({social_context['score'] * 100:.0f}/100)"
+            )
+
         return {
             'action': action,
             'confidence': combined_score,
             'reasoning': ' | '.join(reasoning),
             'risk_level': risk
         }
     
     async def learn_from_outcome(self, trade_result: Dict):
         """Learn from trade outcome across all systems"""
         await self.ml_engine.learn_from_trade(trade_result)
         
         strategy = trade_result.get('strategy', 'momentum')
         await self.strategy_optimizer.record_strategy_performance(
             strategy,
             trade_result.get('pnl', 0)
         )
         
         pattern = trade_result.get('pattern')
         if pattern:
             await self.pattern_engine.update_pattern_success(pattern, trade_result)
         
         self.position_sizer.update_statistics([trade_result])
         
         logger.info("AI systems updated with trade outcome")
diff --git a/src/modules/automated_trading.py b/src/modules/automated_trading.py
index 4ff9f2a42bc4c7450488c2ac2c16ff387a46e74b..80ff27aef2a025ce662c7efa543f3d8cd72900e6 100644
--- a/src/modules/automated_trading.py
+++ b/src/modules/automated_trading.py
@@ -1,106 +1,134 @@
 """
 ğŸ¤– AUTOMATED TRADING ENGINE
 24/7 Autonomous Trading with Professional Risk Management
 
 FEATURES:
 - Set-and-forget operation
 - Follows top wallet activities
 - AI confidence scoring
 - Dynamic position sizing
 - Automatic stop losses
 - Take profit automation
 - Trailing stops
 - Daily loss limits
 """
 
 import asyncio
 import logging
 from datetime import datetime, timedelta
-from typing import Dict, List, Optional
+from types import SimpleNamespace
+from typing import Dict, List, Optional, Tuple, Set
+
+from solders.pubkey import Pubkey
 from dataclasses import dataclass
 
 logger = logging.getLogger(__name__)
 
 
 @dataclass
 class TradingConfig:
     """Automated trading configuration"""
     # Trading limits
     max_position_size_sol: float = 10.0
     default_buy_amount: float = 0.1
     max_slippage: float = 0.05  # 5%
     
     # Automated trading
     auto_trade_enabled: bool = False
     auto_trade_min_confidence: float = 0.75  # 75% confidence required
     auto_trade_max_daily_trades: int = 50
     auto_trade_daily_limit_sol: float = 100.0
     
     # Risk management
     stop_loss_percentage: float = 0.15  # 15%
     take_profit_percentage: float = 0.50  # 50%
     trailing_stop_percentage: float = 0.10  # 10%
     max_daily_loss_sol: float = 50.0
 
 
 class AutomatedTradingEngine:
     """
     ğŸ¤– FULLY AUTOMATED TRADING WITH RISK MANAGEMENT
     
     Features:
     - 24/7 autonomous trading
     - Follows top wallets automatically
     - AI-driven decision making
     - Professional risk management
     - Auto stop losses and take profits
     """
     
-    def __init__(self, config: TradingConfig, wallet_intelligence, jupiter_client, protection_system):
+    def __init__(
+        self,
+        config: TradingConfig,
+        wallet_intelligence,
+        jupiter_client,
+        protection_system,
+        trade_executor=None,
+        monitor=None,
+    ):
         self.config = config
         self.wallet_intelligence = wallet_intelligence
         self.jupiter = jupiter_client
         self.protection = protection_system
-        
+        self.trade_executor = trade_executor
+        self.monitor = monitor
+
         self.active_positions: Dict[str, Dict] = {}
         self.daily_stats = {
             'trades': 0,
             'profit_loss': 0.0,
             'last_reset': datetime.now().date()
         }
         self.is_running = False
-        
+
+        # Cache the last processed signature per wallet so we do not
+        # re-process historical activity every scan.
+        self._wallet_last_signature: Dict[str, str] = {}
+
+        # Cache decoded transactions to avoid hammering the RPC endpoint.
+        self._transaction_cache: Dict[str, Dict[str, object]] = {}
+        self._transaction_cache_ttl = timedelta(minutes=10)
+
+        # User risk configuration cache (refreshes periodically)
+        self._user_settings: Optional[SimpleNamespace] = None
+        self._settings_loaded_at: Optional[datetime] = None
+
         logger.info("ğŸ¤– Automated Trading Engine initialized")
-    
+
     async def start_automated_trading(self, user_id: int, user_keypair, wallet_manager, db_manager=None):
         """Start automated trading for user"""
         self.is_running = True
         self.user_id = user_id
         self.user_keypair = user_keypair
         self.wallet_manager = wallet_manager
         self.db = db_manager
-        
+
+        if self.db:
+            await self._get_user_settings(force_refresh=True)
+
         logger.info(f"ğŸ¤– Automated trading STARTED for user {user_id}")
         
         # Load tracked wallets from database
         if self.db:
             await self._load_tracked_wallets_from_db()
         
         # Start trading loop in background
         asyncio.create_task(self._automated_trading_loop())
     
     async def _load_tracked_wallets_from_db(self):
         """Load tracked wallets from database into wallet intelligence"""
         try:
             tracked_wallets = await self.db.get_tracked_wallets(self.user_id)
             
             logger.info(f"ğŸ“Š Loading {len(tracked_wallets)} tracked wallets from database...")
             
             for wallet in tracked_wallets:
                 # Add to wallet intelligence system
                 await self.wallet_intelligence.track_wallet(
                     wallet.wallet_address,
                     analyze=False  # Skip analysis for now, use saved metrics
                 )
                 
                 # Update metrics from database
                 metrics = self.wallet_intelligence.tracked_wallets.get(wallet.wallet_address)
@@ -108,517 +136,738 @@ class AutomatedTradingEngine:
                     metrics.total_trades = wallet.total_trades
                     metrics.profitable_trades = wallet.profitable_trades
                     metrics.win_rate = wallet.win_rate
                     metrics.total_pnl = wallet.total_pnl
                 
                 logger.info(f"   âœ“ Loaded: {wallet.label or wallet.wallet_address[:8]}... (Score: {wallet.score:.0f})")
             
             # Wallets loaded and ready for scanning
             logger.info(f"âœ… Loaded {len(tracked_wallets)} wallets for automated trading")
             
         except Exception as e:
             logger.error(f"Error loading tracked wallets: {e}")
     
     async def stop_automated_trading(self):
         """Stop automated trading"""
         self.is_running = False
         logger.info("ğŸ›‘ Automated trading STOPPED")
     
     async def _automated_trading_loop(self):
         """Main automated trading loop"""
         logger.info("ğŸ”„ Automated trading loop started")
         
         while self.is_running:
             try:
                 logger.debug(f"ğŸ’« Trading loop iteration - is_running={self.is_running}")
+                settings = await self._get_user_settings()
+
                 # Reset daily stats if needed
                 if datetime.now().date() != self.daily_stats['last_reset']:
                     self.daily_stats = {
                         'trades': 0,
                         'profit_loss': 0.0,
                         'last_reset': datetime.now().date()
                     }
                     logger.info("ğŸ“Š Daily stats reset")
                 
                 # Check daily limits
                 if self.daily_stats['trades'] >= self.config.auto_trade_max_daily_trades:
                     logger.info("Daily trade limit reached, waiting...")
                     await asyncio.sleep(60)
                     continue
                 
-                if abs(self.daily_stats['profit_loss']) >= self.config.max_daily_loss_sol:
+                if self.db:
+                    daily_pnl = await self.db.get_daily_pnl(self.user_id)
+                    self.daily_stats['profit_loss'] = daily_pnl
+
+                    if settings.daily_loss_limit_sol > 0 and daily_pnl <= -settings.daily_loss_limit_sol:
+                        logger.warning(
+                            "Daily loss limit reached (%.4f <= -%.4f SOL) - pausing trading",
+                            daily_pnl,
+                            settings.daily_loss_limit_sol,
+                        )
+                        await asyncio.sleep(300)
+                        continue
+                elif (
+                    settings.daily_loss_limit_sol > 0
+                    and abs(self.daily_stats['profit_loss']) >= settings.daily_loss_limit_sol
+                ):
                     logger.warning("Daily loss limit reached - pausing trading")
                     await asyncio.sleep(300)
                     continue
                 
                 # Find trading opportunities
                 opportunities = await self._scan_for_opportunities()
                 
                 # Execute high-confidence opportunities
                 for opp in opportunities:
                     if opp['confidence'] >= self.config.auto_trade_min_confidence:
-                        await self._execute_automated_trade(opp)
-                
+                        await self._execute_automated_trade(opp, settings)
+
                 # Manage existing positions
-                await self._manage_positions()
+                await self._manage_positions(settings)
                 
                 # Wait before next scan (30 seconds to avoid rate limits)
                 await asyncio.sleep(30)
                 
             except Exception as e:
                 logger.error(f"Error in automated trading loop: {e}")
                 await asyncio.sleep(30)
     
     async def _scan_for_opportunities(self) -> List[Dict]:
         """
         ğŸ” SCAN FOR TRADING OPPORTUNITIES
         
         Uses:
         - Top wallet following
         - Technical signals
         - AI predictions
         - Pattern recognition
         """
         
         opportunities = []
         token_signals = {}  # Track how many wallets are buying each token
         
         try:
             # Get all tracked wallets (not just top 5 - check all 558!)
             all_tracked_wallets = list(self.wallet_intelligence.tracked_wallets.items())
-            
+
             if not all_tracked_wallets:
                 logger.debug("No tracked wallets to monitor")
                 return opportunities
-            
-            logger.info(f"ğŸ” Scanning {len(all_tracked_wallets)} tracked wallets for opportunities...")
-            
-            # Check recent transactions for each wallet
-            from solders.pubkey import Pubkey
-            
-            for address, metrics in all_tracked_wallets[:5]:  # Check only 5 wallets to avoid rate limits
-                try:
-                    pubkey = Pubkey.from_string(address)
-                    
-                    # Get recent signatures (last 2 transactions only)
-                    signatures = await self.wallet_intelligence.client.get_signatures_for_address(
-                        pubkey,
-                        limit=2
-                    )
-                    
-                    if not signatures or not signatures.value:
+
+            wallet_count = len(all_tracked_wallets)
+            logger.info(f"ğŸ” Scanning {wallet_count} tracked wallets for opportunities...")
+
+            scan_started = datetime.now()
+            rpc_requests = 0
+            wallets_with_activity: Set[str] = set()
+
+            batch_size = 20
+
+            for batch_start in range(0, wallet_count, batch_size):
+                batch = all_tracked_wallets[batch_start: batch_start + batch_size]
+
+                signature_tasks = [
+                    self._fetch_recent_signatures(address)
+                    for address, _ in batch
+                ]
+
+                batch_results = await asyncio.gather(*signature_tasks, return_exceptions=True)
+
+                for (address, metrics), result in zip(batch, batch_results):
+                    if isinstance(result, Exception):
+                        logger.debug(f"Error retrieving signatures for {address[:8]}: {result}")
                         continue
-                    
-                    # Add small delay to avoid rate limits
-                    await asyncio.sleep(0.1)
-                    
-                    # Check each recent transaction
-                    for sig_info in signatures.value:
-                        # Only check very recent transactions (last 5 minutes)
+
+                    rpc_requests += result['rpc_calls']
+                    signatures = result['signatures']
+
+                    if not signatures:
+                        continue
+
+                    newest_signature: Optional[str] = None
+                    last_processed = self._wallet_last_signature.get(address)
+
+                    for sig_info in signatures:
+                        sig_value = getattr(sig_info, 'signature', None)
+                        sig_str = str(sig_value) if sig_value else None
+
+                        if not sig_str:
+                            continue
+
+                        if newest_signature is None:
+                            newest_signature = sig_str
+
+                        if sig_str == last_processed:
+                            break
+
                         if hasattr(sig_info, 'block_time') and sig_info.block_time:
                             tx_time = datetime.fromtimestamp(sig_info.block_time)
-                            time_diff = (datetime.now() - tx_time).total_seconds()
-                            
-                            if time_diff > 300:  # Skip if older than 5 minutes
+                            if (datetime.now() - tx_time).total_seconds() > 300:
                                 continue
-                            
-                            # Parse the transaction to find token swaps
-                            # Add delay before parsing to avoid rate limits
-                            await asyncio.sleep(0.2)
-                            token_mint = await self._parse_swap_transaction(sig_info.signature)
-                            
-                            if token_mint:
-                                # Track this signal
-                                if token_mint not in token_signals:
-                                    token_signals[token_mint] = {
-                                        'count': 0,
-                                        'wallets': [],
-                                        'scores': [],
-                                        'first_seen': datetime.now()
-                                    }
-                                
-                                token_signals[token_mint]['count'] += 1
-                                token_signals[token_mint]['wallets'].append(address)
-                                token_signals[token_mint]['scores'].append(metrics.calculate_score())
-                                
-                                logger.info(f"ğŸ¯ Detected buy from {address[:8]}... (score: {metrics.calculate_score():.0f}) - Token: {token_mint[:8]}...")
-                
-                except Exception as e:
-                    logger.debug(f"Error checking wallet {address[:8]}: {e}")
-                    continue
-            
+
+                        token_mint, tx_rpc_calls = await self._parse_swap_transaction(sig_str)
+                        rpc_requests += tx_rpc_calls
+
+                        if token_mint:
+                            wallets_with_activity.add(address)
+
+                            if token_mint not in token_signals:
+                                token_signals[token_mint] = {
+                                    'count': 0,
+                                    'wallets': [],
+                                    'scores': [],
+                                    'first_seen': datetime.now()
+                                }
+
+                            token_signals[token_mint]['count'] += 1
+                            token_signals[token_mint]['wallets'].append(address)
+                            token_signals[token_mint]['scores'].append(metrics.calculate_score())
+
+                            logger.info(
+                                f"ğŸ¯ Detected buy from {address[:8]}... (score: {metrics.calculate_score():.0f}) - Token: {token_mint[:8]}..."
+                            )
+
+                    if newest_signature:
+                        self._wallet_last_signature[address] = newest_signature
+
+                # Brief pause between batches to remain within rate limits
+                await asyncio.sleep(0.05)
+
             # Generate opportunities from strong signals
             for token_mint, signal in token_signals.items():
                 # Calculate confidence based on:
                 # 1. Number of wallets buying
                 # 2. Quality of wallets (scores)
                 # 3. Recency
                 
                 wallet_count = signal['count']
                 avg_wallet_score = sum(signal['scores']) / len(signal['scores']) if signal['scores'] else 0
                 
                 # Confidence formula
                 confidence = 0.5  # Base confidence
                 
                 # Add confidence for multiple wallet signals
                 confidence += min(wallet_count * 0.1, 0.3)  # Up to +30% for 3+ wallets
                 
                 # Add confidence for high-quality wallets
                 if avg_wallet_score > 75:
                     confidence += 0.2
                 elif avg_wallet_score > 60:
                     confidence += 0.1
                 
                 # Only create opportunity if confidence meets minimum
                 if confidence >= self.config.auto_trade_min_confidence:
                     opportunities.append({
                         'token_mint': token_mint,
                         'action': 'buy',
                         'amount': self.config.default_buy_amount,
                         'confidence': confidence,
                         'signal_count': wallet_count,
                         'wallet_scores': signal['scores'],
                         'reason': f"{wallet_count} top wallets buying (avg score: {avg_wallet_score:.0f})"
                     })
                     
                     logger.info(f"âœ¨ OPPORTUNITY FOUND: {token_mint[:8]}... - Confidence: {confidence:.1%} ({wallet_count} wallets)")
-            
+
             if opportunities:
                 logger.info(f"ğŸ¯ Found {len(opportunities)} high-confidence opportunities!")
             else:
                 logger.debug(f"No opportunities found (checked {len(all_tracked_wallets)} wallets)")
-            
+
+            scan_duration = (datetime.now() - scan_started).total_seconds()
+            if self.monitor:
+                self.monitor.record_metric(
+                    'automated_trader.scan_duration_seconds',
+                    scan_duration,
+                    tags={'wallets_total': wallet_count}
+                )
+                self.monitor.record_metric(
+                    'automated_trader.rpc_requests',
+                    rpc_requests,
+                    tags={'wallets_with_activity': len(wallets_with_activity)}
+                )
+                self.monitor.record_metric(
+                    'automated_trader.opportunities_found',
+                    len(opportunities),
+                )
+
         except Exception as e:
             logger.error(f"Error scanning for opportunities: {e}")
-        
+
         return opportunities
-    
-    async def _parse_swap_transaction(self, signature) -> Optional[str]:
+
+    async def _fetch_recent_signatures(self, address: str, limit: int = 3) -> Dict[str, object]:
+        """Fetch recent signatures for an address with monitoring instrumentation."""
+
+        rpc_calls = 0
+
+        try:
+            pubkey = Pubkey.from_string(address)
+        except Exception as exc:
+            logger.debug(f"Invalid wallet address {address[:8]}: {exc}")
+            return {'signatures': [], 'rpc_calls': rpc_calls}
+
+        try:
+            if self.monitor:
+                self.monitor.record_request()
+
+            signatures = await self.wallet_intelligence.client.get_signatures_for_address(
+                pubkey,
+                limit=limit
+            )
+            rpc_calls += 1
+
+            return {
+                'signatures': signatures.value if signatures and signatures.value else [],
+                'rpc_calls': rpc_calls
+            }
+
+        except Exception as exc:
+            logger.debug(f"Error fetching signatures for {address[:8]}: {exc}")
+            return {'signatures': [], 'rpc_calls': rpc_calls}
+
+    async def _parse_swap_transaction(self, signature: str) -> Tuple[Optional[str], int]:
         """
         Parse a transaction to detect token swaps and extract the token mint
-        
+
         Uses multiple methods (in priority order):
         1. Helius Enhanced API (if available)
         2. Pre/post token balance comparison
         3. Parsed instruction analysis
         4. DEX program detection
         
         Returns:
-            Token mint address if this was a buy transaction, None otherwise
+            Tuple of (token mint address if this was a buy transaction, RPC call count)
         """
+        rpc_calls = 0
+
+        cached = self._transaction_cache.get(signature)
+        if cached:
+            cached_at = cached.get('timestamp')
+            if cached_at and (datetime.now() - cached_at) < self._transaction_cache_ttl:
+                return cached.get('mint'), rpc_calls
+            # Cache expired, remove so we refresh
+            self._transaction_cache.pop(signature, None)
+
         try:
             # METHOD 0: Try Helius Enhanced Transaction API first (if Helius RPC)
-            helius_url = self.config.__dict__.get('helius_rpc_url') if hasattr(self.config, '__dict__') else None
-            
-            # Check if using Helius RPC
             import os
             helius_api_key = os.getenv('HELIUS_API_KEY')
-            
+
             if helius_api_key:
                 try:
                     # Use Helius enhanced transaction endpoint
                     import httpx
                     async with httpx.AsyncClient() as client:
+                        if self.monitor:
+                            self.monitor.record_request()
+                        rpc_calls += 1
                         response = await client.get(
                             f"https://api.helius.xyz/v0/transactions/{signature}",
                             params={'api-key': helius_api_key},
                             timeout=5.0
                         )
                         
                         if response.status_code == 200:
                             helius_data = response.json()
                             
                             # Helius provides parsed swap data
                             if helius_data.get('type') in ['SWAP', 'SWAP_EXACT_IN', 'SWAP_EXACT_OUT']:
                                 # Extract token info from Helius parsed data
                                 token_transfers = helius_data.get('tokenTransfers', [])
                                 
                                 for transfer in token_transfers:
                                     # Look for incoming transfers (tokens received)
                                     if transfer.get('tokenAmount', 0) > 0:
                                         mint = transfer.get('mint')
                                         if mint and mint != "So11111111111111111111111111111111111111112":
                                             logger.info(f"ğŸ¯ [Helius] Detected SWAP: {mint[:8]}... via {helius_data.get('source', 'DEX')}")
-                                            return mint
-                
+                                            self._transaction_cache[signature] = {
+                                                'timestamp': datetime.now(),
+                                                'mint': mint
+                                            }
+                                            return mint, rpc_calls
+
                 except Exception as e:
                     logger.debug(f"Helius enhanced API unavailable, falling back to standard parsing: {e}")
-            
+
             # METHOD 1: Standard RPC with balance comparison
+            if self.monitor:
+                self.monitor.record_request()
             tx = await self.wallet_intelligence.client.get_transaction(
                 signature,
                 encoding="jsonParsed",
                 max_supported_transaction_version=0
             )
-            
+            rpc_calls += 1
+
             if not tx or not tx.value:
-                return None
+                self._transaction_cache[signature] = {
+                    'timestamp': datetime.now(),
+                    'mint': None
+                }
+                return None, rpc_calls
             
             # METHOD 1: Check token balance changes (most reliable)
             # This shows what tokens were received in the transaction
             if hasattr(tx.value, 'meta') and tx.value.meta:
                 meta = tx.value.meta
                 
                 # Check post token balances for new tokens received
                 if hasattr(meta, 'post_token_balances') and hasattr(meta, 'pre_token_balances'):
                     post_balances = meta.post_token_balances
                     pre_balances = meta.pre_token_balances
                     
                     # Build dict of pre-balances for comparison
                     pre_balance_dict = {}
                     if pre_balances:
                         for bal in pre_balances:
                             account = str(bal.account_index)
                             mint = bal.mint
                             amount = float(bal.ui_token_amount.ui_amount) if bal.ui_token_amount else 0
                             pre_balance_dict[f"{account}_{mint}"] = amount
                     
                     # Check post balances for increases (tokens received)
                     if post_balances:
                         for bal in post_balances:
                             account = str(bal.account_index)
                             mint = bal.mint
                             post_amount = float(bal.ui_token_amount.ui_amount) if bal.ui_token_amount else 0
                             
                             # Get pre amount (or 0 if didn't exist)
                             pre_amount = pre_balance_dict.get(f"{account}_{mint}", 0)
                             
                             # If balance increased, this token was received (bought)
                             if post_amount > pre_amount:
                                 # Skip SOL and wrapped SOL
                                 SOL_MINT = "So11111111111111111111111111111111111111112"
                                 WSOL_MINT = "So11111111111111111111111111111111111111112"
                                 
                                 if mint not in [SOL_MINT, WSOL_MINT]:
                                     logger.info(f"ğŸ¯ Detected token BUY: {mint[:8]}... (+{post_amount - pre_amount:.4f} tokens)")
-                                    return mint
+                                    self._transaction_cache[signature] = {
+                                        'timestamp': datetime.now(),
+                                        'mint': mint
+                                    }
+                                    return mint, rpc_calls
             
             # METHOD 2: Parse instructions for token transfers
             instructions = tx.value.transaction.transaction.message.instructions
             
             # Track all token transfers in this transaction
             tokens_received = []
             tokens_sent = []
             
             for instruction in instructions:
                 # Check parsed instructions
                 if hasattr(instruction, 'parsed') and isinstance(instruction.parsed, dict):
                     parsed = instruction.parsed
                     instruction_type = parsed.get('type')
                     
                     # Token transfer or transferChecked
                     if instruction_type in ['transfer', 'transferChecked']:
                         info = parsed.get('info', {})
                         mint = info.get('mint')
                         
                         # Determine direction by checking destination
                         if mint:
                             # This is a simplification - would need to check if destination
                             # belongs to the wallet we're monitoring
                             tokens_received.append(mint)
             
             # METHOD 3: Detect known DEX program calls
             for instruction in instructions:
                 if hasattr(instruction, 'program_id'):
                     program_id = str(instruction.program_id)
                     
                     # Known DEX programs
                     dex_programs = {
                         "JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4": "Jupiter V6",
                         "JUP4Fb2cqiRUcaTHdrPC8h2gNsA2ETXiPDD33WcGuJB": "Jupiter V4",
                         "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8": "Raydium AMM",
                         "whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc": "Orca Whirlpool",
                     }
                     
                     if program_id in dex_programs:
                         dex_name = dex_programs[program_id]
                         logger.debug(f"Detected {dex_name} swap in transaction")
-                        
+
                         # If we detected a DEX swap and found tokens received via Method 1 or 2,
                         # return the first non-SOL token
                         for token in tokens_received:
                             SOL_MINT = "So11111111111111111111111111111111111111112"
                             if token != SOL_MINT:
                                 logger.info(f"ğŸ¯ Detected {dex_name} token buy: {token[:8]}...")
-                                return token
+                                self._transaction_cache[signature] = {
+                                    'timestamp': datetime.now(),
+                                    'mint': token
+                                }
+                                return token, rpc_calls
             
             # If we found any tokens received but no DEX program, might still be a swap
             # Return first non-SOL token found
             for token in tokens_received:
                 SOL_MINT = "So11111111111111111111111111111111111111112"
                 if token != SOL_MINT:
-                    return token
+                    self._transaction_cache[signature] = {
+                        'timestamp': datetime.now(),
+                        'mint': token
+                    }
+                    return token, rpc_calls
             
-            return None
+            self._transaction_cache[signature] = {
+                'timestamp': datetime.now(),
+                'mint': None
+            }
+            return None, rpc_calls
             
         except Exception as e:
             logger.debug(f"Error parsing transaction {str(signature)[:8]}: {e}")
-            return None
+            self._transaction_cache[signature] = {
+                'timestamp': datetime.now(),
+                'mint': None
+            }
+            return None, rpc_calls
     
-    async def _execute_automated_trade(self, opportunity: Dict):
+    async def _execute_automated_trade(self, opportunity: Dict, settings: Optional[SimpleNamespace] = None):
         """Execute an automated trade"""
-        
+
         try:
             token_mint = opportunity.get('token_mint')
             action = opportunity.get('action', 'buy')
             amount = opportunity.get('amount', self.config.default_buy_amount)
             confidence = opportunity.get('confidence', 0.0)
-            
+
+            if settings is None:
+                settings = await self._get_user_settings()
+
             logger.info(f"ğŸ¯ Executing automated trade: {action} {amount} SOL of {token_mint[:8]}... (confidence: {confidence:.1%})")
-            
+
             # Run protection checks
             if action == 'buy':
                 protection_result = await self.protection.comprehensive_token_check(token_mint)
-                
+
                 if not protection_result['is_safe']:
                     logger.warning(f"âš ï¸ Token failed safety checks, skipping trade")
                     return
-            
-            # Execute trade via Jupiter with Jito protection
-            SOL_MINT = "So11111111111111111111111111111111111111112"
-            
+
+            if not self.trade_executor:
+                logger.error("Trade executor is not configured for automated trading")
+                return
+
+            amount = min(amount, settings.max_trade_size_sol)
+            if amount <= 0:
+                logger.debug("Configured max trade size prevents automated trade for user %s", self.user_id)
+                return
+
+            metadata = {
+                'opportunity': opportunity.get('source'),
+                'confidence': confidence,
+                'wallet_signal': opportunity.get('wallet_address'),
+            }
+
             if action == 'buy':
-                result = await self.jupiter.execute_swap_with_jito(
-                    input_mint=SOL_MINT,
-                    output_mint=token_mint,
-                    amount=int(amount * 1e9),
-                    keypair=self.user_keypair,
-                    slippage_bps=int(self.config.max_slippage * 10000)
+                result = await self.trade_executor.execute_buy(
+                    self.user_id,
+                    token_mint,
+                    amount,
+                    token_symbol=opportunity.get('token_symbol'),
+                    reason='automated_trader',
+                    context='auto_trader',
+                    execution_mode='jito',
+                    metadata=metadata,
                 )
             else:
-                # Sell logic
-                result = {'success': False, 'error': 'Sell not implemented'}
-            
+                result = await self.trade_executor.execute_sell(
+                    self.user_id,
+                    token_mint,
+                    token_symbol=opportunity.get('token_symbol'),
+                    reason='automated_trader',
+                    context='auto_trader',
+                    metadata=metadata,
+                )
+
             if result.get('success'):
+                stop_loss_pct = None
+                take_profit_pct = None
+
+                if settings.use_stop_loss and settings.default_stop_loss_percentage:
+                    stop_loss_pct = max(settings.default_stop_loss_percentage, 0.0) / 100.0
+
+                if settings.use_take_profit and settings.default_take_profit_percentage:
+                    take_profit_pct = max(settings.default_take_profit_percentage, 0.0) / 100.0
+
                 # Record position
                 self.active_positions[token_mint] = {
-                    'entry_price': opportunity.get('price', 0),
+                    'entry_price': result.get('price') or opportunity.get('price', 0),
                     'amount': amount,
                     'timestamp': datetime.now(),
-                    'confidence': confidence
+                    'confidence': confidence,
+                    'token_symbol': opportunity.get('token_symbol'),
+                    'stop_loss_pct': stop_loss_pct,
+                    'take_profit_pct': take_profit_pct,
                 }
-                
+
                 # Update stats
                 self.daily_stats['trades'] += 1
                 
                 logger.info(f"âœ… Automated trade executed successfully")
             else:
                 logger.error(f"âŒ Automated trade failed: {result.get('error')}")
         
         except Exception as e:
             logger.error(f"Error executing automated trade: {e}")
     
-    async def _manage_positions(self):
+    async def _manage_positions(self, settings: Optional[SimpleNamespace] = None):
         """
         ğŸ“Š MANAGE OPEN POSITIONS
-        
+
         - Check stop losses
         - Check take profits
         - Implement trailing stops
         """
-        
+
+        if settings is None:
+            settings = await self._get_user_settings()
+
         for token_mint, position in list(self.active_positions.items()):
             try:
                 # Get current price
                 current_price = await self._get_token_price(token_mint)
                 
                 if current_price is None:
                     continue
                 
                 entry_price = position['entry_price']
                 pnl_pct = (current_price - entry_price) / entry_price if entry_price > 0 else 0
-                
+
                 # Check stop loss
-                if pnl_pct <= -self.config.stop_loss_percentage:
+                stop_loss_pct = position.get('stop_loss_pct')
+                if stop_loss_pct is None and settings.use_stop_loss and settings.default_stop_loss_percentage:
+                    stop_loss_pct = max(settings.default_stop_loss_percentage, 0.0) / 100.0
+
+                if stop_loss_pct is not None and pnl_pct <= -stop_loss_pct:
                     logger.info(f"ğŸ›‘ Stop loss triggered for {token_mint[:8]}... (PnL: {pnl_pct:.1%})")
                     await self._close_position(token_mint, "STOP_LOSS", pnl_pct)
                     continue
-                
+
                 # Check take profit
-                if pnl_pct >= self.config.take_profit_percentage:
+                take_profit_pct = position.get('take_profit_pct')
+                if take_profit_pct is None and settings.use_take_profit and settings.default_take_profit_percentage:
+                    take_profit_pct = max(settings.default_take_profit_percentage, 0.0) / 100.0
+
+                if take_profit_pct is not None and pnl_pct >= take_profit_pct:
                     logger.info(f"ğŸ’° Take profit triggered for {token_mint[:8]}... (PnL: {pnl_pct:.1%})")
                     await self._close_position(token_mint, "TAKE_PROFIT", pnl_pct)
                     continue
-                
+
                 # Implement trailing stop
                 if pnl_pct > 0:
                     if 'highest_price' not in position:
                         position['highest_price'] = current_price
                     else:
                         position['highest_price'] = max(position['highest_price'], current_price)
                         
                         # Check if price fell from highest
                         price_drop = (position['highest_price'] - current_price) / position['highest_price']
                         if price_drop >= self.config.trailing_stop_percentage:
                             logger.info(f"ğŸ“‰ Trailing stop triggered for {token_mint[:8]}... (PnL: {pnl_pct:.1%})")
                             await self._close_position(token_mint, "TRAILING_STOP", pnl_pct)
                 
             except Exception as e:
                 logger.error(f"Error managing position {token_mint}: {e}")
     
     async def _get_token_price(self, token_mint: str) -> Optional[float]:
         """Get current token price"""
         try:
             prices = await self.jupiter.get_token_price([token_mint])
             return prices.get(token_mint, 0)
         except Exception as e:
             logger.error(f"Error getting token price: {e}")
             return None
     
     async def _close_position(self, token_mint: str, reason: str, pnl_pct: float):
         """Close a position"""
         position = self.active_positions.pop(token_mint, None)
         if position:
             # Calculate P&L
             pnl_sol = position['amount'] * pnl_pct
             self.daily_stats['profit_loss'] += pnl_sol
-            
+
             logger.info(f"ğŸ”„ Closing position: {token_mint[:8]}... - Reason: {reason} - PnL: {pnl_sol:+.4f} SOL")
-            
-            # Execute actual sell transaction
+
+            if not self.trade_executor:
+                logger.error("Trade executor is not configured for automated exit")
+                self.active_positions[token_mint] = position
+                return
+
             try:
-                SOL_MINT = "So11111111111111111111111111111111111111112"
-                
-                # Get token balance to sell
-                balance = await self.wallet_manager.get_token_balance(self.user_id, token_mint)
-                if balance and balance > 0:
-                    # Convert to lamports
-                    amount_to_sell = int(balance * 1e9)  # Assume 9 decimals
-                    
-                    logger.info(f"ğŸ’° Selling {balance:.6f} tokens of {token_mint[:8]}...")
-                    
-                    # Execute swap through Jupiter
-                    result = await self.jupiter.execute_swap_with_jito(
-                        input_mint=token_mint,
-                        output_mint=SOL_MINT,
-                        amount=amount_to_sell,
-                        keypair=self.user_keypair,
-                        slippage_bps=300,  # 3% slippage for sells
-                        tip_amount_lamports=50000,  # 0.00005 SOL tip
-                        priority_fee_lamports=1000000  # Medium priority
-                    )
-                    
-                    if result and result.get('success'):
-                        logger.info(f"âœ… Position closed successfully!")
-                        logger.info(f"   Reason: {reason}")
-                        logger.info(f"   PnL: {pnl_sol:+.4f} SOL ({pnl_pct:+.1%})")
-                        logger.info(f"   Signature: {result.get('signature', 'N/A')}")
-                    else:
-                        logger.error(f"âŒ Failed to close position: {result}")
+                result = await self.trade_executor.execute_sell(
+                    self.user_id,
+                    token_mint,
+                    token_symbol=position.get('token_symbol'),
+                    reason=f'auto_trader:{reason}',
+                    context='auto_trader',
+                    metadata={'exit_reason': reason, 'trigger_pnl_pct': pnl_pct},
+                )
+
+                if result and result.get('success'):
+                    logger.info(f"âœ… Position closed successfully!")
+                    logger.info(f"   Reason: {reason}")
+                    logger.info(f"   PnL: {result.get('pnl', 0.0):+.4f} SOL")
+                    logger.info(f"   Signature: {result.get('signature', 'N/A')}")
                 else:
-                    logger.warning(f"âš ï¸ No token balance to sell for {token_mint[:8]}")
-                    
+                    logger.error(f"âŒ Failed to close position: {result}")
+                    self.active_positions[token_mint] = position
             except Exception as e:
                 logger.error(f"Error executing sell: {e}")
-                # Re-add position if sell failed
                 self.active_positions[token_mint] = position
-    
+
+    async def _get_user_settings(self, force_refresh: bool = False) -> SimpleNamespace:
+        """Load and cache user risk settings."""
+
+        if not getattr(self, 'user_id', None):
+            return self._default_user_settings()
+
+        if not self.db:
+            return self._default_user_settings()
+
+        now = datetime.utcnow()
+        if (
+            force_refresh
+            or self._user_settings is None
+            or self._settings_loaded_at is None
+            or (now - self._settings_loaded_at) > timedelta(minutes=5)
+        ):
+            record = await self.db.get_user_settings(self.user_id)
+            self._user_settings = self._settings_from_record(record)
+            self._settings_loaded_at = now
+
+        return self._user_settings
+
+    def _settings_from_record(self, record) -> SimpleNamespace:
+        if not record:
+            return self._default_user_settings()
+
+        return SimpleNamespace(
+            max_trade_size_sol=
+                record.max_trade_size_sol if record.max_trade_size_sol is not None else 1.0,
+            daily_loss_limit_sol=
+                record.daily_loss_limit_sol if record.daily_loss_limit_sol is not None else 5.0,
+            slippage_percentage=record.slippage_percentage or 5.0,
+            use_stop_loss=(
+                True if getattr(record, 'use_stop_loss', None) is None else bool(record.use_stop_loss)
+            ),
+            default_stop_loss_percentage=(
+                record.default_stop_loss_percentage if record.default_stop_loss_percentage is not None else 10.0
+            ),
+            use_take_profit=(
+                True if getattr(record, 'use_take_profit', None) is None else bool(record.use_take_profit)
+            ),
+            default_take_profit_percentage=(
+                record.default_take_profit_percentage if record.default_take_profit_percentage is not None else 20.0
+            ),
+        )
+
+    def _default_user_settings(self) -> SimpleNamespace:
+        return SimpleNamespace(
+            max_trade_size_sol=1.0,
+            daily_loss_limit_sol=5.0,
+            slippage_percentage=5.0,
+            use_stop_loss=True,
+            default_stop_loss_percentage=10.0,
+            use_take_profit=True,
+            default_take_profit_percentage=20.0,
+        )
+
     def get_status(self) -> Dict:
         """Get current trading status"""
         return {
             'is_running': self.is_running,
             'daily_trades': self.daily_stats['trades'],
             'daily_pnl': self.daily_stats['profit_loss'],
             'active_positions': len(self.active_positions),
             'positions': list(self.active_positions.keys())
         }
 
diff --git a/src/modules/database.py b/src/modules/database.py
index ac3b1fe4cf4f2d5884993315c99fa609df476808..17480bde1274d74fff3d3eb316ef316b5ff3c64e 100644
--- a/src/modules/database.py
+++ b/src/modules/database.py
@@ -1,180 +1,245 @@
 """
 Database module for tracking trades, profits, and wallet performance
 """
 
 import asyncio
 import logging
 from datetime import datetime, timedelta
-from typing import List, Dict, Optional
-from sqlalchemy import create_engine, Column, Integer, String, Float, DateTime, Boolean
+from typing import List, Dict, Optional, Tuple, Any
+from sqlalchemy import create_engine, Column, Integer, String, Float, DateTime, Boolean, Text
 from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
 from sqlalchemy.orm import declarative_base, sessionmaker
 from sqlalchemy import select, func, and_, or_
 
 logger = logging.getLogger(__name__)
 
 Base = declarative_base()
 
 
 class Trade(Base):
     """Trade record"""
     __tablename__ = 'trades'
     
     id = Column(Integer, primary_key=True)
     user_id = Column(Integer, index=True)
     signature = Column(String, unique=True)
     trade_type = Column(String)  # 'buy' or 'sell'
     token_mint = Column(String, index=True)
     token_symbol = Column(String)
     amount_sol = Column(Float)
     amount_tokens = Column(Float)
     price = Column(Float)
     slippage = Column(Float)
     price_impact = Column(Float)
     timestamp = Column(DateTime, default=datetime.utcnow, index=True)
     success = Column(Boolean)
     error_message = Column(String, nullable=True)
+
+    # Context
+    context = Column(String, default="manual", index=True)
+    metadata_json = Column(Text, nullable=True)
     
     # PnL tracking
     pnl_sol = Column(Float, nullable=True)
     pnl_percentage = Column(Float, nullable=True)
     
     # Position tracking
     position_id = Column(String, nullable=True, index=True)
     is_position_open = Column(Boolean, default=True)
 
 
 class UserWallet(Base):
     """Individual user trading wallet"""
     __tablename__ = 'user_wallets'
     
     id = Column(Integer, primary_key=True)
     user_id = Column(Integer, unique=True, index=True)
     telegram_username = Column(String)
     
     # Wallet credentials (encrypted)
     public_key = Column(String, unique=True, index=True)
     encrypted_private_key = Column(String)  # Encrypted with master key
     
     # Balances (cached)
     sol_balance = Column(Float, default=0.0)
     last_balance_update = Column(DateTime, nullable=True)
     
     # Metadata
     created_at = Column(DateTime, default=datetime.utcnow)
     last_used = Column(DateTime, default=datetime.utcnow)
     is_active = Column(Boolean, default=True)
 
 
 class TrackedWallet(Base):
     """Tracked wallet for copy trading"""
     __tablename__ = 'tracked_wallets'
-    
+
     id = Column(Integer, primary_key=True)
     user_id = Column(Integer, index=True)
     wallet_address = Column(String, index=True)
     label = Column(String)
     added_at = Column(DateTime, default=datetime.utcnow)
-    
+
     # Performance metrics
     total_trades = Column(Integer, default=0)
     profitable_trades = Column(Integer, default=0)
     win_rate = Column(Float, default=0.0)
     total_pnl = Column(Float, default=0.0)
     score = Column(Float, default=0.0)
-    
+
     # Copy trading
     copy_enabled = Column(Boolean, default=False)
     copy_amount_sol = Column(Float, default=0.1)
     last_checked = Column(DateTime, nullable=True)
 
+    # Trader profile metadata
+    is_trader = Column(Boolean, default=False, index=True)
+    trader_tier = Column(String, default='bronze')
+    followers = Column(Integer, default=0)
+    reputation_score = Column(Float, default=0.0)
+    strategies_shared = Column(Integer, default=0)
+    total_profit_shared = Column(Float, default=0.0)
+    is_verified = Column(Boolean, default=False)
+
+    # Copy relationship metadata
+    copy_trader_id = Column(Integer, nullable=True, index=True)
+    copy_percentage = Column(Float, default=100.0)
+    copy_started_at = Column(DateTime, nullable=True)
+    copy_max_daily_trades = Column(Integer, default=10)
+    copy_total_trades = Column(Integer, default=0)
+    copy_total_profit = Column(Float, default=0.0)
+
 
 class Position(Base):
     """Open trading position"""
     __tablename__ = 'positions'
-    
+
     id = Column(Integer, primary_key=True)
     user_id = Column(Integer, index=True)
     position_id = Column(String, unique=True, index=True)
     token_mint = Column(String, index=True)
     token_symbol = Column(String)
-    
+
+    # Token metadata
+    token_decimals = Column(Integer, default=9)
+
     # Entry
     entry_price = Column(Float)
     entry_amount_sol = Column(Float)
     entry_amount_tokens = Column(Float)
+    entry_amount_raw = Column(Integer, default=0)
     entry_signature = Column(String)
     entry_timestamp = Column(DateTime, default=datetime.utcnow)
-    
+
+    # Remaining balances for partial exits
+    remaining_amount_sol = Column(Float, default=0.0)
+    remaining_amount_tokens = Column(Float, default=0.0)
+    remaining_amount_raw = Column(Integer, default=0)
+    realized_pnl_sol = Column(Float, default=0.0)
+    realized_amount_sol = Column(Float, default=0.0)
+
     # Exit
     exit_price = Column(Float, nullable=True)
     exit_amount_sol = Column(Float, nullable=True)
+    exit_amount_tokens = Column(Float, nullable=True)
+    exit_amount_raw = Column(Integer, nullable=True)
     exit_signature = Column(String, nullable=True)
     exit_timestamp = Column(DateTime, nullable=True)
-    
+
     # Status
     is_open = Column(Boolean, default=True, index=True)
     pnl_sol = Column(Float, nullable=True)
     pnl_percentage = Column(Float, nullable=True)
-    
+
+    # Provenance / metadata
+    source = Column(String, default="manual", index=True)
+    metadata_json = Column(Text, nullable=True)
+
     # Stop loss / Take profit
     stop_loss_percentage = Column(Float, nullable=True)
     take_profit_percentage = Column(Float, nullable=True)
 
 
 class UserSettings(Base):
     """User configuration"""
     __tablename__ = 'user_settings'
     
     user_id = Column(Integer, primary_key=True)
     auto_trading_enabled = Column(Boolean, default=False)
     max_trade_size_sol = Column(Float, default=1.0)
     daily_loss_limit_sol = Column(Float, default=5.0)
     slippage_percentage = Column(Float, default=5.0)
     require_confirmation = Column(Boolean, default=True)
     
     # Risk management
     use_stop_loss = Column(Boolean, default=True)
     default_stop_loss_percentage = Column(Float, default=10.0)
     use_take_profit = Column(Boolean, default=True)
     default_take_profit_percentage = Column(Float, default=20.0)
     
     # Anti-scam
     check_honeypots = Column(Boolean, default=True)
     min_liquidity_usd = Column(Float, default=10000.0)
     
     # ğŸ¯ Auto-Sniper Settings
     snipe_enabled = Column(Boolean, default=False)
     snipe_max_amount = Column(Float, default=0.1)
     snipe_min_liquidity = Column(Float, default=10000.0)
     snipe_min_confidence = Column(Float, default=0.65)
     snipe_max_daily = Column(Integer, default=10)
     snipe_only_strong_buy = Column(Boolean, default=True)
     snipe_daily_used = Column(Integer, default=0)
     snipe_last_reset = Column(DateTime, default=datetime.utcnow)
-    
+    snipe_last_timestamp = Column(DateTime, nullable=True)
+
+    created_at = Column(DateTime, default=datetime.utcnow)
+    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
+
+
+class SnipeRun(Base):
+    """Snapshot of sniper AI decisions and execution state"""
+    __tablename__ = 'snipe_runs'
+
+    id = Column(Integer, primary_key=True)
+    snipe_id = Column(String, unique=True, index=True)
+    user_id = Column(Integer, index=True)
+    token_mint = Column(String, index=True)
+    token_symbol = Column(String)
+    amount_sol = Column(Float, default=0.0)
+
+    status = Column(String, index=True, default='ANALYZED')
+    ai_confidence = Column(Float, nullable=True)
+    ai_recommendation = Column(String, nullable=True)
+    ai_snapshot = Column(Text, nullable=True)
+    context_json = Column(Text, nullable=True)
+
+    decision_timestamp = Column(DateTime, default=datetime.utcnow, index=True)
+    triggered_at = Column(DateTime, nullable=True)
+    completed_at = Column(DateTime, nullable=True)
+    is_manual = Column(Boolean, default=False)
+
     created_at = Column(DateTime, default=datetime.utcnow)
     updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
 
 
 class DatabaseManager:
     """Async database manager"""
     
     def __init__(self, db_url: str = "sqlite+aiosqlite:///trading_bot.db"):
         self.engine = create_async_engine(db_url, echo=False)
         self.async_session = async_sessionmaker(
             self.engine,
             class_=AsyncSession,
             expire_on_commit=False
         )
     
     async def init_db(self):
         """Initialize database tables"""
         async with self.engine.begin() as conn:
             await conn.run_sync(Base.metadata.create_all)
         logger.info("Database initialized")
     
     async def add_trade(self, trade_data: Dict) -> Trade:
         """Add new trade record"""
         async with self.async_session() as session:
             trade = Trade(**trade_data)
@@ -241,71 +306,295 @@ class DatabaseManager:
             
             # Win rate
             win_rate = (profitable_trades / total_trades * 100) if total_trades > 0 else 0
             
             return {
                 'total_trades': total_trades,
                 'profitable_trades': profitable_trades,
                 'win_rate': win_rate,
                 'total_pnl': total_pnl,
                 'period_days': days
             }
     
     async def add_tracked_wallet(self, wallet_data: Dict) -> TrackedWallet:
         """Add wallet to track"""
         async with self.async_session() as session:
             wallet = TrackedWallet(**wallet_data)
             session.add(wallet)
             await session.commit()
             await session.refresh(wallet)
             return wallet
     
     async def get_tracked_wallets(self, user_id: int) -> List[TrackedWallet]:
         """Get user's tracked wallets"""
         async with self.async_session() as session:
             query = select(TrackedWallet).where(
-                TrackedWallet.user_id == user_id
+                and_(
+                    TrackedWallet.user_id == user_id,
+                    TrackedWallet.copy_trader_id.is_(None)
+                )
             ).order_by(TrackedWallet.score.desc())
             result = await session.execute(query)
             return result.scalars().all()
     
     async def update_wallet_metrics(
         self,
         wallet_id: int,
         metrics: Dict
     ):
         """Update wallet performance metrics"""
         async with self.async_session() as session:
             query = select(TrackedWallet).where(TrackedWallet.id == wallet_id)
             result = await session.execute(query)
             wallet = result.scalar_one_or_none()
-            
+
             if wallet:
                 for key, value in metrics.items():
                     setattr(wallet, key, value)
                 wallet.last_checked = datetime.utcnow()
                 await session.commit()
+
+    async def upsert_trader_profile(
+        self,
+        user_id: int,
+        username: str,
+        metadata: Optional[Dict] = None
+    ) -> TrackedWallet:
+        """Create or update a trader profile in tracked wallets"""
+        metadata = metadata or {}
+        async with self.async_session() as session:
+            query = select(TrackedWallet).where(
+                and_(
+                    TrackedWallet.user_id == user_id,
+                    TrackedWallet.is_trader == True
+                )
+            )
+            result = await session.execute(query)
+            profile = result.scalar_one_or_none()
+
+            if not profile:
+                profile = TrackedWallet(
+                    user_id=user_id,
+                    wallet_address=metadata.get('wallet_address', f'trader:{user_id}'),
+                    label=username,
+                    is_trader=True,
+                    trader_tier=metadata.get('trader_tier', 'bronze'),
+                    followers=metadata.get('followers', 0),
+                    reputation_score=metadata.get('reputation_score', 0.0),
+                    strategies_shared=metadata.get('strategies_shared', 0),
+                    total_profit_shared=metadata.get('total_profit_shared', 0.0),
+                    is_verified=metadata.get('is_verified', False)
+                )
+                session.add(profile)
+            else:
+                profile.label = username
+                for key, value in metadata.items():
+                    if hasattr(profile, key):
+                        setattr(profile, key, value)
+
+            await session.commit()
+            await session.refresh(profile)
+            return profile
+
+    async def get_trader_profiles(self) -> List[TrackedWallet]:
+        """Return all trader profiles"""
+        async with self.async_session() as session:
+            query = select(TrackedWallet).where(TrackedWallet.is_trader == True)
+            result = await session.execute(query)
+            return result.scalars().all()
+
+    async def get_trader_profile(self, user_id: int) -> Optional[TrackedWallet]:
+        """Return a specific trader profile"""
+        async with self.async_session() as session:
+            query = select(TrackedWallet).where(
+                and_(
+                    TrackedWallet.user_id == user_id,
+                    TrackedWallet.is_trader == True
+                )
+            )
+            result = await session.execute(query)
+            return result.scalar_one_or_none()
+
+    async def update_trader_profile(self, user_id: int, updates: Dict) -> Optional[TrackedWallet]:
+        """Update trader profile fields"""
+        async with self.async_session() as session:
+            query = select(TrackedWallet).where(
+                and_(
+                    TrackedWallet.user_id == user_id,
+                    TrackedWallet.is_trader == True
+                )
+            )
+            result = await session.execute(query)
+            profile = result.scalar_one_or_none()
+
+            if not profile:
+                return None
+
+            for key, value in updates.items():
+                if hasattr(profile, key):
+                    setattr(profile, key, value)
+
+            await session.commit()
+            await session.refresh(profile)
+            return profile
+
+    async def increment_trader_followers(self, user_id: int, delta: int) -> Optional[TrackedWallet]:
+        """Increment a trader's follower count"""
+        async with self.async_session() as session:
+            query = select(TrackedWallet).where(
+                and_(
+                    TrackedWallet.user_id == user_id,
+                    TrackedWallet.is_trader == True
+                )
+            )
+            result = await session.execute(query)
+            profile = result.scalar_one_or_none()
+
+            if not profile:
+                return None
+
+            profile.followers = max(0, (profile.followers or 0) + delta)
+
+            await session.commit()
+            await session.refresh(profile)
+            return profile
+
+    async def set_copy_relationship(
+        self,
+        follower_id: int,
+        trader_id: int,
+        settings: Dict
+    ) -> Tuple[TrackedWallet, bool]:
+        """Enable or create a copy relationship"""
+        async with self.async_session() as session:
+            query = select(TrackedWallet).where(
+                and_(
+                    TrackedWallet.user_id == follower_id,
+                    TrackedWallet.copy_trader_id == trader_id
+                )
+            )
+            result = await session.execute(query)
+            relationship = result.scalar_one_or_none()
+            activated = False
+            now = datetime.utcnow()
+
+            if not relationship:
+                relationship = TrackedWallet(
+                    user_id=follower_id,
+                    wallet_address=settings.get('wallet_address', f'copy:{trader_id}'),
+                    label=settings.get('label', f'Copy {trader_id}'),
+                    copy_trader_id=trader_id,
+                    copy_enabled=True,
+                    copy_amount_sol=settings.get('max_copy_amount', 0.1),
+                    copy_percentage=settings.get('copy_percentage', 100.0),
+                    copy_max_daily_trades=settings.get('max_daily_trades', 10),
+                    copy_started_at=now
+                )
+                session.add(relationship)
+                activated = True
+            else:
+                previously_enabled = bool(relationship.copy_enabled)
+                relationship.copy_enabled = True
+                relationship.copy_started_at = relationship.copy_started_at or now
+                activated = not previously_enabled
+
+            relationship.copy_amount_sol = settings.get('max_copy_amount', relationship.copy_amount_sol)
+            relationship.copy_percentage = settings.get('copy_percentage', relationship.copy_percentage or 100.0)
+            relationship.copy_max_daily_trades = settings.get(
+                'max_daily_trades',
+                relationship.copy_max_daily_trades
+            )
+            relationship.last_checked = now
+
+            await session.commit()
+            await session.refresh(relationship)
+            return relationship, activated
+
+    async def disable_copy_relationship(self, follower_id: int, trader_id: int) -> bool:
+        """Disable an active copy relationship"""
+        async with self.async_session() as session:
+            query = select(TrackedWallet).where(
+                and_(
+                    TrackedWallet.user_id == follower_id,
+                    TrackedWallet.copy_trader_id == trader_id
+                )
+            )
+            result = await session.execute(query)
+            relationship = result.scalar_one_or_none()
+
+            if not relationship:
+                return False
+
+            was_enabled = bool(relationship.copy_enabled)
+            relationship.copy_enabled = False
+            await session.commit()
+            return was_enabled
+
+    async def get_copy_relationships(
+        self,
+        follower_id: Optional[int] = None,
+        only_enabled: bool = True
+    ) -> List[TrackedWallet]:
+        """Return copy relationships for a follower or all"""
+        async with self.async_session() as session:
+            query = select(TrackedWallet).where(TrackedWallet.copy_trader_id.isnot(None))
+
+            if follower_id is not None:
+                query = query.where(TrackedWallet.user_id == follower_id)
+
+            if only_enabled:
+                query = query.where(TrackedWallet.copy_enabled == True)
+
+            result = await session.execute(query)
+            return result.scalars().all()
+
+    async def update_copy_relationship(
+        self,
+        follower_id: int,
+        trader_id: int,
+        updates: Dict
+    ):
+        """Update fields on a copy relationship"""
+        async with self.async_session() as session:
+            query = select(TrackedWallet).where(
+                and_(
+                    TrackedWallet.user_id == follower_id,
+                    TrackedWallet.copy_trader_id == trader_id
+                )
+            )
+            result = await session.execute(query)
+            relationship = result.scalar_one_or_none()
+
+            if not relationship:
+                return
+
+            for key, value in updates.items():
+                if hasattr(relationship, key):
+                    setattr(relationship, key, value)
+
+            await session.commit()
+
     
     async def open_position(self, position_data: Dict) -> Position:
         """Open new trading position"""
         async with self.async_session() as session:
             position = Position(**position_data)
             session.add(position)
             await session.commit()
             await session.refresh(position)
             return position
     
     async def close_position(
         self,
         position_id: str,
         exit_data: Dict
     ) -> Optional[Position]:
         """Close trading position"""
         async with self.async_session() as session:
             query = select(Position).where(Position.position_id == position_id)
             result = await session.execute(query)
             position = result.scalar_one_or_none()
             
             if position:
                 position.is_open = False
                 for key, value in exit_data.items():
                     setattr(position, key, value)
@@ -331,78 +620,200 @@ class DatabaseManager:
                 and_(
                     Position.user_id == user_id,
                     Position.is_open == True
                 )
             ).order_by(Position.entry_timestamp.desc())
             result = await session.execute(query)
             return result.scalars().all()
     
     async def get_position_by_token(
         self,
         user_id: int,
         token_mint: str
     ) -> Optional[Position]:
         """Get open position for specific token"""
         async with self.async_session() as session:
             query = select(Position).where(
                 and_(
                     Position.user_id == user_id,
                     Position.token_mint == token_mint,
                     Position.is_open == True
                 )
             )
             result = await session.execute(query)
             return result.scalar_one_or_none()
     
+
+    async def update_position_partial(self, position_id: str, updates: Dict[str, Any]) -> Optional[Position]:
+        """Apply partial exit updates to a position without closing it."""
+        if not updates:
+            return None
+
+        async with self.async_session() as session:
+            query = select(Position).where(Position.position_id == position_id)
+            result = await session.execute(query)
+            position = result.scalar_one_or_none()
+
+            if not position:
+                return None
+
+            for key, value in updates.items():
+                if hasattr(position, key):
+                    setattr(position, key, value)
+
+            await session.commit()
+            await session.refresh(position)
+            return position
+
     async def get_user_settings(self, user_id: int) -> Optional[UserSettings]:
         """Get user settings"""
         async with self.async_session() as session:
             query = select(UserSettings).where(UserSettings.user_id == user_id)
             result = await session.execute(query)
             return result.scalar_one_or_none()
     
+    async def ensure_user_settings(self, user_id: int, defaults: Dict[str, Any]) -> UserSettings:
+        """Ensure a user settings row exists and return it."""
+        async with self.async_session() as session:
+            query = select(UserSettings).where(UserSettings.user_id == user_id)
+            result = await session.execute(query)
+            record = result.scalar_one_or_none()
+
+            if record:
+                return record
+
+            record = UserSettings(user_id=user_id, **defaults)
+            session.add(record)
+            await session.commit()
+            await session.refresh(record)
+            return record
+
     async def update_user_settings(self, user_id: int, settings: Dict):
         """Update user settings"""
         async with self.async_session() as session:
             query = select(UserSettings).where(UserSettings.user_id == user_id)
             result = await session.execute(query)
             user_settings = result.scalar_one_or_none()
-            
+
             if not user_settings:
                 user_settings = UserSettings(user_id=user_id, **settings)
                 session.add(user_settings)
             else:
                 for key, value in settings.items():
                     setattr(user_settings, key, value)
                 user_settings.updated_at = datetime.utcnow()
-            
+
             await session.commit()
-    
+
+    async def get_all_user_settings(self) -> List[UserSettings]:
+        """Return all user settings records"""
+        async with self.async_session() as session:
+            query = select(UserSettings)
+            result = await session.execute(query)
+            return result.scalars().all()
+
+    async def upsert_snipe_run(self, run_data: Dict) -> SnipeRun:
+        """Create or update a sniper run snapshot"""
+        async with self.async_session() as session:
+            query = select(SnipeRun).where(SnipeRun.snipe_id == run_data['snipe_id'])
+            result = await session.execute(query)
+            run = result.scalar_one_or_none()
+
+            if run:
+                for key, value in run_data.items():
+                    setattr(run, key, value)
+                run.updated_at = datetime.utcnow()
+            else:
+                run = SnipeRun(**run_data)
+                session.add(run)
+
+            await session.commit()
+            await session.refresh(run)
+            return run
+
+    async def update_snipe_run(self, snipe_id: str, updates: Dict) -> Optional[SnipeRun]:
+        """Update sniper run state"""
+        if not updates:
+            updates = {}
+
+        async with self.async_session() as session:
+            query = select(SnipeRun).where(SnipeRun.snipe_id == snipe_id)
+            result = await session.execute(query)
+            run = result.scalar_one_or_none()
+
+            if not run:
+                return None
+
+            for key, value in updates.items():
+                setattr(run, key, value)
+
+            run.updated_at = datetime.utcnow()
+            await session.commit()
+            await session.refresh(run)
+            return run
+
+    async def get_active_snipe_runs(self) -> List[SnipeRun]:
+        """Return snipes that are still awaiting execution"""
+        async with self.async_session() as session:
+            query = select(SnipeRun).where(
+                SnipeRun.status.in_(['MONITORING', 'EXECUTING'])
+            ).order_by(SnipeRun.decision_timestamp.asc())
+            result = await session.execute(query)
+            return result.scalars().all()
+
+    async def get_recent_snipe_runs(
+        self,
+        user_id: Optional[int] = None,
+        limit: int = 50
+    ) -> List[SnipeRun]:
+        """Fetch recent sniper decisions"""
+        async with self.async_session() as session:
+            query = select(SnipeRun)
+
+            if user_id is not None:
+                query = query.where(SnipeRun.user_id == user_id)
+
+            query = query.order_by(SnipeRun.decision_timestamp.desc(), SnipeRun.updated_at.desc()).limit(limit)
+            result = await session.execute(query)
+            runs = list(result.scalars().all())
+            runs.reverse()  # Oldest first for chronological presentation
+            return runs
+
     async def get_daily_pnl(self, user_id: int) -> float:
         """Get today's PnL"""
         async with self.async_session() as session:
             today = datetime.utcnow().replace(hour=0, minute=0, second=0, microsecond=0)
             
             query = select(func.sum(Trade.pnl_sol)).where(
                 and_(
                     Trade.user_id == user_id,
                     Trade.timestamp >= today,
                     Trade.success == True
                 )
             )
             result = await session.execute(query)
             return result.scalar() or 0.0
     
     async def cleanup_old_data(self, days: int = 90):
         """Clean up old trade data"""
         async with self.async_session() as session:
             cutoff_date = datetime.utcnow() - timedelta(days=days)
             
             query = select(Trade).where(Trade.timestamp < cutoff_date)
             result = await session.execute(query)
             old_trades = result.scalars().all()
             
             for trade in old_trades:
                 await session.delete(trade)
             
             await session.commit()
             logger.info(f"Cleaned up {len(old_trades)} old trades")
+
+    async def dispose(self):
+        """Dispose of the underlying async engine."""
+        dispose = getattr(self.engine, 'dispose', None)
+        if not dispose:
+            return
+
+        result = dispose()
+        if hasattr(result, '__await__'):
+            await result
diff --git a/src/modules/monitoring.py b/src/modules/monitoring.py
index 53eed98b1dc60cd147c6afa3160bc75ca1f6df74..5a41bb42ea054dbaf09842482b15a186bed64a55 100644
--- a/src/modules/monitoring.py
+++ b/src/modules/monitoring.py
@@ -1,92 +1,186 @@
 """
 Monitoring and Alerting Module
 Tracks bot health, performance, and sends alerts
 """
 
 import asyncio
 import logging
+from collections import defaultdict
 from datetime import datetime, timedelta
-from typing import Dict, List, Optional
+from typing import Any, Dict, List, Optional
 from telegram import Bot
 from telegram.error import TelegramError
+from telegram.helpers import escape_markdown
 
 logger = logging.getLogger(__name__)
 
 
 class BotMonitor:
     """Monitor bot health and performance"""
     
     def __init__(self, bot: Bot, admin_chat_id: Optional[int] = None):
         self.bot = bot
         self.admin_chat_id = admin_chat_id
         
         # Metrics
         self.start_time = datetime.utcnow()
         self.total_requests = 0
         self.successful_trades = 0
         self.failed_trades = 0
         self.errors: List[Dict] = []
         self.last_heartbeat = datetime.utcnow()
-        
+
         # Alerts
         self.alert_cooldown: Dict[str, datetime] = {}
         self.alert_cooldown_seconds = 300  # 5 minutes
+
+        # Custom metrics storage (rolling window per metric name)
+        self.metrics: Dict[str, List[Dict[str, Any]]] = defaultdict(list)
     
     def record_request(self):
         """Record an API request"""
         self.total_requests += 1
     
     def record_trade_success(self):
         """Record successful trade"""
         self.successful_trades += 1
     
     def record_trade_failure(self, error: str):
         """Record failed trade"""
         self.failed_trades += 1
         self.errors.append({
             'timestamp': datetime.utcnow(),
             'type': 'trade_failure',
             'message': error
         })
     
     def record_error(self, error_type: str, message: str):
         """Record an error"""
         self.errors.append({
             'timestamp': datetime.utcnow(),
             'type': error_type,
             'message': message
         })
         
         # Keep only last 100 errors
         if len(self.errors) > 100:
             self.errors = self.errors[-100:]
     
     def update_heartbeat(self):
         """Update heartbeat timestamp"""
         self.last_heartbeat = datetime.utcnow()
-    
+
+    def record_metric(
+        self,
+        name: str,
+        value: float,
+        *,
+        tags: Optional[Dict[str, Any]] = None,
+    ) -> None:
+        """Record a numeric metric sample with optional tags."""
+
+        sample = {
+            'timestamp': datetime.utcnow(),
+            'value': value,
+            'tags': tags or {},
+        }
+
+        metric_samples = self.metrics[name]
+        metric_samples.append(sample)
+
+        # Keep the last 200 samples per metric to avoid unbounded growth
+        if len(metric_samples) > 200:
+            del metric_samples[:-200]
+
+    def get_metric_samples(self, name: str) -> List[Dict[str, Any]]:
+        """Return recent metric samples for external reporting."""
+
+        return list(self.metrics.get(name, ()))
+
+    def get_recent_errors(self, *, limit: int = 5) -> List[Dict[str, Any]]:
+        """Return the most recent recorded errors."""
+
+        if limit <= 0:
+            return []
+        return list(self.errors[-limit:])
+
+    def render_markdown_summary(self) -> str:
+        """Serialize current health/metrics into a Markdown snippet."""
+
+        stats = self.get_stats()
+        lines = [
+            "*Bot Metrics Summary*",
+            f"â€¢ Uptime: `{stats['uptime_hours']:.2f}h`",
+            f"â€¢ Total requests: `{stats['total_requests']}`",
+            f"â€¢ Successful trades: `{stats['successful_trades']}`",
+            f"â€¢ Failed trades: `{stats['failed_trades']}`",
+            f"â€¢ Success rate: `{stats['success_rate']:.1f}%`",
+        ]
+
+        if self.metrics:
+            lines.append("\n*Latest custom metrics*")
+            for name, samples in self.metrics.items():
+                if not samples:
+                    continue
+                latest = samples[-1]
+                timestamp = latest['timestamp'].strftime('%Y-%m-%d %H:%M:%S')
+                value = latest['value']
+                lines.append(
+                    f"â€¢ `{escape_markdown(name, version=1)}`: `{value}` (at {timestamp} UTC)"
+                )
+
+        recent_errors = self.get_recent_errors()
+        if recent_errors:
+            lines.append("\n*Recent errors*")
+            for err in recent_errors:
+                timestamp = err['timestamp'].strftime('%H:%M:%S')
+                err_type = escape_markdown(str(err['type']), version=1)
+                message = escape_markdown(str(err['message']), version=1)
+                lines.append(
+                    f"â€¢ `{timestamp}` Â· `{err_type}` â€“ {message}"
+                )
+
+        return "\n".join(lines)
+
+    async def publish_summary(self, heading: str = "ğŸ“Š Bot metrics summary") -> None:
+        """Send the metrics report to the configured admin chat."""
+
+        if not self.admin_chat_id or not self.bot:
+            return
+
+        message = f"{heading}\n\n{self.render_markdown_summary()}"
+        try:
+            await self.bot.send_message(
+                chat_id=self.admin_chat_id,
+                text=message,
+                parse_mode='Markdown',
+                disable_web_page_preview=True,
+            )
+        except TelegramError as exc:  # pragma: no cover - network dependent
+            logger.error("Failed to publish metrics summary: %s", exc)
+
     async def send_alert(self, alert_type: str, message: str):
         """Send alert to admin"""
         if not self.admin_chat_id:
             return
         
         # Check cooldown
         cooldown_key = f"{alert_type}:{message[:50]}"
         if cooldown_key in self.alert_cooldown:
             time_since_last = (datetime.utcnow() - self.alert_cooldown[cooldown_key]).seconds
             if time_since_last < self.alert_cooldown_seconds:
                 return  # Skip duplicate alert
         
         try:
             alert_message = f"ğŸš¨ *ALERT*\n\n"
             alert_message += f"Type: `{alert_type}`\n"
             alert_message += f"Time: `{datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')}`\n\n"
             alert_message += f"{message}"
             
             await self.bot.send_message(
                 chat_id=self.admin_chat_id,
                 text=alert_message,
                 parse_mode='Markdown'
             )
             
             # Update cooldown
diff --git a/src/modules/sentiment_analysis.py b/src/modules/sentiment_analysis.py
index 020e9804f3bd41db78b7633827e3d5fdf178e0a4..bb71a95de47d999936dec2f6938bd05ac5df8670 100644
--- a/src/modules/sentiment_analysis.py
+++ b/src/modules/sentiment_analysis.py
@@ -659,72 +659,80 @@ class SocialMediaAggregator:
     ) -> Dict:
         """
         Comprehensive social media sentiment analysis
         
         Returns aggregated sentiment from all sources
         """
         # Check cache
         if token_address in self.social_scores:
             last_update = self.update_intervals.get(token_address, datetime.min)
             if (datetime.utcnow() - last_update).seconds < 300:  # 5 min cache
                 return self.social_scores[token_address]
         
         # Search keywords
         keywords = [token_address[:8], token_symbol, f"${token_symbol}"]
         
         # Gather data from all sources
         twitter_data = await self.twitter.monitor_token(token_address, keywords)
         reddit_data = await self.reddit.monitor_token(token_address, keywords)
         discord_data = await self.discord.monitor_mentions(token_address, keywords)
         
         # Aggregate scores
         # Weight Twitter more heavily (real-time, high signal)
         twitter_weight = 0.5
         reddit_weight = 0.3
         discord_weight = 0.2
-        
+
         aggregated_sentiment = (
-            twitter_data['sentiment_score'] * twitter_weight +
-            reddit_data['sentiment_score'] * reddit_weight +
-            discord_data['sentiment_score'] * discord_weight
+            twitter_data.get('sentiment_score', 50) * twitter_weight +
+            reddit_data.get('sentiment_score', 50) * reddit_weight +
+            discord_data.get('sentiment_score', 50) * discord_weight
         )
-        
+
         # Calculate overall social score (0-100)
         social_score = self._calculate_social_score(
             twitter_data,
             reddit_data,
             discord_data
         )
-        
+
+        total_mentions = (
+            twitter_data.get('mentions', 0)
+            + reddit_data.get('posts', 0)
+            + reddit_data.get('comments', 0)
+            + discord_data.get('mentions', 0)
+        )
+
         result = {
             'sentiment_score': aggregated_sentiment,
             'social_score': social_score,
             'twitter': twitter_data,
             'reddit': reddit_data,
             'discord': discord_data,
-            'viral_potential': twitter_data['viral_potential'],
+            'viral_potential': twitter_data.get('viral_potential', 0.0),
             'overall_recommendation': self._get_recommendation(social_score, aggregated_sentiment),
+            'total_mentions': total_mentions,
             'last_updated': datetime.utcnow()
         }
         
         # Cache result
         self.social_scores[token_address] = result
         self.update_intervals[token_address] = datetime.utcnow()
         
         return result
     
     async def aggregate_sentiment(
         self,
         token_address: Optional[str] = None,
         duration_hours: int = 24
     ) -> Dict:
         """
         Aggregate sentiment across all social media sources
         
         Args:
             token_address: Token to analyze (None for general market sentiment)
             duration_hours: Time window to analyze
         
         Returns:
             Aggregated sentiment data
         """
         # Simulated aggregated data
@@ -743,63 +751,72 @@ class SocialMediaAggregator:
             },
             'trending_topics': [
                 {'topic': 'new_listing', 'count': 450},
                 {'topic': 'partnership', 'count': 320},
                 {'topic': 'bullish', 'count': 280}
             ],
             'duration_hours': duration_hours
         }
     
     def _calculate_social_score(
         self,
         twitter: Dict,
         reddit: Dict,
         discord: Dict
     ) -> float:
         """
         Calculate overall social score (0-100)
         
         Based on:
         - Total mentions across platforms
         - Sentiment
         - Viral potential
         - Influencer engagement
         """
         # Mention score (0-40 points)
-        total_mentions = twitter['mentions'] + reddit['posts'] + discord['mentions']
+        total_mentions = (
+            twitter.get('mentions', 0)
+            + reddit.get('posts', 0)
+            + reddit.get('comments', 0)
+            + discord.get('mentions', 0)
+        )
         mention_score = min(total_mentions / 100 * 40, 40)
-        
+
         # Sentiment score (0-30 points)
-        avg_sentiment = (twitter['sentiment_score'] + reddit['sentiment_score'] + discord['sentiment_score']) / 3
+        avg_sentiment = (
+            twitter.get('sentiment_score', 50)
+            + reddit.get('sentiment_score', 50)
+            + discord.get('sentiment_score', 50)
+        ) / 3
         sentiment_score = avg_sentiment / 100 * 30
-        
+
         # Viral score (0-20 points)
-        viral_score = twitter['viral_potential'] * 20
-        
+        viral_score = twitter.get('viral_potential', 0) * 20
+
         # Influencer score (0-10 points)
-        influencer_score = min(twitter['influencer_mentions'] / 5 * 10, 10)
-        
+        influencer_score = min(twitter.get('influencer_mentions', 0) / 5 * 10, 10)
+
         return mention_score + sentiment_score + viral_score + influencer_score
     
     def _get_recommendation(self, social_score: float, sentiment: float) -> str:
         """Get trading recommendation based on social data"""
         
         if social_score > 80 and sentiment > 70:
             return 'strong_buy'
         elif social_score > 60 and sentiment > 60:
             return 'buy'
         elif social_score > 40 or sentiment > 50:
             return 'neutral'
         else:
             return 'avoid'
     
     async def detect_viral_tokens(self, min_score: float = 70) -> List[Dict]:
         """Detect tokens going viral"""
         
         viral_tokens = []
         
         for token_address, data in self.social_scores.items():
             if data['social_score'] >= min_score:
                 viral_tokens.append({
                     'token_address': token_address,
                     'social_score': data['social_score'],
                     'viral_potential': data['viral_potential'],
diff --git a/src/modules/social_trading.py b/src/modules/social_trading.py
index 4eb1dcfb38671d3c3edc90a126e60ca223b32ec4..6566de732c5651772bdb3952cd981c8fd5489f92 100644
--- a/src/modules/social_trading.py
+++ b/src/modules/social_trading.py
@@ -1,142 +1,226 @@
 """
 SOCIAL TRADING MARKETPLACE
 Revolutionary copy trading and community intelligence system
 
 UNIQUE DIFFERENTIATORS:
 1. Copy top traders automatically
 2. Community-driven token intelligence
 3. Trader reputation system
 4. Strategy marketplace
 5. Profit sharing for shared strategies
 """
 
 import asyncio
 import logging
-from typing import Dict, List, Optional, Set
+from typing import Any, Dict, List, Optional, Set
 from datetime import datetime, timedelta
 from dataclasses import dataclass
 from enum import Enum
 
 logger = logging.getLogger(__name__)
 
 
 class TraderTier(Enum):
     """Trader reputation tiers"""
     BRONZE = "bronze"
     SILVER = "silver"
     GOLD = "gold"
     PLATINUM = "platinum"
     DIAMOND = "diamond"
 
 
 @dataclass
 class TraderProfile:
     """Public trader profile"""
     user_id: int
     username: str
     tier: TraderTier
     total_trades: int
     win_rate: float
     total_pnl: float
     followers: int
     reputation_score: float
     verified: bool
     strategies_shared: int
     total_profit_shared: float
 
 
 class SocialTradingMarketplace:
     """
     Marketplace for copy trading and strategy sharing
     """
     
     def __init__(self, database_manager):
         self.db = database_manager
         self.traders: Dict[int, TraderProfile] = {}
-        self.copy_relationships: Dict[int, Set[int]] = {}  # follower_id -> [trader_ids]
-        self.active_copies: Dict[int, Dict] = {}  # user_id -> copy settings
+        self.copy_relationships: Dict[int, Set[int]] = {}  # follower_id -> trader_ids
+        self.active_copies: Dict[int, Dict[int, Dict]] = {}  # follower_id -> trader_id -> settings
         self.leaderboard_cache: List[TraderProfile] = []
         self.last_leaderboard_update = datetime.utcnow()
-    
+        self._initialized = False
+        self._init_lock = asyncio.Lock()
+        self.trade_executor = None
+
+    async def initialize(self):
+        """Load trader and copy trading state from the database"""
+        async with self._init_lock:
+            if self._initialized:
+                return
+
+            await self._load_traders_from_db()
+            await self._load_copy_relationships()
+            await self._update_leaderboard()
+
+            self._initialized = True
+
+    async def _ensure_initialized(self):
+        if not self._initialized:
+            await self.initialize()
+
+    def attach_trade_executor(self, trade_executor) -> None:
+        """Attach the shared trade execution service for follower trades."""
+        self.trade_executor = trade_executor
+
+    async def _load_traders_from_db(self):
+        self.traders.clear()
+        trader_records = await self.db.get_trader_profiles()
+
+        for record in trader_records:
+            profile = self._record_to_profile(record)
+            self.traders[profile.user_id] = profile
+
+    async def _load_copy_relationships(self):
+        self.copy_relationships.clear()
+        self.active_copies.clear()
+
+        relationships = await self.db.get_copy_relationships(only_enabled=False)
+
+        for rel in relationships:
+            trader_id = rel.copy_trader_id
+            if trader_id is None:
+                continue
+
+            follower_id = rel.user_id
+            self.active_copies.setdefault(follower_id, {})[trader_id] = {
+                'copy_percentage': rel.copy_percentage or 100.0,
+                'max_copy_amount': rel.copy_amount_sol or 0.1,
+                'max_daily_trades': rel.copy_max_daily_trades or 10,
+                'enabled': bool(rel.copy_enabled),
+                'started_at': rel.copy_started_at or datetime.utcnow(),
+                'total_copied': rel.copy_total_trades or 0,
+                'total_profit': rel.copy_total_profit or 0.0
+            }
+
+            if rel.copy_enabled:
+                self.copy_relationships.setdefault(follower_id, set()).add(trader_id)
+
+    def _record_to_profile(self, record) -> TraderProfile:
+        """Convert a tracked wallet record into a trader profile"""
+        tier_key = (record.trader_tier or 'bronze').upper()
+        tier = TraderTier.__members__.get(tier_key, TraderTier.BRONZE)
+
+        return TraderProfile(
+            user_id=record.user_id,
+            username=record.label or f"trader_{record.user_id}",
+            tier=tier,
+            total_trades=record.total_trades or 0,
+            win_rate=record.win_rate or 0.0,
+            total_pnl=record.total_pnl or 0.0,
+            followers=record.followers or 0,
+            reputation_score=record.reputation_score or 0.0,
+            verified=bool(record.is_verified),
+            strategies_shared=record.strategies_shared or 0,
+            total_profit_shared=record.total_profit_shared or 0.0
+        )
+
     async def register_trader(
         self,
         user_id: int,
         username: str
     ) -> TraderProfile:
         """Register a new trader in the marketplace"""
-        
+
+        await self._ensure_initialized()
+
         # Check if already registered
         if user_id in self.traders:
-            return self.traders[user_id]
-        
-        # Create profile
-        profile = TraderProfile(
-            user_id=user_id,
-            username=username,
-            tier=TraderTier.BRONZE,
-            total_trades=0,
-            win_rate=0.0,
-            total_pnl=0.0,
-            followers=0,
-            reputation_score=0.0,
-            verified=False,
-            strategies_shared=0,
-            total_profit_shared=0.0
-        )
-        
+            profile = self.traders[user_id]
+            if profile.username != username:
+                await self.db.update_trader_profile(user_id, {'label': username})
+                profile.username = username
+            return profile
+
+        record = await self.db.upsert_trader_profile(user_id, username)
+        profile = self._record_to_profile(record)
         self.traders[user_id] = profile
+
+        await self._update_leaderboard()
         logger.info(f"Trader registered: {username}")
-        
+
         return profile
     
     async def update_trader_stats(
         self,
         user_id: int,
         trade_result: Dict
     ):
         """Update trader statistics after a trade"""
-        
+
+        await self._ensure_initialized()
+
         if user_id not in self.traders:
             return
-        
+
         profile = self.traders[user_id]
-        
+
         # Update stats
         profile.total_trades += 1
         profile.total_pnl += trade_result.get('pnl', 0)
         
         # Recalculate win rate
         stats = await self.db.get_user_stats(user_id, days=30)
         profile.win_rate = stats.get('win_rate', 0)
         
         # Update reputation score
         profile.reputation_score = self._calculate_reputation_score(profile)
-        
+
         # Update tier
         profile.tier = self._calculate_tier(profile)
-        
+
+        # Persist to database
+        await self.db.update_trader_profile(user_id, {
+            'total_trades': profile.total_trades,
+            'total_pnl': profile.total_pnl,
+            'win_rate': profile.win_rate,
+            'reputation_score': profile.reputation_score,
+            'trader_tier': profile.tier.value,
+            'followers': profile.followers,
+            'strategies_shared': profile.strategies_shared,
+            'total_profit_shared': profile.total_profit_shared,
+        })
+
         # Update leaderboard
         await self._update_leaderboard()
     
     def _calculate_reputation_score(self, profile: TraderProfile) -> float:
         """
         Calculate trader reputation score (0-100)
         
         Based on:
         - Win rate (40%)
         - Total PnL (30%)
         - Consistency (20%)
         - Community engagement (10%)
         """
         # Win rate component (0-40 points)
         win_rate_score = min(profile.win_rate, 100) * 0.4
         
         # PnL component (0-30 points)
         pnl_score = min(max(profile.total_pnl / 10, 0), 30)
         
         # Consistency component (0-20 points)
         # More trades = more consistent
         consistency_score = min(profile.total_trades / 100 * 20, 20)
         
         # Community component (0-10 points)
         community_score = min(
@@ -160,256 +244,416 @@ class SocialTradingMarketplace:
             return TraderTier.SILVER
         else:
             return TraderTier.BRONZE
     
     async def start_copying(
         self,
         follower_id: int,
         trader_id: int,
         copy_percentage: float = 100.0,
         max_copy_amount: float = 1.0
     ) -> bool:
         """
         Start copying a trader
         
         Args:
             follower_id: User who wants to copy
             trader_id: Trader to copy
             copy_percentage: Percentage of trader's position size to copy
             max_copy_amount: Maximum amount to copy per trade
         
         Returns:
             Success status
         """
         settings = {
             'copy_percentage': copy_percentage,
-            'max_copy_amount': max_copy_amount
+            'max_copy_amount': max_copy_amount,
+            'max_daily_trades': 10
         }
         return await self.start_copying_trader(follower_id, trader_id, settings)
     
     async def is_copying(self, follower_id: int, trader_id: int) -> bool:
         """Check if follower is copying a trader"""
+        await self._ensure_initialized()
         if follower_id not in self.copy_relationships:
             return False
         return trader_id in self.copy_relationships[follower_id]
     
     async def should_copy_trade(
         self,
         follower_id: int,
         trader_id: int,
         trade_data: Dict
     ) -> bool:
         """
         Determine if a follower should copy a trader's trade
-        
+
         Args:
             follower_id: User who is copying
             trader_id: Trader being copied
             trade_data: Trade information
-        
+
         Returns:
             True if should copy
         """
+        await self._ensure_initialized()
+
         # Check if actively copying
         if not await self.is_copying(follower_id, trader_id):
             return False
-        
+
         # Check copy settings
-        if follower_id not in self.active_copies or trader_id not in self.active_copies[follower_id]:
+        settings = self.active_copies.get(follower_id, {}).get(trader_id)
+
+        if not settings or not settings.get('enabled', False):
             return False
-        
-        settings = self.active_copies[follower_id][trader_id]
-        
+
         # Check if copy amount exceeds max
         copy_percentage = settings.get('copy_percentage', 100) / 100
         copy_amount = trade_data.get('amount_sol', 0) * copy_percentage
-        
+
         if copy_amount > settings.get('max_copy_amount', 1.0):
             return False
-        
+
         return True
     
     async def start_copying_trader(
         self,
         follower_id: int,
         trader_id: int,
         settings: Dict
     ) -> bool:
         """
         Start copying a trader's trades
-        
+
         Args:
             follower_id: User who wants to copy
             trader_id: Trader to copy
             settings: Copy settings (amount per trade, etc.)
         """
+        await self._ensure_initialized()
+
         # Validation
         if trader_id not in self.traders:
             logger.error(f"Trader {trader_id} not found")
             return False
-        
+
         if follower_id == trader_id:
             logger.error("Cannot copy yourself")
             return False
-        
-        # Initialize copy relationship
-        if follower_id not in self.copy_relationships:
-            self.copy_relationships[follower_id] = set()
-        
-        self.copy_relationships[follower_id].add(trader_id)
-        
-        # Store settings
-        self.active_copies[follower_id] = {
-            'trader_id': trader_id,
-            'amount_per_trade': settings.get('amount_per_trade', 0.1),
-            'max_daily_trades': settings.get('max_daily_trades', 10),
+
+        max_copy_amount = settings.get('max_copy_amount', settings.get('amount_per_trade', 0.1))
+        copy_percentage = settings.get('copy_percentage', 100.0)
+        max_daily_trades = settings.get('max_daily_trades', 10)
+
+        relationship, activated = await self.db.set_copy_relationship(
+            follower_id,
+            trader_id,
+            {
+                'max_copy_amount': max_copy_amount,
+                'copy_percentage': copy_percentage,
+                'max_daily_trades': max_daily_trades,
+                'label': settings.get('label', f'Copy {trader_id}')
+            }
+        )
+
+        self.copy_relationships.setdefault(follower_id, set()).add(trader_id)
+        self.active_copies.setdefault(follower_id, {})[trader_id] = {
+            'copy_percentage': relationship.copy_percentage or copy_percentage,
+            'max_copy_amount': relationship.copy_amount_sol or max_copy_amount,
+            'max_daily_trades': relationship.copy_max_daily_trades or max_daily_trades,
             'enabled': True,
-            'started_at': datetime.utcnow(),
-            'total_copied': 0,
-            'total_profit': 0.0
+            'started_at': relationship.copy_started_at or datetime.utcnow(),
+            'total_copied': relationship.copy_total_trades or 0,
+            'total_profit': relationship.copy_total_profit or 0.0
         }
-        
-        # Update follower count
-        self.traders[trader_id].followers += 1
-        
+
+        # Update follower count if this is a new active relationship
+        if activated and trader_id in self.traders:
+            self.traders[trader_id].followers += 1
+            await self.db.increment_trader_followers(trader_id, 1)
+
         logger.info(f"User {follower_id} started copying trader {trader_id}")
         return True
     
     async def stop_copying_trader(
         self,
         follower_id: int,
         trader_id: int
     ) -> bool:
         """Stop copying a trader"""
-        
+
+        await self._ensure_initialized()
+
+        was_enabled = await self.db.disable_copy_relationship(follower_id, trader_id)
+
         if follower_id in self.copy_relationships:
             self.copy_relationships[follower_id].discard(trader_id)
-        
-        if follower_id in self.active_copies:
-            self.active_copies[follower_id]['enabled'] = False
-        
-        # Update follower count
-        if trader_id in self.traders:
+            if not self.copy_relationships[follower_id]:
+                del self.copy_relationships[follower_id]
+
+        if follower_id in self.active_copies and trader_id in self.active_copies[follower_id]:
+            self.active_copies[follower_id][trader_id]['enabled'] = False
+
+        if was_enabled and trader_id in self.traders:
             self.traders[trader_id].followers = max(0, self.traders[trader_id].followers - 1)
-        
+            await self.db.increment_trader_followers(trader_id, -1)
+
         logger.info(f"User {follower_id} stopped copying trader {trader_id}")
         return True
     
     async def execute_copy_trade(
         self,
         trader_id: int,
         trade_data: Dict
     ) -> List[Dict]:
-        """
-        Execute copy trades for all followers
-        
-        Returns list of copy trades executed
-        """
-        copy_trades = []
-        
-        # Find all followers
-        followers = [
-            follower_id for follower_id, traders in self.copy_relationships.items()
-            if trader_id in traders
-        ]
-        
-        for follower_id in followers:
-            copy_settings = self.active_copies.get(follower_id, {})
-            
-            if not copy_settings.get('enabled', False):
+        """Backward-compatible wrapper for copy trade execution."""
+
+        return await self.handle_trader_execution(trader_id, trade_data)
+
+    async def handle_trader_execution(
+        self,
+        trader_id: int,
+        trade_data: Dict[str, Any]
+    ) -> List[Dict]:
+        """Propagate trader executions to eligible followers."""
+
+        await self._ensure_initialized()
+
+        trade_type = (trade_data or {}).get('trade_type') or trade_data.get('action') or 'buy'
+        trade_type = trade_type.lower()
+
+        if trade_type == 'buy':
+            return await self._execute_copy_buys(trader_id, trade_data)
+        if trade_type == 'sell':
+            return await self._execute_copy_sells(trader_id, trade_data)
+
+        logger.debug('Unsupported trade type for copy trading: %s', trade_type)
+        return []
+
+    async def _execute_copy_buys(
+        self,
+        trader_id: int,
+        trade_data: Dict[str, Any]
+    ) -> List[Dict]:
+        token_mint = trade_data.get('token_mint')
+        amount_sol = trade_data.get('amount_sol', 0.0)
+
+        if not token_mint or amount_sol <= 0:
+            return []
+
+        results: List[Dict] = []
+
+        for follower_id, traders in list(self.copy_relationships.items()):
+            if trader_id not in traders:
                 continue
-            
-            # Check daily limit
+
+            copy_settings = self.active_copies.get(follower_id, {}).get(trader_id)
+            if not copy_settings or not copy_settings.get('enabled', False):
+                continue
+
             if copy_settings.get('total_copied', 0) >= copy_settings.get('max_daily_trades', 10):
                 continue
-            
-            # Create copy trade
-            copy_trade = {
+
+            percentage = (copy_settings.get('copy_percentage', 100.0) or 0.0) / 100.0
+            base_amount = amount_sol * percentage
+            max_amount = copy_settings.get('max_copy_amount', base_amount)
+            copy_amount = min(base_amount, max_amount)
+
+            if copy_amount <= 0:
+                continue
+
+            entry = {
                 'follower_id': follower_id,
                 'trader_id': trader_id,
-                'token_mint': trade_data['token_mint'],
-                'action': trade_data['action'],
-                'amount': copy_settings['amount_per_trade'],
-                'original_trade': trade_data,
-                'timestamp': datetime.utcnow()
+                'token_mint': token_mint,
+                'token_symbol': trade_data.get('token_symbol'),
+                'amount_sol': copy_amount,
+                'timestamp': datetime.utcnow(),
+                'context': trade_data.get('context'),
             }
-            
-            copy_trades.append(copy_trade)
-            
-            # Update copy stats
-            copy_settings['total_copied'] += 1
-        
-        logger.info(f"Executing {len(copy_trades)} copy trades for trader {trader_id}")
-        return copy_trades
+
+            if not self.trade_executor:
+                entry['status'] = 'pending_executor'
+                results.append(entry)
+                continue
+
+            try:
+                execution = await self.trade_executor.execute_buy(
+                    follower_id,
+                    token_mint,
+                    copy_amount,
+                    token_symbol=trade_data.get('token_symbol'),
+                    reason='copy_trade',
+                    context='copy_trade',
+                    metadata={
+                        'copied_from': trader_id,
+                        'source_position': trade_data.get('position_id'),
+                        'origin_signature': trade_data.get('signature'),
+                    },
+                )
+            except Exception as exc:  # pragma: no cover - defensive
+                execution = {'success': False, 'error': str(exc)}
+
+            entry['execution'] = execution
+            results.append(entry)
+
+            if execution.get('success'):
+                copy_settings['total_copied'] = copy_settings.get('total_copied', 0) + 1
+                await self.db.update_copy_relationship(
+                    follower_id,
+                    trader_id,
+                    {
+                        'copy_total_trades': copy_settings['total_copied']
+                    }
+                )
+
+        if results:
+            logger.info("Executed %d copy buys for trader %s", len(results), trader_id)
+
+        return results
+
+    async def _execute_copy_sells(
+        self,
+        trader_id: int,
+        trade_data: Dict[str, Any]
+    ) -> List[Dict]:
+        token_mint = trade_data.get('token_mint')
+        if not token_mint:
+            return []
+
+        results: List[Dict] = []
+
+        for follower_id, traders in list(self.copy_relationships.items()):
+            if trader_id not in traders:
+                continue
+
+            copy_settings = self.active_copies.get(follower_id, {}).get(trader_id)
+            if not copy_settings or not copy_settings.get('enabled', False):
+                continue
+
+            entry = {
+                'follower_id': follower_id,
+                'trader_id': trader_id,
+                'token_mint': token_mint,
+                'token_symbol': trade_data.get('token_symbol'),
+                'timestamp': datetime.utcnow(),
+                'context': trade_data.get('context'),
+            }
+
+            if not self.trade_executor:
+                entry['status'] = 'pending_executor'
+                results.append(entry)
+                continue
+
+            try:
+                execution = await self.trade_executor.execute_sell(
+                    follower_id,
+                    token_mint,
+                    token_symbol=trade_data.get('token_symbol'),
+                    reason='copy_trade',
+                    context='copy_trade',
+                    metadata={
+                        'copied_from': trader_id,
+                        'source_position': trade_data.get('position_id'),
+                        'origin_signature': trade_data.get('signature'),
+                    },
+                )
+            except Exception as exc:  # pragma: no cover - defensive
+                execution = {'success': False, 'error': str(exc)}
+
+            entry['execution'] = execution
+            results.append(entry)
+
+            if execution.get('success'):
+                pnl = execution.get('pnl') or 0.0
+                copy_settings['total_copied'] = copy_settings.get('total_copied', 0) + 1
+                copy_settings['total_profit'] = copy_settings.get('total_profit', 0.0) + pnl
+                await self.db.update_copy_relationship(
+                    follower_id,
+                    trader_id,
+                    {
+                        'copy_total_trades': copy_settings['total_copied'],
+                        'copy_total_profit': copy_settings['total_profit'],
+                    }
+                )
+
+        if results:
+            logger.info("Executed %d copy sells for trader %s", len(results), trader_id)
+
+        return results
     
     async def get_leaderboard(
         self,
         tier: Optional[TraderTier] = None,
         limit: int = 50
     ) -> List[TraderProfile]:
         """
         Get trader leaderboard
-        
+
         Args:
             tier: Filter by tier
             limit: Number of traders to return
         """
+        await self._ensure_initialized()
         # Update cache if stale
         if (datetime.utcnow() - self.last_leaderboard_update).seconds > 300:
             await self._update_leaderboard()
         
         leaderboard = self.leaderboard_cache
         
         # Filter by tier if specified
         if tier:
             leaderboard = [t for t in leaderboard if t.tier == tier]
         
         return leaderboard[:limit]
     
     async def _update_leaderboard(self):
         """Update leaderboard cache"""
         sorted_traders = sorted(
             self.traders.values(),
             key=lambda t: t.reputation_score,
             reverse=True
         )
         
         self.leaderboard_cache = sorted_traders
         self.last_leaderboard_update = datetime.utcnow()
     
     async def get_trader_profile(self, trader_id: int) -> Optional[TraderProfile]:
         """Get detailed trader profile"""
+        await self._ensure_initialized()
         return self.traders.get(trader_id)
     
     async def search_traders(
         self,
         min_win_rate: float = 0.0,
         min_trades: int = 0,
         tier: Optional[TraderTier] = None
     ) -> List[TraderProfile]:
         """Search for traders matching criteria"""
-        
+
+        await self._ensure_initialized()
         results = []
         for trader in self.traders.values():
             if trader.win_rate < min_win_rate:
                 continue
             if trader.total_trades < min_trades:
                 continue
             if tier and trader.tier != tier:
                 continue
             
             results.append(trader)
         
         # Sort by reputation
         results.sort(key=lambda t: t.reputation_score, reverse=True)
         
         return results
 
 
 class StrategyMarketplace:
     """
     Marketplace for buying/selling trading strategies
     """
     
     def __init__(self, database_manager):
         self.db = database_manager
         self.strategies: Dict[str, Dict] = {}
diff --git a/src/modules/token_sniper.py b/src/modules/token_sniper.py
index 0bd72b37f9ffc93b1f53c226209d700e83863dcd..1c0dc6dbabdd3f37a204b8516b288083366c1fcd 100644
--- a/src/modules/token_sniper.py
+++ b/src/modules/token_sniper.py
@@ -1,67 +1,68 @@
 """
 ğŸ¯ ELITE AUTOMATIC TOKEN SNIPER
 Lightning-fast token launch detection with AI-powered execution
 
 ELITE FEATURES:
 - Sub-100ms token detection
 - Multi-pool monitoring (Raydium, Orca, Meteora, Pump.fun)
 - Jito-powered execution for MEV protection
 - Pre-execution safety validation
 - Liquidity event prediction
 - AI confidence scoring
 - Professional risk management
 """
 
 import asyncio
 import logging
 import hashlib
 import json
 from datetime import datetime, timedelta
-from typing import Dict, List, Optional, Set
+from typing import Any, Awaitable, Callable, Dict, List, Optional, Set
 import aiohttp
 import websockets
 from dataclasses import dataclass
 
 logger = logging.getLogger(__name__)
 
 
 @dataclass
 class SnipeSettings:
     """User's snipe configuration"""
     user_id: int
     enabled: bool = False
     max_buy_amount: float = 0.1  # SOL
     min_liquidity: float = 2000  # USD - Lower for more opportunities!
     min_ai_confidence: float = 0.65  # 65%
     max_daily_snipes: int = 10
     only_strong_buy: bool = True  # Only buy if AI says "strong_buy"
     require_social: bool = False  # Require social mentions
     
     # Limits
     daily_snipes_used: int = 0
     last_reset: datetime = None
+    last_snipe_at: datetime = None
 
 
 class PumpFunMonitor:
     """
     Monitors pump.fun for new token launches
     Uses official Pump.fun API + WebSocket for real-time detection
     """
     
     def __init__(self):
         self.session = None
         self.seen_tokens: Set[str] = set()
         self.running = False
         self.check_interval = 10  # seconds - check every 10 seconds for faster detection
         self.callbacks = []
         self.ws = None  # WebSocket connection
         self.pumpfun_api = "https://frontend-api.pump.fun"
         
     async def start(self):
         """Start monitoring"""
         if self.running:
             return
         
         self.running = True
         self.session = aiohttp.ClientSession()
         logger.info("ğŸ¯ Pump.fun monitor started")
@@ -556,342 +557,1029 @@ class PumpFunMonitor:
                             logger.debug(f"Non-JSON WebSocket message: {message}")
                         except Exception as e:
                             logger.error(f"Error processing WebSocket message: {e}")
             
             except websockets.exceptions.WebSocketException as e:
                 logger.warning(f"âš ï¸ WebSocket disconnected: {e}")
                 logger.info("ğŸ”„ Reconnecting in 10 seconds...")
                 await asyncio.sleep(10)
             except Exception as e:
                 logger.error(f"WebSocket error: {e}")
                 await asyncio.sleep(10)
 
 
 class AutoSniper:
     """
     ğŸ¯ ELITE AUTOMATIC TOKEN SNIPER
     
     Features:
     - Lightning-fast detection (<100ms)
     - Jito bundle execution
     - AI-powered analysis
     - Multi-DEX monitoring
     - Professional risk management
     """
     
-    def __init__(self, ai_manager, wallet_manager, jupiter_client, protection_system=None):
+    def __init__(
+        self,
+        ai_manager,
+        wallet_manager,
+        jupiter_client,
+        database_manager=None,
+        protection_system=None,
+        trade_executor=None,
+        sentiment_aggregator=None,
+        community_intel=None,
+    ):
         self.ai_manager = ai_manager
         self.wallet_manager = wallet_manager
         self.jupiter = jupiter_client
         self.protection = protection_system  # Elite protection system
         self.monitor = PumpFunMonitor()
         self.auto_trader = None  # Will be set when auto-trading starts
-        
+        self.trade_executor = trade_executor
+        self.sentiment_aggregator = sentiment_aggregator
+        self.community_intel = community_intel
+
         # User settings: user_id -> SnipeSettings
         self.user_settings: Dict[int, SnipeSettings] = {}
-        
+        self.db = database_manager
+        self._settings_loaded = False
+        self._state_restored = False
+
         # Elite features
         self.active_snipes: Dict[str, Dict] = {}  # snipe_id -> snipe_data
         self.snipe_results: List[Dict] = []
-        
+        self._history_limit = 200
+        self._notification_handler: Optional[
+            Callable[[str, Dict[str, Any]], Awaitable[None]]
+        ] = None
+
         # Rate limiting
         self.last_snipe = {}  # user_id -> timestamp
         self.min_snipe_interval = 60  # seconds between snipes per user
         
         logger.info("ğŸ¯ Elite Auto-Sniper initialized")
     
     def register_auto_trader(self, auto_trader):
         """Register automated trading engine for position management"""
         self.auto_trader = auto_trader
         logger.info("ğŸ¯ Auto-trader registered with sniper for position tracking")
-    
+
+    def register_notification_handler(
+        self,
+        handler: Callable[[str, Dict[str, Any]], Awaitable[None]],
+    ) -> None:
+        """Register callback for delivering user-visible sniper events."""
+
+        self._notification_handler = handler
+
+    async def _notify(self, event_type: str, payload: Dict[str, Any]) -> None:
+        """Safely dispatch notifications without breaking sniper flow."""
+
+        if not self._notification_handler:
+            return
+
+        try:
+            maybe = self._notification_handler(event_type, payload)
+            if asyncio.iscoroutine(maybe):
+                await maybe
+        except Exception:  # pragma: no cover - defensive logging
+            logger.exception("Failed to dispatch sniper notification")
+
+    def _generate_snipe_id(self, user_id: int, token_mint: str) -> str:
+        """Generate deterministic snipe identifier for persistence"""
+        base = f"{user_id}:{token_mint}:{datetime.utcnow().timestamp()}"
+        return hashlib.md5(base.encode()).hexdigest()[:12]
+
+    def _json_dumps(self, payload: Optional[Dict]) -> Optional[str]:
+        """Serialize payload to JSON while handling datetimes"""
+        if payload is None:
+            return None
+
+        def _default(obj):
+            if isinstance(obj, datetime):
+                return obj.isoformat()
+            return str(obj)
+
+        try:
+            return json.dumps(payload, default=_default)
+        except Exception:
+            logger.debug("Failed to serialize payload for snipe snapshot", exc_info=True)
+            return None
+
+    def _json_loads(self, payload: Optional[str]) -> Dict:
+        """Best-effort JSON loader"""
+        if not payload:
+            return {}
+
+        try:
+            return json.loads(payload)
+        except (TypeError, json.JSONDecodeError):
+            logger.debug("Failed to load JSON payload for snipe snapshot: %s", payload)
+            return {}
+
+    def _build_history_entry(self, run) -> Optional[Dict]:
+        """Normalize snipe run data for in-memory history cache"""
+
+        if not run:
+            return None
+
+        if isinstance(run, dict):
+            getter = run.get
+        else:
+            getter = lambda key: getattr(run, key, None)
+
+        timestamp = getter('decision_timestamp') or getter('triggered_at') or getter('completed_at')
+        if isinstance(timestamp, str):
+            try:
+                timestamp = datetime.fromisoformat(timestamp)
+            except ValueError:
+                timestamp = datetime.utcnow()
+        if not timestamp:
+            timestamp = datetime.utcnow()
+
+        status = getter('status') or ('EXECUTED' if getter('success') else 'UNKNOWN')
+        confidence = getter('ai_confidence')
+        if confidence is None:
+            confidence = getter('confidence')
+
+        recommendation = getter('ai_recommendation')
+        if recommendation is None:
+            recommendation = getter('recommendation')
+
+        context = None
+        if isinstance(run, dict):
+            context = run.get('context')
+            if not context:
+                context = self._json_loads(run.get('context_json'))
+            analysis = run.get('analysis') or self._json_loads(run.get('ai_snapshot'))
+        else:
+            context = self._json_loads(getter('context_json'))
+            analysis = self._json_loads(getter('ai_snapshot'))
+
+        entry = {
+            'snipe_id': getter('snipe_id'),
+            'user_id': getter('user_id'),
+            'token': getter('token_symbol') or getter('token') or 'UNKNOWN',
+            'token_mint': getter('token_mint'),
+            'amount': getter('amount_sol') if getter('amount_sol') is not None else getter('amount'),
+            'confidence': confidence,
+            'timestamp': timestamp,
+            'status': status,
+            'success': bool(getter('success')) if getter('success') is not None else status in {'EXECUTED', 'FILLED', 'COMPLETED'},
+            'recommendation': recommendation,
+            'analysis': analysis,
+            'context': context,
+        }
+
+        return entry
+
+    def _update_history_cache(self, entry: Optional[Dict]):
+        """Insert or refresh a snipe history entry in memory"""
+        if not entry:
+            return
+
+        snipe_id = entry.get('snipe_id')
+        if snipe_id:
+            for idx, existing in enumerate(self.snipe_results):
+                if existing.get('snipe_id') == snipe_id:
+                    self.snipe_results[idx] = entry
+                    break
+            else:
+                self.snipe_results.append(entry)
+        else:
+            self.snipe_results.append(entry)
+
+        if len(self.snipe_results) > self._history_limit:
+            self.snipe_results = self.snipe_results[-self._history_limit:]
+
+        self.snipe_results.sort(key=lambda item: item.get('timestamp') or datetime.utcnow())
+
+    def _update_history_cache_from_record(self, run):
+        entry = self._build_history_entry(run)
+        self._update_history_cache(entry)
+
+    async def _refresh_snipe_history_cache(self):
+        if not self.db:
+            return
+
+        runs = await self.db.get_recent_snipe_runs(limit=self._history_limit)
+        entries = []
+        for run in runs:
+            entry = self._build_history_entry(run)
+            if entry:
+                entries.append(entry)
+
+        entries.sort(key=lambda item: item.get('timestamp') or datetime.utcnow())
+        self.snipe_results = entries[-self._history_limit:]
+
+    async def _restore_active_snipes(self):
+        if not self.db or self._state_restored:
+            return
+
+        active_runs = await self.db.get_active_snipe_runs()
+        for run in active_runs:
+            if not getattr(run, 'is_manual', False):
+                continue
+
+            if run.snipe_id in self.active_snipes:
+                continue
+
+            context = self._json_loads(getattr(run, 'context_json', None))
+            state = {
+                'user_id': run.user_id,
+                'token_mint': run.token_mint,
+                'amount_sol': run.amount_sol,
+                'status': run.status or 'MONITORING',
+                'created_at': run.decision_timestamp or datetime.utcnow(),
+                'checks_passed': context.get('checks_passed', False)
+            }
+
+            for key, value in context.items():
+                state.setdefault(key, value)
+
+            self.active_snipes[run.snipe_id] = state
+
+            if state['status'] == 'MONITORING':
+                asyncio.create_task(self._monitor_manual_snipe(run.snipe_id))
+
+        self._state_restored = True
+
+    async def _persist_manual_snipe_state(
+        self,
+        snipe_id: str,
+        user_id: int,
+        token_mint: str,
+        amount: float
+    ):
+        context = {
+            'checks_passed': False,
+            'source': 'MANUAL'
+        }
+
+        if not self.db:
+            entry = {
+                'snipe_id': snipe_id,
+                'user_id': user_id,
+                'token': 'UNKNOWN',
+                'token_mint': token_mint,
+                'amount': amount,
+                'timestamp': datetime.utcnow(),
+                'status': 'MONITORING',
+                'success': False,
+                'context': context
+            }
+            self._update_history_cache(entry)
+            return
+
+        record = {
+            'snipe_id': snipe_id,
+            'user_id': user_id,
+            'token_mint': token_mint,
+            'token_symbol': 'UNKNOWN',
+            'amount_sol': amount,
+            'status': 'MONITORING',
+            'decision_timestamp': datetime.utcnow(),
+            'is_manual': True,
+            'context_json': self._json_dumps(context)
+        }
+
+        run = await self.db.upsert_snipe_run(record)
+        self._update_history_cache_from_record(run)
+
+    async def _record_ai_decision(
+        self,
+        snipe_id: str,
+        user_id: int,
+        token_info: Dict,
+        settings: SnipeSettings,
+        token_data: Dict,
+        ai_analysis: Dict
+    ):
+        snapshot = {
+            'token_data': token_data,
+            'analysis': ai_analysis
+        }
+
+        entry = {
+            'snipe_id': snipe_id,
+            'user_id': user_id,
+            'token': token_info.get('symbol', 'UNKNOWN'),
+            'token_mint': token_info['address'],
+            'amount': settings.max_buy_amount,
+            'confidence': ai_analysis.get('confidence'),
+            'timestamp': datetime.utcnow(),
+            'status': 'ANALYZED',
+            'success': False,
+            'recommendation': ai_analysis.get('action'),
+            'analysis': snapshot,
+            'context': {'source': 'AUTO'}
+        }
+
+        if not self.db:
+            self._update_history_cache(entry)
+            return
+
+        record = {
+            'snipe_id': snipe_id,
+            'user_id': user_id,
+            'token_mint': token_info['address'],
+            'token_symbol': token_info.get('symbol', 'UNKNOWN'),
+            'amount_sol': settings.max_buy_amount,
+            'status': 'ANALYZED',
+            'ai_confidence': ai_analysis.get('confidence'),
+            'ai_recommendation': ai_analysis.get('action'),
+            'ai_snapshot': self._json_dumps(snapshot),
+            'decision_timestamp': datetime.utcnow(),
+            'is_manual': False,
+            'context_json': self._json_dumps({'source': 'AUTO'})
+        }
+
+        run = await self.db.upsert_snipe_run(record)
+        self._update_history_cache_from_record(run)
+
+    async def _update_snipe_record(
+        self,
+        snipe_id: str,
+        *,
+        status: Optional[str] = None,
+        confidence: Optional[float] = None,
+        recommendation: Optional[str] = None,
+        triggered_at: Optional[datetime] = None,
+        completed_at: Optional[datetime] = None,
+        context: Optional[Dict] = None,
+        analysis: Optional[Dict] = None
+    ):
+        if self.db:
+            updates = {}
+            if status is not None:
+                updates['status'] = status
+            if confidence is not None:
+                updates['ai_confidence'] = confidence
+            if recommendation is not None:
+                updates['ai_recommendation'] = recommendation
+            if triggered_at is not None:
+                updates['triggered_at'] = triggered_at
+            if completed_at is not None:
+                updates['completed_at'] = completed_at
+            if context is not None:
+                updates['context_json'] = self._json_dumps(context)
+            if analysis is not None:
+                updates['ai_snapshot'] = self._json_dumps(analysis)
+
+            run = await self.db.update_snipe_run(snipe_id, updates)
+            if run:
+                self._update_history_cache_from_record(run)
+            return
+
+        entry = next((item for item in self.snipe_results if item.get('snipe_id') == snipe_id), None)
+        if not entry:
+            entry = {
+                'snipe_id': snipe_id,
+                'timestamp': datetime.utcnow(),
+            }
+
+        if status is not None:
+            entry['status'] = status
+            entry['success'] = status in {'EXECUTED', 'FILLED', 'COMPLETED'}
+        if confidence is not None:
+            entry['confidence'] = confidence
+        if recommendation is not None:
+            entry['recommendation'] = recommendation
+        if triggered_at is not None:
+            entry['triggered_at'] = triggered_at
+        if completed_at is not None:
+            entry['completed_at'] = completed_at
+        if context is not None:
+            entry['context'] = context
+        if analysis is not None:
+            entry['analysis'] = analysis
+
+        self._update_history_cache(entry)
+    async def load_persistent_settings(self) -> Dict[int, SnipeSettings]:
+        """Load sniper settings from the database"""
+        if not self.db:
+            logger.warning("ğŸ¯ No database manager provided; sniper settings persistence disabled")
+            return self.user_settings
+
+        if self._settings_loaded:
+            return self.user_settings
+
+        records = await self.db.get_all_user_settings()
+
+        for record in records:
+            settings = self._settings_from_record(record)
+            self.user_settings[record.user_id] = settings
+            if settings.last_snipe_at:
+                self.last_snipe[record.user_id] = settings.last_snipe_at.timestamp()
+
+        await self._restore_active_snipes()
+        await self._refresh_snipe_history_cache()
+
+        self._settings_loaded = True
+        logger.info("ğŸ¯ Loaded %d sniper profiles from database", len(self.user_settings))
+        return self.user_settings
+
+    def _settings_from_record(self, record) -> SnipeSettings:
+        """Convert database record into runtime sniper settings"""
+        return SnipeSettings(
+            user_id=record.user_id,
+            enabled=bool(record.snipe_enabled),
+            max_buy_amount=record.snipe_max_amount or 0.1,
+            min_liquidity=record.snipe_min_liquidity or 10000.0,
+            min_ai_confidence=record.snipe_min_confidence or 0.65,
+            max_daily_snipes=record.snipe_max_daily or 10,
+            only_strong_buy=bool(record.snipe_only_strong_buy),
+            daily_snipes_used=record.snipe_daily_used or 0,
+            last_reset=record.snipe_last_reset,
+            last_snipe_at=record.snipe_last_timestamp
+        )
+
+    async def _persist_user_settings(self, settings: SnipeSettings):
+        """Persist sniper settings for a user"""
+        if not self.db:
+            return
+
+        await self.db.update_user_settings(settings.user_id, {
+            'snipe_enabled': settings.enabled,
+            'snipe_max_amount': settings.max_buy_amount,
+            'snipe_min_liquidity': settings.min_liquidity,
+            'snipe_min_confidence': settings.min_ai_confidence,
+            'snipe_max_daily': settings.max_daily_snipes,
+            'snipe_only_strong_buy': settings.only_strong_buy,
+            'snipe_daily_used': settings.daily_snipes_used,
+            'snipe_last_reset': settings.last_reset or datetime.utcnow(),
+            'snipe_last_timestamp': settings.last_snipe_at
+        })
+
     async def start(self):
         """Start the sniper"""
         await self.monitor.start()
         self.monitor.on_new_token(self._on_new_token_detected)
         logger.info("ğŸ¯ Auto-sniper started and monitoring")
     
     async def stop(self):
         """Stop the sniper"""
         await self.monitor.stop()
         logger.info("ğŸ¯ Auto-sniper stopped")
     
-    def enable_snipe(self, user_id: int, settings: Dict = None):
+    async def enable_snipe(self, user_id: int, settings: Dict = None):
         """Enable auto-snipe for a user"""
-        if user_id not in self.user_settings:
-            self.user_settings[user_id] = SnipeSettings(
+        if self.db and not self._settings_loaded:
+            await self.load_persistent_settings()
+
+        user_settings = self.user_settings.get(user_id)
+
+        if not user_settings and self.db:
+            record = await self.db.get_user_settings(user_id)
+            if record:
+                user_settings = self._settings_from_record(record)
+
+        if not user_settings:
+            user_settings = SnipeSettings(
                 user_id=user_id,
                 last_reset=datetime.now()
             )
-        
-        self.user_settings[user_id].enabled = True
-        
-        # Update settings if provided
+
+        user_settings.enabled = True
+
         if settings:
             for key, value in settings.items():
-                if hasattr(self.user_settings[user_id], key):
-                    setattr(self.user_settings[user_id], key, value)
-        
+                if hasattr(user_settings, key):
+                    setattr(user_settings, key, value)
+
+        if not user_settings.last_reset:
+            user_settings.last_reset = datetime.now()
+
+        self.user_settings[user_id] = user_settings
+        if user_settings.last_snipe_at:
+            self.last_snipe[user_id] = user_settings.last_snipe_at.timestamp()
+        else:
+            self.last_snipe.pop(user_id, None)
+        await self._persist_user_settings(user_settings)
+
         logger.info(f"ğŸ¯ Auto-snipe enabled for user {user_id}")
-        return self.user_settings[user_id]
-    
-    def disable_snipe(self, user_id: int):
+        return user_settings
+
+    async def disable_snipe(self, user_id: int):
         """Disable auto-snipe for a user"""
-        if user_id in self.user_settings:
-            self.user_settings[user_id].enabled = False
-            logger.info(f"ğŸ¯ Auto-snipe disabled for user {user_id}")
-    
+        if self.db and not self._settings_loaded:
+            await self.load_persistent_settings()
+
+        user_settings = self.user_settings.get(user_id)
+
+        if not user_settings and self.db:
+            record = await self.db.get_user_settings(user_id)
+            if record:
+                user_settings = self._settings_from_record(record)
+
+        if not user_settings:
+            return
+
+        user_settings.enabled = False
+        self.user_settings[user_id] = user_settings
+        await self._persist_user_settings(user_settings)
+        logger.info(f"ğŸ¯ Auto-snipe disabled for user {user_id}")
+
     def get_settings(self, user_id: int) -> Optional[SnipeSettings]:
         """Get user's snipe settings"""
         return self.user_settings.get(user_id)
     
     async def _on_new_token_detected(self, token_info: Dict):
         """Called when a new token is detected"""
         logger.info(f"ğŸ¯ Processing new token: {token_info['symbol']}")
         
         # Check which users have auto-snipe enabled
         enabled_users = [
             user_id for user_id, settings in self.user_settings.items()
             if settings.enabled
         ]
         
         if not enabled_users:
             logger.debug("No users with auto-snipe enabled")
             return
         
         logger.info(f"ğŸ¯ {len(enabled_users)} users with auto-snipe enabled")
         
         # Analyze token for each enabled user
         for user_id in enabled_users:
             try:
                 await self._process_snipe_for_user(user_id, token_info)
             except Exception as e:
                 logger.error(f"Error processing snipe for user {user_id}: {e}")
     
     async def _process_snipe_for_user(self, user_id: int, token_info: Dict):
         """
         ğŸ¯ ELITE SNIPE PROCESSING
         
         Includes:
         - 6-layer safety checks
         - AI confidence validation
         - Jito-powered execution
         - Real-time notifications
         """
-        settings = self.user_settings[user_id]
-        
+        settings = self.user_settings.get(user_id)
+
+        if not settings:
+            logger.debug(f"No sniper settings configured for user {user_id}")
+            return
+
         # Reset daily counter if needed
         if settings.last_reset and (datetime.now() - settings.last_reset).days >= 1:
             settings.daily_snipes_used = 0
             settings.last_reset = datetime.now()
-        
+            await self._persist_user_settings(settings)
+
         # Check daily limit
         if settings.daily_snipes_used >= settings.max_daily_snipes:
             logger.debug(f"User {user_id} hit daily snipe limit")
             return
         
         # Check rate limiting
         last_snipe_time = self.last_snipe.get(user_id, 0)
         if datetime.now().timestamp() - last_snipe_time < self.min_snipe_interval:
             logger.debug(f"User {user_id} rate limited")
             return
         
         # Check minimum liquidity
         if token_info['liquidity_usd'] < settings.min_liquidity:
             logger.debug(f"Token liquidity too low: ${token_info['liquidity_usd']:.0f} < ${settings.min_liquidity:.0f}")
             return
         
         # Get user balance
         balance = await self.wallet_manager.get_user_balance(user_id)
         if balance < settings.max_buy_amount:
             logger.debug(f"User {user_id} insufficient balance: {balance:.4f} < {settings.max_buy_amount:.4f}")
             return
         
         # ğŸ›¡ï¸ ELITE FEATURE: Run comprehensive safety checks
         if self.protection:
             logger.info(f"ğŸ›¡ï¸ Running elite protection checks for {token_info['symbol']}...")
             safety_result = await self.protection.comprehensive_token_check(token_info['address'])
             
             if not safety_result['is_safe'] or safety_result['risk_score'] > 70:
                 logger.warning(f"â›” Token failed elite safety checks (risk: {safety_result['risk_score']:.1f}/100)")
                 return
         
+        sentiment_snapshot = None
+        community_signal = None
+
+        if self.sentiment_aggregator:
+            try:
+                sentiment_snapshot = await self.sentiment_aggregator.analyze_token_sentiment(
+                    token_info['address'],
+                    token_info.get('symbol', 'TOKEN')
+                )
+            except Exception as exc:
+                logger.debug("Failed to enrich sniper signal with social sentiment: %s", exc)
+                sentiment_snapshot = None
+
+        if self.community_intel:
+            try:
+                community_signal = await self.community_intel.get_community_signal(token_info['address'])
+            except Exception as exc:
+                logger.debug("Failed to fetch community intelligence: %s", exc)
+                community_signal = None
+
+        if settings.require_social:
+            total_mentions = 0
+            if sentiment_snapshot:
+                total_mentions = sentiment_snapshot.get('total_mentions', 0) or 0
+            if total_mentions == 0:
+                logger.debug("Skipping snipe due to missing social momentum for user %s", user_id)
+                return
+
         # Prepare token data for AI analysis
         token_data = {
             'address': token_info['address'],
             'symbol': token_info['symbol'],
             'liquidity_usd': token_info['liquidity_usd'],
             'volume_24h': 0,  # Too new
             'price_change_1h': 0,
             'price_change_24h': 0,
             'holder_count': 50,  # Estimate
             'top_10_holder_percentage': 40,  # Assume concentrated
             'transaction_count_1h': 10,  # Early
             'buy_sell_ratio': 1.5,  # Assume buying
             'market_cap': token_info['liquidity_usd'] * 2,
             'age_hours': 0.1,  # Very new
             'social_mentions': 0,  # Too new
-            'sentiment_score': 50  # Neutral
+            'sentiment_score': 50,  # Neutral
+            'social_score': 50,
+            'community_score': 0,
         }
-        
+
+        if sentiment_snapshot:
+            token_data['sentiment_score'] = sentiment_snapshot.get('sentiment_score', token_data['sentiment_score'])
+            token_data['social_mentions'] = sentiment_snapshot.get('total_mentions', token_data['social_mentions'])
+            token_data['social_score'] = sentiment_snapshot.get('social_score', token_data['social_score'])
+
+        if community_signal:
+            token_data['community_score'] = community_signal.get('community_score', token_data['community_score'])
+
+        snipe_id = self._generate_snipe_id(user_id, token_info['address'])
+
         # Run AI analysis
         logger.info(f"ğŸ¯ Running AI analysis for user {user_id} on {token_info['symbol']}")
-        ai_analysis = await self.ai_manager.analyze_opportunity(token_data, balance)
-        
+        ai_analysis = await self.ai_manager.analyze_opportunity(
+            token_data,
+            balance,
+            sentiment_snapshot=sentiment_snapshot,
+            community_signal=community_signal
+        )
+
         # Check AI recommendation
         action = ai_analysis['action']
         confidence = ai_analysis['confidence']
-        
+
         logger.info(f"ğŸ¯ AI says: {action} with {confidence:.1%} confidence")
-        
+
+        await self._record_ai_decision(
+            snipe_id,
+            user_id,
+            token_info,
+            settings,
+            token_data,
+            ai_analysis
+        )
+
         # Check if meets criteria
         if settings.only_strong_buy and action != 'strong_buy':
             logger.debug(f"Not strong_buy: {action}")
+            await self._update_snipe_record(
+                snipe_id,
+                status='SKIPPED',
+                confidence=confidence,
+                recommendation=action,
+                completed_at=datetime.utcnow(),
+                context={
+                    'reason': 'not_strong_buy',
+                    'required_action': 'strong_buy',
+                    'actual_action': action,
+                    'source': 'AUTO'
+                }
+            )
             return
-        
+
         if confidence < settings.min_ai_confidence:
             logger.debug(f"Confidence too low: {confidence:.1%} < {settings.min_ai_confidence:.1%}")
+            await self._update_snipe_record(
+                snipe_id,
+                status='SKIPPED',
+                confidence=confidence,
+                recommendation=action,
+                completed_at=datetime.utcnow(),
+                context={
+                    'reason': 'confidence_below_threshold',
+                    'required': settings.min_ai_confidence,
+                    'confidence': confidence,
+                    'source': 'AUTO'
+                }
+            )
             return
-        
+
         # Execute elite snipe with Jito protection!
         logger.info(f"ğŸ¯ EXECUTING ELITE SNIPE for user {user_id}: {token_info['symbol']}")
-        
+
         try:
             # Get user's keypair
             user_keypair = await self.wallet_manager.get_user_keypair(user_id)
             if not user_keypair:
                 logger.error(f"Could not get keypair for user {user_id}")
+                await self._update_snipe_record(
+                    snipe_id,
+                    status='FAILED',
+                    confidence=confidence,
+                    recommendation=action,
+                    completed_at=datetime.utcnow(),
+                    context={'error': 'missing_keypair', 'source': 'AUTO'}
+                )
+                await self._notify(
+                    'snipe_failed',
+                    {
+                        'user_id': user_id,
+                        'token_mint': token_info.get('address'),
+                        'token_symbol': token_info.get('symbol'),
+                        'amount_sol': settings.max_buy_amount,
+                        'confidence': confidence,
+                        'snipe_id': snipe_id,
+                        'error': 'Wallet unavailable for sniping',
+                        'source': 'AUTO',
+                    },
+                )
                 return
-            
-            # Execute swap with Jito bundle for MEV protection
+
             amount_lamports = int(settings.max_buy_amount * 1e9)
             SOL_MINT = "So11111111111111111111111111111111111111112"
-            
-            # ğŸš€ ELITE FEATURE: Execute with Jito bundle
-            result = await self.jupiter.execute_swap_with_jito(
-                input_mint=SOL_MINT,
-                output_mint=token_info['address'],
-                amount=amount_lamports,
-                keypair=user_keypair,
-                slippage_bps=100,  # 1% slippage for snipes
-                tip_amount_lamports=100000,  # 0.0001 SOL tip
-                priority_fee_lamports=2000000  # High priority
+
+            trigger_time = datetime.utcnow()
+            await self._update_snipe_record(
+                snipe_id,
+                status='EXECUTING',
+                confidence=confidence,
+                recommendation=action,
+                triggered_at=trigger_time,
+                context={'source': 'AUTO'}
             )
-            
+
+            execution_metadata = {
+                'snipe_id': snipe_id,
+                'ai_confidence': confidence,
+                'token_symbol': token_info.get('symbol'),
+                'source': 'AUTO',
+            }
+
+            if self.trade_executor:
+                result = await self.trade_executor.execute_buy(
+                    user_id,
+                    token_info['address'],
+                    settings.max_buy_amount,
+                    token_symbol=token_info.get('symbol'),
+                    reason='auto_sniper',
+                    context='sniper_auto',
+                    execution_mode='jito',
+                    priority_fee_lamports=2_000_000,
+                    tip_lamports=100_000,
+                    metadata=execution_metadata,
+                )
+            else:
+                result = await self.jupiter.execute_swap_with_jito(
+                    input_mint=SOL_MINT,
+                    output_mint=token_info['address'],
+                    amount=amount_lamports,
+                    keypair=user_keypair,
+                    slippage_bps=100,
+                    tip_amount_lamports=100000,
+                    priority_fee_lamports=2000000,
+                )
+
             if result and result.get('success'):
                 logger.info(f"âœ… ELITE SNIPE EXECUTED!")
                 logger.info(f"   Token: {token_info['symbol']}")
                 logger.info(f"   Amount: {settings.max_buy_amount:.4f} SOL")
                 logger.info(f"   AI Confidence: {confidence:.1%}")
                 logger.info(f"   Protection: Jito Bundle")
                 logger.info(f"   Bundle ID: {result.get('bundle_id', 'N/A')}")
-                
+
                 # Update counters
                 settings.daily_snipes_used += 1
-                self.last_snipe[user_id] = datetime.now().timestamp()
-                
-                # Record snipe result
-                self.snipe_results.append({
-                    'user_id': user_id,
-                    'token': token_info['symbol'],
-                    'token_mint': token_info['address'],
-                    'amount': settings.max_buy_amount,
-                    'confidence': confidence,
-                    'timestamp': datetime.now(),
-                    'success': True
-                })
-                
+                now_ts = datetime.utcnow()
+                settings.last_snipe_at = now_ts
+                self.last_snipe[user_id] = now_ts.timestamp()
+                await self._persist_user_settings(settings)
+
+                tokens_received = result.get('amount_tokens') or 0.0
+                price = result.get('price') or (
+                    settings.max_buy_amount / tokens_received if tokens_received else None
+                )
+
+                await self._update_snipe_record(
+                    snipe_id,
+                    status='EXECUTED',
+                    confidence=confidence,
+                    recommendation=action,
+                    completed_at=now_ts,
+                    context={
+                        'bundle_id': result.get('bundle_id'),
+                        'amount_tokens': tokens_received,
+                        'price': price,
+                        'position_id': result.get('position_id'),
+                        'signature': result.get('signature'),
+                        'source': 'AUTO'
+                    }
+                )
+
+                await self._notify(
+                    'snipe_executed',
+                    {
+                        'user_id': user_id,
+                        'token_mint': token_info.get('address'),
+                        'token_symbol': token_info.get('symbol'),
+                        'amount_sol': settings.max_buy_amount,
+                        'amount_tokens': tokens_received,
+                        'confidence': confidence,
+                        'signature': result.get('signature'),
+                        'bundle_id': result.get('bundle_id'),
+                        'snipe_id': snipe_id,
+                        'price': price,
+                        'source': 'AUTO',
+                    },
+                )
+
                 # ğŸ¯ Register position with auto-trader for stop loss/take profit tracking
                 if self.auto_trader and self.auto_trader.is_running:
-                    entry_price = result.get('output_amount', 0) / settings.max_buy_amount if settings.max_buy_amount > 0 else 0
+                    entry_price = price or 0
                     self.auto_trader.active_positions[token_info['address']] = {
                         'token_mint': token_info['address'],
                         'token_symbol': token_info['symbol'],
                         'entry_price': entry_price,
                         'amount': settings.max_buy_amount,
                         'entry_time': datetime.now(),
                         'source': 'AUTO_SNIPE'
                     }
                     logger.info(f"ğŸ“Š Position registered for auto-management (Stop Loss: 15%, Take Profit: 50%)")
                 
-                # TODO: Send notification to user via Telegram
-                
                 return {
                     'success': True,
                     'token': token_info['symbol'],
                     'amount': settings.max_buy_amount,
                     'confidence': confidence,
                     'bundle_id': result.get('bundle_id')
                 }
             else:
                 logger.error(f"âŒ Snipe failed: {result.get('error', 'Unknown error')}")
+                await self._update_snipe_record(
+                    snipe_id,
+                    status='FAILED',
+                    confidence=confidence,
+                    recommendation=action,
+                    completed_at=datetime.utcnow(),
+                    context={
+                        'error': result.get('error', 'Unknown error'),
+                        'source': 'AUTO'
+                    }
+                )
+                await self._notify(
+                    'snipe_failed',
+                    {
+                        'user_id': user_id,
+                        'token_mint': token_info.get('address'),
+                        'token_symbol': token_info.get('symbol'),
+                        'amount_sol': settings.max_buy_amount,
+                        'confidence': confidence,
+                        'snipe_id': snipe_id,
+                        'error': result.get('error', 'Unknown error'),
+                        'source': 'AUTO',
+                    },
+                )
                 return {
                     'success': False,
                     'error': result.get('error', 'Unknown error')
                 }
-        
+
         except Exception as e:
             logger.error(f"Snipe execution error: {e}")
+            await self._update_snipe_record(
+                snipe_id,
+                status='FAILED',
+                confidence=confidence,
+                recommendation=action,
+                completed_at=datetime.utcnow(),
+                context={'error': str(e), 'source': 'AUTO'}
+            )
+            await self._notify(
+                'snipe_failed',
+                {
+                    'user_id': user_id,
+                    'token_mint': token_info.get('address'),
+                    'token_symbol': token_info.get('symbol'),
+                    'amount_sol': settings.max_buy_amount,
+                    'confidence': confidence,
+                    'snipe_id': snipe_id,
+                    'error': str(e),
+                    'source': 'AUTO',
+                },
+            )
             return {
                 'success': False,
                 'error': str(e)
             }
     
     def setup_manual_snipe(self, user_id: int, token_mint: str, amount: float) -> Dict:
         """
         ğŸ¯ ELITE FEATURE: Setup manual snipe for when liquidity is added
         
         Returns snipe ID and status
         """
         snipe_id = hashlib.md5(f"{token_mint}{datetime.now()}".encode()).hexdigest()[:8]
         
         self.active_snipes[snipe_id] = {
             'user_id': user_id,
             'token_mint': token_mint,
             'amount_sol': amount,
             'status': 'MONITORING',
             'created_at': datetime.now(),
             'checks_passed': False
         }
-        
+
+        try:
+            asyncio.create_task(
+                self._persist_manual_snipe_state(snipe_id, user_id, token_mint, amount)
+            )
+        except RuntimeError:
+            if self.db:
+                asyncio.run(
+                    self._persist_manual_snipe_state(snipe_id, user_id, token_mint, amount)
+                )
+            else:
+                # Fallback to synchronous cache update when no loop is running
+                self._update_history_cache({
+                    'snipe_id': snipe_id,
+                    'user_id': user_id,
+                    'token': 'UNKNOWN',
+                    'token_mint': token_mint,
+                    'amount': amount,
+                    'timestamp': datetime.utcnow(),
+                    'status': 'MONITORING',
+                    'success': False,
+                    'context': {'checks_passed': False, 'source': 'MANUAL'}
+                })
+
         logger.info(f"ğŸ¯ Manual snipe {snipe_id} setup for {token_mint[:8]}... with {amount} SOL")
-        
+
         # Start monitoring in background
-        asyncio.create_task(self._monitor_manual_snipe(snipe_id))
-        
+        try:
+            asyncio.create_task(self._monitor_manual_snipe(snipe_id))
+        except RuntimeError:
+            logger.warning("Unable to schedule manual snipe monitor without an active event loop")
+
         return {
             'snipe_id': snipe_id,
             'status': 'ACTIVE',
             'message': 'Monitoring for liquidity addition...'
         }
     
     async def _monitor_manual_snipe(self, snipe_id: str):
         """Monitor for liquidity and execute manual snipe"""
         snipe = self.active_snipes[snipe_id]
         token_mint = snipe['token_mint']
         
         max_attempts = 600  # 10 minutes
         check_interval = 1.0  # 1 second
         
         for attempt in range(max_attempts):
             try:
                 # Check if liquidity exists (simplified check)
                 # In production, would actually check DEX pools
                 
                 await asyncio.sleep(check_interval)
                 
             except Exception as e:
                 logger.error(f"Error monitoring snipe {snipe_id}: {e}")
         
         # Timeout
         snipe['status'] = 'TIMEOUT'
         logger.warning(f"â±ï¸ Manual snipe {snipe_id} timed out")
+
+        await self._update_snipe_record(
+            snipe_id,
+            status='TIMEOUT',
+            completed_at=datetime.utcnow(),
+            context={
+                'checks_passed': snipe.get('checks_passed', False),
+                'source': 'MANUAL',
+                'timeout': True
+            }
+        )
+
+        self.active_snipes.pop(snipe_id, None)
     
     def get_snipe_history(self, user_id: int = None, limit: int = 20) -> List[Dict]:
         """Get snipe history for user or all"""
         if user_id:
             results = [r for r in self.snipe_results if r['user_id'] == user_id]
         else:
             results = self.snipe_results
         
         return results[-limit:]
 
diff --git a/src/modules/trade_execution.py b/src/modules/trade_execution.py
new file mode 100644
index 0000000000000000000000000000000000000000..6380c14b19afcc301fc0cfc2ba864f51276714ac
--- /dev/null
+++ b/src/modules/trade_execution.py
@@ -0,0 +1,631 @@
+"""Centralized trade execution with risk checks and persistence."""
+
+from __future__ import annotations
+
+import json
+import logging
+from datetime import datetime
+from types import SimpleNamespace
+from typing import Any, Dict, Optional
+
+from src.modules.database import DatabaseManager
+from src.modules.wallet_manager import UserWalletManager
+from src.modules.jupiter_client import JupiterClient
+from src.modules.elite_protection import EliteProtectionSystem
+from src.modules.monitoring import BotMonitor
+from src.modules.social_trading import (
+    SocialTradingMarketplace,
+    RewardSystem,
+    REWARD_POINTS,
+)
+
+logger = logging.getLogger(__name__)
+
+
+class TradeExecutionError(Exception):
+    """Raised when a trade cannot be executed."""
+
+
+class TradeExecutionService:
+    """Handles manual and automated trade execution with risk controls."""
+
+    SOL_MINT = "So11111111111111111111111111111111111111112"
+
+    def __init__(
+        self,
+        db: DatabaseManager,
+        wallet_manager: UserWalletManager,
+        jupiter: JupiterClient,
+        protection: Optional[EliteProtectionSystem] = None,
+        monitor: Optional[BotMonitor] = None,
+        social_marketplace: Optional[SocialTradingMarketplace] = None,
+        rewards: Optional[RewardSystem] = None,
+        default_user_settings: Optional[Dict[str, Any]] = None,
+    ) -> None:
+        self.db = db
+        self.wallet_manager = wallet_manager
+        self.jupiter = jupiter
+        self.protection = protection
+        self.monitor = monitor
+        self.social_marketplace = social_marketplace
+        self.rewards = rewards
+        self._default_user_settings = dict(default_user_settings) if default_user_settings else None
+
+    async def execute_buy(
+        self,
+        user_id: int,
+        token_mint: str,
+        amount_sol: float,
+        *,
+        token_symbol: Optional[str] = None,
+        reason: str = "manual",
+        context: str = "manual",
+        execution_mode: str = "standard",
+        priority_fee_lamports: Optional[int] = None,
+        tip_lamports: Optional[int] = None,
+        metadata: Optional[Dict[str, Any]] = None,
+    ) -> Dict:
+        """Execute a SOL -> token swap with safety and persistence."""
+
+        if amount_sol <= 0:
+            return {"success": False, "error": "Trade amount must be positive"}
+
+        settings = await self._get_user_settings(user_id)
+
+        if amount_sol > settings.max_trade_size_sol:
+            return {
+                "success": False,
+                "error": (
+                    f"Trade exceeds max size ({settings.max_trade_size_sol:.2f} SOL)."
+                ),
+            }
+
+        daily_pnl = await self.db.get_daily_pnl(user_id)
+        if daily_pnl <= -settings.daily_loss_limit_sol:
+            return {
+                "success": False,
+                "error": "Daily loss limit reached. Trading paused until tomorrow.",
+            }
+
+        balance = await self.wallet_manager.get_user_balance(user_id)
+        if balance < amount_sol:
+            return {
+                "success": False,
+                "error": (
+                    f"Insufficient balance. Available {balance:.4f} SOL, required {amount_sol:.4f} SOL."
+                ),
+            }
+
+        if self.protection and settings.check_honeypots:
+            safety = await self.protection.comprehensive_token_check(token_mint)
+            if not safety.get("is_safe", False):
+                return {
+                    "success": False,
+                    "error": "Token failed safety checks. Trade blocked.",
+                    "details": safety,
+                }
+            liquidity = safety.get("details", {}).get("liquidity_usd", 0)
+            if liquidity < settings.min_liquidity_usd:
+                return {
+                    "success": False,
+                    "error": (
+                        "Token liquidity below your configured minimum."
+                    ),
+                }
+
+        keypair = await self.wallet_manager.get_user_keypair(user_id)
+        if not keypair:
+            return {"success": False, "error": "Wallet unavailable for trading"}
+
+        slippage_bps = self._slippage_to_bps(settings.slippage_percentage)
+        amount_lamports = int(amount_sol * 1e9)
+
+        # Capture quote metadata to derive token decimals when available
+        quote = None
+        if execution_mode != "jito":
+            quote = await self.jupiter.get_quote(
+                self.SOL_MINT,
+                token_mint,
+                amount_lamports,
+                slippage_bps=slippage_bps,
+            )
+
+        if execution_mode == "jito":
+            result = await self.jupiter.execute_swap_with_jito(
+                input_mint=self.SOL_MINT,
+                output_mint=token_mint,
+                amount=amount_lamports,
+                keypair=keypair,
+                slippage_bps=slippage_bps,
+                tip_amount_lamports=tip_lamports or 100_000,
+                priority_fee_lamports=priority_fee_lamports or 1_000_000,
+            )
+        else:
+            result = await self.jupiter.execute_swap(
+                self.SOL_MINT,
+                token_mint,
+                amount_lamports,
+                keypair,
+                slippage_bps=slippage_bps,
+            )
+
+        if not result.get("success"):
+            await self._record_failed_trade(result.get("error", "Unknown error"))
+            await self._persist_trade_record(
+                user_id,
+                token_mint,
+                token_symbol,
+                amount_sol,
+                0.0,
+                "buy",
+                success=False,
+                error_message=result.get("error"),
+                context=context,
+                metadata=metadata,
+            )
+            return {"success": False, "error": result.get("error", "Swap failed")}
+
+        quote_payload = result.get("quote") if isinstance(result, dict) else None
+        token_decimals = self._extract_decimals(quote_payload or quote)
+        output_raw = int(
+            result.get("output_amount")
+            or (quote_payload or {}).get("outAmount", 0)
+        )
+        tokens_received = self._convert_amount(output_raw, token_decimals)
+        execution_price = self._calculate_price(amount_sol, tokens_received)
+        signature = result.get("signature")
+        bundle_id = result.get("bundle_id") if isinstance(result, dict) else None
+
+        position_id = signature or self._build_position_id(user_id, token_mint)
+
+        trade_metadata = metadata or {}
+        if bundle_id:
+            trade_metadata = {**trade_metadata, "bundle_id": bundle_id}
+
+        await self._persist_trade_record(
+            user_id,
+            token_mint,
+            token_symbol,
+            amount_sol,
+            tokens_received,
+            "buy",
+            signature=signature,
+            price=execution_price,
+            slippage=settings.slippage_percentage,
+            price_impact=result.get("price_impact"),
+            position_id=position_id,
+            context=context,
+            metadata=trade_metadata,
+        )
+
+        await self.db.open_position(
+            {
+                "user_id": user_id,
+                "position_id": position_id,
+                "token_mint": token_mint,
+                "token_symbol": token_symbol or token_mint[:6],
+                "token_decimals": token_decimals,
+                "entry_price": execution_price or 0.0,
+                "entry_amount_sol": amount_sol,
+                "entry_amount_tokens": tokens_received,
+                "entry_amount_raw": output_raw,
+                "entry_signature": signature,
+                "entry_timestamp": datetime.utcnow(),
+                "remaining_amount_sol": amount_sol,
+                "remaining_amount_tokens": tokens_received,
+                "remaining_amount_raw": output_raw,
+                "realized_pnl_sol": 0.0,
+                "realized_amount_sol": 0.0,
+
+                "source": context,
+                "metadata_json": self._serialize_metadata(trade_metadata),
+                "stop_loss_percentage": (
+                    settings.default_stop_loss_percentage if settings.use_stop_loss else None
+                ),
+                "take_profit_percentage": (
+                    settings.default_take_profit_percentage
+                    if settings.use_take_profit
+                    else None
+                ),
+            }
+        )
+
+        await self._reward_user(user_id, "buy", reason)
+
+        if self.monitor:
+            self.monitor.record_trade_success()
+
+        if self.social_marketplace and context != "copy_trade":
+            try:
+                await self.social_marketplace.handle_trader_execution(
+                    user_id,
+                    {
+                        "trade_type": "buy",
+                        "token_mint": token_mint,
+                        "token_symbol": token_symbol,
+                        "amount_sol": amount_sol,
+                        "amount_tokens": tokens_received,
+                        "price": execution_price,
+                        "position_id": position_id,
+                        "signature": signature,
+                        "bundle_id": bundle_id,
+                        "context": context,
+                        "metadata": trade_metadata,
+                    },
+                )
+            except Exception:
+                logger.exception("Failed to propagate copy trade execution")
+
+        logger.info(
+            "BUY executed | user=%s token=%s amount_sol=%.4f tokens=%.4f signature=%s",
+            user_id,
+            token_mint,
+            amount_sol,
+            tokens_received,
+            signature,
+        )
+
+        return {
+            "success": True,
+            "signature": signature,
+            "amount_sol": amount_sol,
+            "amount_tokens": tokens_received,
+            "token_decimals": token_decimals,
+            "price": execution_price,
+            "position_id": position_id,
+            "bundle_id": bundle_id,
+            "metadata": trade_metadata,
+        }
+
+
+    async def execute_sell(
+        self,
+        user_id: int,
+        token_mint: str,
+        *,
+        amount_tokens: Optional[float] = None,
+        token_symbol: Optional[str] = None,
+        reason: str = "manual",
+        context: str = "manual",
+        metadata: Optional[Dict[str, Any]] = None,
+    ) -> Dict:
+        """Execute a token -> SOL swap for an open position."""
+
+        position = await self.db.get_position_by_token(user_id, token_mint)
+        if not position:
+            return {
+                "success": False,
+                "error": "No open position found for that token.",
+            }
+
+        settings = await self._get_user_settings(user_id)
+        slippage_bps = self._slippage_to_bps(settings.slippage_percentage)
+
+        token_decimals = position.token_decimals or 6
+        scale = 10 ** max(token_decimals, 0)
+        remaining_tokens = position.remaining_amount_tokens or position.entry_amount_tokens or 0.0
+        remaining_raw = position.remaining_amount_raw or position.entry_amount_raw or 0
+        remaining_cost = position.remaining_amount_sol or position.entry_amount_sol or 0.0
+        realized_amount_sol = position.realized_amount_sol or 0.0
+        realized_pnl_total = position.realized_pnl_sol or 0.0
+
+        if remaining_tokens <= 0 or remaining_raw <= 0:
+            return {
+                "success": False,
+                "error": "Position has no remaining balance to sell.",
+            }
+
+        if amount_tokens is None:
+            amount_tokens = remaining_tokens
+
+        if amount_tokens <= 0:
+            return {"success": False, "error": "Sell amount must be positive"}
+
+        if amount_tokens > remaining_tokens:
+            amount_tokens = remaining_tokens
+
+        amount_raw = int(round(amount_tokens * scale))
+        if amount_raw <= 0:
+            amount_raw = remaining_raw
+            amount_tokens = remaining_tokens
+
+        if amount_raw > remaining_raw:
+            amount_raw = remaining_raw
+            amount_tokens = remaining_raw / scale if scale else remaining_tokens
+
+        proportion = amount_raw / remaining_raw if remaining_raw else 1.0
+        cost_to_release = remaining_cost * proportion
+
+        keypair = await self.wallet_manager.get_user_keypair(user_id)
+        if not keypair:
+            return {"success": False, "error": "Wallet unavailable for trading"}
+
+        result = await self.jupiter.execute_swap(
+            token_mint,
+            self.SOL_MINT,
+            amount_raw,
+            keypair,
+            slippage_bps=slippage_bps,
+        )
+
+        if not result.get("success"):
+            await self._record_failed_trade(result.get("error", "Unknown error"))
+            await self._persist_trade_record(
+                user_id,
+                token_mint,
+                token_symbol,
+                0.0,
+                amount_tokens,
+                "sell",
+                success=False,
+                error_message=result.get("error"),
+                position_id=position.position_id,
+                context=context,
+                metadata=metadata,
+            )
+            return {"success": False, "error": result.get("error", "Swap failed")}
+
+        signature = result.get("signature")
+        sol_received = self._convert_amount(int(result.get("output_amount", 0)), 9)
+        price = self._calculate_price(sol_received, amount_tokens)
+        trade_metadata = metadata or {}
+
+        new_remaining_raw = max(remaining_raw - amount_raw, 0)
+        new_remaining_tokens = max(remaining_tokens - amount_tokens, 0.0)
+        new_remaining_cost = max(remaining_cost - cost_to_release, 0.0)
+        realized_amount_sol += sol_received
+        realized_pnl_total += sol_received - cost_to_release
+        pnl_value = sol_received - cost_to_release
+
+        position_closed = new_remaining_tokens <= 1e-9 or new_remaining_raw <= 0
+        serialized_metadata = self._serialize_metadata(trade_metadata)
+
+        if position_closed:
+            total_tokens = position.entry_amount_tokens or (remaining_tokens + amount_tokens)
+            total_raw = position.entry_amount_raw or (remaining_raw + amount_raw)
+            position_updates = {
+                "exit_price": price or 0.0,
+                "exit_amount_sol": realized_amount_sol,
+                "exit_amount_tokens": total_tokens,
+                "exit_amount_raw": total_raw,
+                "exit_signature": signature,
+                "exit_timestamp": datetime.utcnow(),
+                "remaining_amount_sol": 0.0,
+                "remaining_amount_tokens": 0.0,
+                "remaining_amount_raw": 0,
+                "realized_pnl_sol": realized_pnl_total,
+                "realized_amount_sol": realized_amount_sol,
+            }
+            if serialized_metadata is not None:
+                position_updates["metadata_json"] = serialized_metadata
+
+            closed_position = await self.db.close_position(
+                position.position_id,
+                position_updates,
+            )
+
+            if closed_position and closed_position.pnl_sol is not None:
+                pnl_value = closed_position.pnl_sol
+            else:
+                pnl_value = realized_pnl_total
+        else:
+            updates = {
+                "remaining_amount_sol": new_remaining_cost,
+                "remaining_amount_tokens": new_remaining_tokens,
+                "remaining_amount_raw": new_remaining_raw,
+                "realized_pnl_sol": realized_pnl_total,
+                "realized_amount_sol": realized_amount_sol,
+            }
+            if serialized_metadata is not None:
+                updates["metadata_json"] = serialized_metadata
+
+            await self.db.update_position_partial(position.position_id, updates)
+
+        await self._persist_trade_record(
+            user_id,
+            token_mint,
+            token_symbol,
+            sol_received,
+            amount_tokens,
+            "sell",
+            signature=signature,
+            price=price,
+            slippage=settings.slippage_percentage,
+            price_impact=result.get("price_impact"),
+            position_id=position.position_id,
+            is_position_open=not position_closed,
+            context=context,
+            metadata=trade_metadata,
+        )
+
+        await self._reward_user(user_id, "sell", reason, pnl=pnl_value)
+
+        if self.social_marketplace and context != "copy_trade":
+            try:
+                await self.social_marketplace.handle_trader_execution(
+                    user_id,
+                    {
+                        "trade_type": "sell",
+                        "token_mint": token_mint,
+                        "token_symbol": token_symbol,
+                        "amount_sol": sol_received,
+                        "amount_tokens": amount_tokens,
+                        "price": price,
+                        "position_id": position.position_id,
+                        "signature": signature,
+                        "pnl": pnl_value,
+                        "context": context,
+                        "metadata": trade_metadata,
+                    },
+                )
+            except Exception:
+                logger.exception("Failed to propagate copy trade sell execution")
+
+        if self.social_marketplace:
+            await self.social_marketplace.update_trader_stats(
+                user_id,
+                {"pnl": pnl_value},
+            )
+
+        if self.monitor:
+            self.monitor.record_trade_success()
+
+        logger.info(
+            "SELL executed | user=%s token=%s amount_tokens=%.4f sol_received=%.4f signature=%s",
+            user_id,
+            token_mint,
+            amount_tokens,
+            sol_received,
+            signature,
+        )
+
+        return {
+            "success": True,
+            "signature": signature,
+            "amount_sol": sol_received,
+            "amount_tokens": amount_tokens,
+            "price": price,
+            "position_id": position.position_id,
+            "pnl": pnl_value,
+            "closed": position_closed,
+        }
+
+    async def _persist_trade_record(
+        self,
+        user_id: int,
+        token_mint: str,
+        token_symbol: Optional[str],
+        amount_sol: float,
+        amount_tokens: float,
+        trade_type: str,
+        *,
+        signature: Optional[str] = None,
+        price: Optional[float] = None,
+        slippage: Optional[float] = None,
+        price_impact: Optional[float] = None,
+        success: bool = True,
+        error_message: Optional[str] = None,
+        position_id: Optional[str] = None,
+        is_position_open: bool = True,
+        context: str = "manual",
+        metadata: Optional[Dict[str, Any]] = None,
+    ) -> None:
+        """Persist trade record in the database."""
+
+        trade_data = {
+            "user_id": user_id,
+            "signature": signature or self._build_position_id(user_id, token_mint),
+            "trade_type": trade_type,
+            "token_mint": token_mint,
+            "token_symbol": token_symbol or token_mint[:6],
+            "amount_sol": amount_sol,
+            "amount_tokens": amount_tokens,
+            "price": price,
+            "slippage": slippage,
+            "price_impact": price_impact,
+            "timestamp": datetime.utcnow(),
+            "success": success,
+            "error_message": error_message,
+            "position_id": position_id,
+            "is_position_open": is_position_open,
+            "context": context,
+            "metadata_json": self._serialize_metadata(metadata),
+        }
+
+        await self.db.add_trade(trade_data)
+
+    async def _reward_user(
+        self,
+        user_id: int,
+        trade_type: str,
+        reason: str,
+        *,
+        pnl: float = 0.0,
+    ) -> None:
+        if not self.rewards:
+            return
+
+        await self.rewards.award_points(
+            user_id,
+            REWARD_POINTS.get("successful_trade", 10),
+            f"{reason}:{trade_type}",
+        )
+
+    async def _record_failed_trade(self, error: str) -> None:
+        if self.monitor:
+            self.monitor.record_trade_failure(error)
+
+    async def _get_user_settings(self, user_id: int) -> SimpleNamespace:
+        settings = await self.db.get_user_settings(user_id)
+        if settings:
+            return settings
+
+        if self._default_user_settings is not None:
+            return await self.db.ensure_user_settings(user_id, self._default_user_settings)
+
+        return SimpleNamespace(
+            max_trade_size_sol=1.0,
+            daily_loss_limit_sol=5.0,
+            slippage_percentage=5.0,
+            require_confirmation=True,
+            use_stop_loss=True,
+            default_stop_loss_percentage=10.0,
+            use_take_profit=True,
+            default_take_profit_percentage=20.0,
+            check_honeypots=True,
+            min_liquidity_usd=10000.0,
+        )
+
+    def _extract_decimals(self, quote: Optional[Dict]) -> int:
+        if not quote:
+            return 6
+
+        if "outDecimals" in quote:
+            try:
+                return int(quote["outDecimals"])
+            except (ValueError, TypeError):
+                pass
+
+        route_plan = quote.get("routePlan") if isinstance(quote, dict) else None
+        if route_plan:
+            for leg in route_plan:
+                swap_info = leg.get("swapInfo", {}) if isinstance(leg, dict) else {}
+                decimals = swap_info.get("outDecimals")
+                if decimals is not None:
+                    try:
+                        return int(decimals)
+                    except (ValueError, TypeError):
+                        continue
+
+        return 6
+
+    def _convert_amount(self, amount: int, decimals: int) -> float:
+        try:
+            scale = 10 ** max(decimals, 0)
+        except OverflowError:
+            scale = 1
+        return amount / scale if scale else float(amount)
+
+    def _calculate_price(self, sol_amount: float, token_amount: float) -> Optional[float]:
+        if token_amount and token_amount > 0:
+            return sol_amount / token_amount
+        return None
+
+    def _slippage_to_bps(self, slippage_percentage: Optional[float]) -> int:
+        if slippage_percentage is None:
+            return 50
+        return max(1, int(slippage_percentage * 100))
+
+    def _build_position_id(self, user_id: int, token_mint: str) -> str:
+        return f"{user_id}-{token_mint}-{datetime.utcnow().timestamp()}"
+
+    def _serialize_metadata(self, metadata: Optional[Dict[str, Any]]) -> Optional[str]:
+        if not metadata:
+            return None
+
+        try:
+            return json.dumps(metadata)
+        except (TypeError, ValueError):
+            logger.debug("Failed to serialize trade metadata", exc_info=True)
+            return None
+
diff --git a/src/modules/wallet_manager.py b/src/modules/wallet_manager.py
index f790b9f4b8ab358cf26c2b379f1fb29064560eec..a33223fc3dfea3755349397e0e980960e73ca17b 100644
--- a/src/modules/wallet_manager.py
+++ b/src/modules/wallet_manager.py
@@ -1,148 +1,195 @@
 """
 USER WALLET MANAGEMENT
 Each user gets their own dedicated trading wallet
 Secure encryption of private keys
 """
 
 import os
 import base58
 import logging
-from typing import Optional, Dict
+from typing import Optional, Dict, Union
 from datetime import datetime
 from cryptography.fernet import Fernet
 from solders.keypair import Keypair
 from solana.rpc.async_api import AsyncClient
 from sqlalchemy import select
 
 from src.modules.database import UserWallet, DatabaseManager
 
 logger = logging.getLogger(__name__)
 
 
 class WalletEncryption:
     """Handles encryption/decryption of wallet private keys"""
     
-    def __init__(self):
-        # Get or generate master encryption key
-        self.master_key = self._get_or_create_master_key()
+    def __init__(self, master_key: Optional[Union[str, bytes]] = None):
+        """Initialize wallet encryption helper.
+
+        Args:
+            master_key: Optional override for the Fernet key. When not provided
+                the value is read from ``WALLET_ENCRYPTION_KEY``. The key must
+                be a url-safe base64 encoded 32-byte string as required by
+                :class:`cryptography.fernet.Fernet`.
+        """
+
+        self.master_key = self._load_master_key(master_key)
         self.fernet = Fernet(self.master_key)
-    
-    def _get_or_create_master_key(self) -> bytes:
-        """Get master key from env or generate new one"""
+
+    @staticmethod
+    def generate_key() -> str:
+        """Generate a new wallet encryption key."""
+
+        return Fernet.generate_key().decode()
+
+    @staticmethod
+    def validate_key(key: Union[str, bytes]) -> bytes:
+        """Validate that the provided key is a proper Fernet key."""
+
+        if not key:
+            raise ValueError("Wallet encryption key cannot be empty")
+
+        key_bytes = key if isinstance(key, bytes) else key.encode()
+
+        try:
+            # Instantiating Fernet validates the key structure
+            Fernet(key_bytes)
+        except Exception as exc:  # pragma: no cover - cryptography raises ValueError
+            raise ValueError(
+                "Invalid WALLET_ENCRYPTION_KEY provided. The key must be a "
+                "urlsafe base64-encoded 32-byte string. Generate one with "
+                "WalletEncryption.generate_key() or the rotate_wallet_key.py "
+                "utility."
+            ) from exc
+
+        return key_bytes
+
+    def _load_master_key(self, master_key: Optional[Union[str, bytes]]) -> bytes:
+        """Load the master key from an override or the environment."""
+
+        if master_key is not None:
+            return self.validate_key(master_key)
+
         key_str = os.getenv('WALLET_ENCRYPTION_KEY')
-        
-        if key_str:
-            return key_str.encode()
-        
-        # Generate new key
-        new_key = Fernet.generate_key()
-        logger.warning("Generated new wallet encryption key. Add to .env:")
-        logger.warning(f"WALLET_ENCRYPTION_KEY={new_key.decode()}")
-        return new_key
+        if not key_str:
+            raise RuntimeError(
+                "WALLET_ENCRYPTION_KEY environment variable is required. "
+                "Set it to a Fernet key before starting the bot. Use the "
+                "scripts/rotate_wallet_key.py tool to generate or rotate "
+                "keys and store them securely (for example in a secrets "
+                "manager or HSM)."
+            )
+
+        return self.validate_key(key_str)
     
     def encrypt_private_key(self, private_key_bytes: bytes) -> str:
         """Encrypt private key"""
         return self.fernet.encrypt(private_key_bytes).decode()
     
     def decrypt_private_key(self, encrypted_key: str) -> bytes:
         """Decrypt private key"""
         return self.fernet.decrypt(encrypted_key.encode())
 
 
 class UserWalletManager:
     """
     Manages individual user wallets
     Each user gets their own Solana wallet for trading
     """
     
-    def __init__(self, db: DatabaseManager, rpc_client: AsyncClient):
+    def __init__(self, db: DatabaseManager, rpc_client: AsyncClient, default_user_settings: Optional[Dict] = None):
         self.db = db
         self.client = rpc_client
         self.encryption = WalletEncryption()
         self._wallet_cache = {}  # Cache keypairs in memory
+        self._default_user_settings = dict(default_user_settings) if default_user_settings else None
     
     async def get_or_create_user_wallet(
         self,
         user_id: int,
         username: str = None
     ) -> Dict:
         """
         Get existing wallet or create new one for user
         
         Returns:
             Dict with public_key, sol_balance, is_new
         """
         # Check if user already has wallet
         logger.info(f"ğŸ” Looking for existing wallet for user {user_id}...")
         wallet = await self._get_wallet_from_db(user_id)
         
         if wallet:
             logger.info(f"âœ… Found existing wallet: {wallet.public_key}")
-        
-        if wallet:
-            # Update balance
+
+            if self._default_user_settings is not None:
+                await self.db.ensure_user_settings(user_id, self._default_user_settings)
+
+            # Update balance from chain
             balance = await self._get_sol_balance(wallet.public_key)
-            
+
             async with self.db.async_session() as session:
                 wallet.sol_balance = balance
                 wallet.last_balance_update = datetime.utcnow()
                 wallet.last_used = datetime.utcnow()
                 await session.commit()
-            
+
             return {
                 'public_key': wallet.public_key,
                 'sol_balance': balance,
                 'is_new': False,
                 'created_at': wallet.created_at
             }
         
         # Create new wallet for user
         logger.warning(f"âš ï¸ No existing wallet found for user {user_id}")
         logger.info(f"Creating new wallet for user {user_id}")
         
         # Generate new Solana keypair
         keypair = Keypair()
         public_key = str(keypair.pubkey())
         private_key_bytes = bytes(keypair)
         
         # Encrypt private key
         encrypted_key = self.encryption.encrypt_private_key(private_key_bytes)
         
         # Save to database
         async with self.db.async_session() as session:
             user_wallet = UserWallet(
                 user_id=user_id,
                 telegram_username=username,
                 public_key=public_key,
                 encrypted_private_key=encrypted_key,
                 sol_balance=0.0,
                 last_balance_update=datetime.utcnow()
             )
             session.add(user_wallet)
             await session.commit()
         
+        if self._default_user_settings is not None:
+            await self.db.ensure_user_settings(user_id, self._default_user_settings)
+        
         # Cache the keypair
         self._wallet_cache[user_id] = keypair
         
         logger.info(f"âœ… Created wallet for user {user_id}: {public_key}")
         
         return {
             'public_key': public_key,
             'sol_balance': 0.0,
             'is_new': True,
             'created_at': datetime.utcnow()
         }
     
     async def get_user_keypair(self, user_id: int) -> Optional[Keypair]:
         """
         Get user's keypair for signing transactions
         Decrypts from database and caches in memory
         """
         # Check cache first
         if user_id in self._wallet_cache:
             return self._wallet_cache[user_id]
         
         # Get from database
         wallet = await self._get_wallet_from_db(user_id)
         if not wallet:
             return None
diff --git a/tests/bot_functionality_test.py b/tests/bot_functionality_test.py
index 2745f9221b4c310e2388643ebbf33d2439be2494..259502600f2d0541f70f278f0418c9895e006480 100644
--- a/tests/bot_functionality_test.py
+++ b/tests/bot_functionality_test.py
@@ -35,50 +35,51 @@ class BotFunctionalityTester:
             'social_trading': {},
             'auto_sniper': {},
             'sentiment_features': {},
             'rewards': {},
             'inline_buttons': {},
             'overall_status': 'PENDING'
         }
         self.test_user_id = 999999999  # Test user ID
         self.test_token = "So11111111111111111111111111111111111111112"  # SOL token for testing
         
     async def setup(self):
         """Initialize all bot components"""
         print("[*] Setting up test environment...")
         
         try:
             # Initialize core components
             self.rpc_url = os.getenv('SOLANA_RPC_URL', 'https://api.mainnet-beta.solana.com')
             self.client = AsyncClient(self.rpc_url)
             self.db = DatabaseManager()
             await self.db.init_db()
             
             # Initialize modules
             self.wallet_manager = UserWalletManager(self.db, self.client)
             self.ai_manager = AIStrategyManager()
             self.social_marketplace = SocialTradingMarketplace(self.db)
+            await self.social_marketplace.initialize()
             self.community_intel = CommunityIntelligence()
             self.rewards = RewardSystem()
             
             # Initialize sentiment (may not have API keys)
             try:
                 self.sentiment_analyzer = SocialMediaAggregator(
                     twitter_api_key=os.getenv('TWITTER_API_KEY'),
                     reddit_credentials={
                         'client_id': os.getenv('REDDIT_CLIENT_ID'),
                         'client_secret': os.getenv('REDDIT_CLIENT_SECRET')
                     },
                     discord_token=os.getenv('DISCORD_TOKEN')
                 )
                 self.trend_detector = TrendDetector()
             except:
                 self.sentiment_analyzer = None
                 self.trend_detector = None
             
             print("[OK] Test environment ready\n")
             return True
             
         except Exception as e:
             print(f"[ERROR] Setup failed: {e}")
             return False
     
@@ -335,60 +336,88 @@ class BotFunctionalityTester:
             except Exception as e:
                 self.results['ai_analysis'][token_name] = {
                     'success': False,
                     'message': f'Exception: {str(e)}'
                 }
                 print(f"[FAIL] - {token_name}: {str(e)}")
     
     async def _test_token_analysis(self, token_mint: str, token_name: str):
         """Test AI analysis for a specific token"""
         try:
             # Mock token data (in production, this would fetch real data)
             token_data = {
                 'address': token_mint,
                 'symbol': token_name,
                 'liquidity_usd': 50000,
                 'volume_24h': 100000,
                 'price_change_1h': 5.0,
                 'price_change_24h': 10.0,
                 'holder_count': 500,
                 'top_10_holder_percentage': 30,
                 'transaction_count_1h': 100,
                 'buy_sell_ratio': 1.5,
                 'market_cap': 1000000,
                 'age_hours': 48,
                 'social_mentions': 50,
-                'sentiment_score': 65
+                'sentiment_score': 65,
+                'social_score': 70,
+                'community_score': 60
             }
-            
+
             # Get portfolio value
             portfolio_value = 1.0  # Mock value
-            
+
+            sentiment_snapshot = {
+                'sentiment_score': 72,
+                'social_score': 78,
+                'total_mentions': 120,
+                'viral_potential': 0.45,
+                'overall_recommendation': 'buy',
+                'twitter': {'mentions': 80, 'trending': True, 'sentiment_score': 74, 'influencer_mentions': 2},
+                'reddit': {'posts': 20, 'comments': 15, 'sentiment_score': 68},
+                'discord': {'mentions': 5, 'sentiment_score': 70}
+            }
+
+            community_signal = {
+                'community_score': 68,
+                'avg_rating': 4.2,
+                'total_ratings': 18,
+                'flag_count': 1,
+                'sentiment': 'positive'
+            }
+
+            token_data['sentiment_score'] = sentiment_snapshot['sentiment_score']
+            token_data['social_mentions'] = sentiment_snapshot['total_mentions']
+            token_data['social_score'] = sentiment_snapshot['social_score']
+            token_data['community_score'] = community_signal['community_score']
+
             # Run AI analysis
             ai_analysis = await self.ai_manager.analyze_opportunity(
                 token_data,
-                portfolio_value
+                portfolio_value,
+                sentiment_snapshot=sentiment_snapshot,
+                community_signal=community_signal
             )
             
             if ai_analysis and 'action' in ai_analysis:
                 return {
                     'success': True,
                     'message': f'AI Analysis complete - Action: {ai_analysis["action"]}, Confidence: {ai_analysis["confidence"]:.1%}',
                     'analysis': ai_analysis
                 }
             else:
                 return {
                     'success': False,
                     'message': 'AI analysis returned incomplete data'
                 }
                 
         except Exception as e:
             return {
                 'success': False,
                 'message': f'Error: {str(e)}'
             }
     
     async def test_social_trading(self):
         """Test social trading features"""
         print("\n" + "="*60)
         print("TEST 4: SOCIAL TRADING FEATURES")
         print("="*60)
diff --git a/tests/conftest.py b/tests/conftest.py
index 741b7f15ab28fbaced4a04fc3effa8e1caeb564e..6f599e24ad41afa5adf4c74d490e2ee0d13729b7 100644
--- a/tests/conftest.py
+++ b/tests/conftest.py
@@ -1,34 +1,39 @@
 """
 Pytest configuration and fixtures
 """
 
+import os
+
 import pytest
 import asyncio
 from unittest.mock import Mock, AsyncMock
 
 
+os.environ.setdefault("WALLET_ENCRYPTION_KEY", "dLchbDvo1g_JUTokdPNfKM2-tP32T7kL6YwEH54oFsY=")
+
+
 @pytest.fixture(scope="session")
 def event_loop():
     """Create an event loop for the test session"""
     loop = asyncio.get_event_loop_policy().new_event_loop()
     yield loop
     loop.close()
 
 
 @pytest.fixture
 def mock_config():
     """Mock configuration"""
     from src.config import Config, TradingConfig
     
     trading = TradingConfig(
         max_slippage=5.0,
         default_buy_amount_sol=0.1,
         min_profit_percentage=2.0,
         max_trade_size_sol=1.0,
         daily_loss_limit_sol=5.0,
         require_confirmation=True,
         min_liquidity_usd=10000.0,
         check_mint_authority=True,
         check_freeze_authority=True,
     )
     
diff --git a/tests/test_copy_trading.py b/tests/test_copy_trading.py
index 09855327d25cf32668b4ddbfcad57ed4464aad03..effe4c9e03c76a1add407d59624acf29a893fbf8 100644
--- a/tests/test_copy_trading.py
+++ b/tests/test_copy_trading.py
@@ -342,51 +342,54 @@ class CopyTradingTester:
             logger.info(f"\nğŸ” Getting community consensus...\n")
             
             consensus = await self.community_intel.get_token_rating(test_token)
             
             logger.info(f"ğŸ“Š COMMUNITY RATING:")
             logger.info(f"   Token: {test_token[:8]}...")
             logger.info(f"   Average: {consensus['avg_rating']:.1f}/10")
             logger.info(f"   Ratings: {consensus['rating_count']}")
             logger.info(f"   Confidence: {consensus['confidence']:.0f}%")
             logger.info(f"   Recommendation: {consensus['recommendation'].upper()}")
             
             logger.info(f"\nâœ… COMMUNITY INTELLIGENCE WORKING!")
             return True
             
         except Exception as e:
             logger.error(f"âŒ Community intelligence test failed: {e}")
             return False
     
     async def run_comprehensive_test(self):
         """
         Run all copy trading tests
         """
         logger.info("\n" + "="*60)
         logger.info("ğŸš€ COPY TRADING & SOCIAL MARKETPLACE TEST")
         logger.info("="*60 + "\n")
-        
+
+        await self.db.init_db()
+        await self.social_marketplace.initialize()
+
         results = {}
         
         # Test 1: Trader registration
         results['registration'] = await self.test_trader_registration()
         
         # Test 2: /copy command
         results['copy_command'] = await self.test_copy_command()
         
         # Test 3: Auto-copy execution
         results['auto_copy'] = await self.test_auto_copy_execution()
         
         # Test 4: Leaderboard
         results['leaderboard'] = await self.test_leaderboard()
         
         # Test 5: Strategy marketplace
         results['strategy_marketplace'] = await self.test_strategy_marketplace()
         
         # Test 6: Community ratings
         results['community'] = await self.test_community_ratings()
         
         # Print summary
         logger.info("\n" + "="*60)
         logger.info("ğŸ“Š TEST SUMMARY")
         logger.info("="*60)
         
diff --git a/tests/unit/test_trade_execution.py b/tests/unit/test_trade_execution.py
new file mode 100644
index 0000000000000000000000000000000000000000..29057e10cfe5ea26875952a5633351888d7df0f5
--- /dev/null
+++ b/tests/unit/test_trade_execution.py
@@ -0,0 +1,162 @@
+import pytest
+from unittest.mock import AsyncMock
+
+from solders.keypair import Keypair
+
+from src.modules.trade_execution import TradeExecutionService
+from src.modules.social_trading import RewardSystem
+
+
+class StubWalletManager:
+    def __init__(self):
+        self.keypair = Keypair()
+        self.balance = 10.0
+
+    async def get_user_keypair(self, user_id):
+        return self.keypair
+
+    async def get_user_balance(self, user_id):
+        return self.balance
+
+    async def get_user_wallet_address(self, user_id):
+        return str(self.keypair.pubkey())
+
+
+class StubProtection:
+    async def comprehensive_token_check(self, token_mint: str):
+        return {"is_safe": True, "details": {"liquidity_usd": 20000}}
+
+
+class StubMonitor:
+    def __init__(self):
+        self.success = 0
+        self.failure = 0
+
+    def record_trade_success(self):
+        self.success += 1
+
+    def record_trade_failure(self, error: str):
+        self.failure += 1
+
+
+class StubMarketplace:
+    def __init__(self):
+        self.update_trader_stats = AsyncMock()
+        self.handle_trader_execution = AsyncMock(return_value=[])
+
+
+@pytest.mark.asyncio
+async def test_execute_buy_success(mock_database):
+    wallet_manager = StubWalletManager()
+
+    jupiter = AsyncMock()
+    jupiter.get_quote.return_value = {"outAmount": 500000000, "outDecimals": 6}
+    jupiter.execute_swap.return_value = {
+        "success": True,
+        "signature": "sig-buy",
+        "output_amount": 500000000,
+        "price_impact": 0.2,
+    }
+
+    service = TradeExecutionService(
+        mock_database,
+        wallet_manager,
+        jupiter,
+        protection=StubProtection(),
+        monitor=StubMonitor(),
+        social_marketplace=StubMarketplace(),
+        rewards=RewardSystem(),
+    )
+
+    result = await service.execute_buy(1, "TokenMint", 0.5, token_symbol="TEST")
+
+    assert result["success"] is True
+    assert result["signature"] == "sig-buy"
+    assert pytest.approx(result["amount_sol"], rel=1e-6) == 0.5
+
+    trades = await mock_database.get_user_trades(user_id=1)
+    assert len(trades) == 1
+    assert trades[0].trade_type == "buy"
+
+    positions = await mock_database.get_open_positions(user_id=1)
+    assert len(positions) == 1
+    assert positions[0].token_mint == "TokenMint"
+    assert positions[0].entry_amount_raw == 500000000
+
+
+@pytest.mark.asyncio
+async def test_execute_sell_success(mock_database):
+    wallet_manager = StubWalletManager()
+
+    buy_result = {
+        "success": True,
+        "signature": "sig-buy",
+        "output_amount": 400000000,
+        "price_impact": 0.1,
+    }
+    sell_result = {
+        "success": True,
+        "signature": "sig-sell",
+        "output_amount": 450000000,
+        "price_impact": 0.05,
+    }
+
+    jupiter = AsyncMock()
+    jupiter.get_quote.return_value = {"outAmount": 400000000, "outDecimals": 6}
+    jupiter.execute_swap = AsyncMock(side_effect=[buy_result, sell_result])
+
+    marketplace = StubMarketplace()
+    monitor = StubMonitor()
+
+    service = TradeExecutionService(
+        mock_database,
+        wallet_manager,
+        jupiter,
+        protection=StubProtection(),
+        monitor=monitor,
+        social_marketplace=marketplace,
+        rewards=RewardSystem(),
+    )
+
+    await service.execute_buy(1, "TokenMint", 0.4, token_symbol="TEST")
+    result = await service.execute_sell(1, "TokenMint")
+
+    assert result["success"] is True
+    assert result["signature"] == "sig-sell"
+    assert pytest.approx(result["amount_sol"], rel=1e-6) == 0.45
+    assert marketplace.update_trader_stats.await_count == 1
+    assert monitor.success >= 2
+
+    trades = await mock_database.get_user_trades(user_id=1)
+    assert len(trades) == 2
+    assert trades[-1].trade_type == "sell"
+    assert trades[-1].is_position_open is False
+
+    positions = await mock_database.get_open_positions(user_id=1)
+    assert positions == []
+
+
+@pytest.mark.asyncio
+async def test_sell_without_position(mock_database):
+    wallet_manager = StubWalletManager()
+    jupiter = AsyncMock()
+    jupiter.get_quote.return_value = {"outAmount": 400000000, "outDecimals": 6}
+    jupiter.execute_swap.return_value = {
+        "success": True,
+        "signature": "sig",
+        "output_amount": 400000000,
+    }
+
+    service = TradeExecutionService(
+        mock_database,
+        wallet_manager,
+        jupiter,
+        protection=StubProtection(),
+        monitor=StubMonitor(),
+        social_marketplace=StubMarketplace(),
+        rewards=RewardSystem(),
+    )
+
+    result = await service.execute_sell(1, "TokenMint")
+    assert result["success"] is False
+    assert "No open position" in result["error"]
diff --git a/vendor/README.md b/vendor/README.md
new file mode 100644
index 0000000000000000000000000000000000000000..dda4ae1aedeb80a1c095884ebc427f2dd2f09e3e
--- /dev/null
+++ b/vendor/README.md
@@ -0,0 +1,11 @@
+# Vendored wheelhouse
+
+The CI pipeline expects this directory to contain pre-downloaded wheels that match `requirements/dev.lock`.
+
+Populate it locally with:
+
+```bash
+python scripts/fetch_wheels.py
+```
+
+The wheels are optional for day-to-day development, but committing them ensures completely offline installs in production environments.
